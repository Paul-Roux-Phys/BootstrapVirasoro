#+title: Three Point functions of loop models: numerical data
#+author: Paul Roux
#+date: <14-05-2024>
#+property: header-args:julia :tangle three_point.jl

* Analytical prediction

We compute the following three point structure constants:

 \begin{align}
\boxed{C^\text{ref}_{(r_1,s_1)(r_2,s_2)(r_3,s_3)} =\prod_{\epsilon_1,\epsilon_2,\epsilon_3=\pm} \Gamma_\beta^{-1} \left(\tfrac{\beta+\beta^{-1}}{2} + \tfrac{\beta}{2}\left|\textstyle{\sum_i} \epsilon_ir_i\right| + \tfrac{\beta^{-1}}{2}\textstyle{\sum_i} \epsilon_is_i\right)}\ ,
 \label{cref}
\end{align}

and we use

\begin{align}
  C^{\text{ref}}_{P_{(1,1)}(r,s)^{2}} &= K \prod_{\pm, \pm}\Gamma_{\beta}^{-1}(\beta^{\pm 1} + r\beta \pm s\beta^{-1}), \\
K &=\prod_{\pm} \Gamma_{\beta}^{-2}(\beta^{\pm 1})
\end{align}

#+begin_src julia
using Pkg; Pkg.activate(".");
using JuliVirBootstrap

cs = [CentralCharge("β", i) for i in 0:0.1:1]
V1s = [Field(ci, Kac=true, r=1, s=0) for ci in cs]

β = sqrt(2/3)
tol = 1e-6
Gb(w) = double_Gamma(w, β, tol)

function factor_K(c, tol)
    β = c["β"]
    return 1/prod(double_Gamma(β^pm, β, tol) for pm in -1:2:1)^2
end

function Cref(c, V1, V2, V3, tol)
    β = c["β"]
    if (V1.isKac && V1.isdiagonal && V1.r == 1 && V1.s == 1 && V2 == V1 && V1.isdegenerate)
        r = V2.r
        s = V2.s
        println("Hello")
        return Complex{BigFloat}(factor_K(c, tol)*prod(prod(1/double_Gamma(β^pm1 + r*β + pm2*s/β, β, tol) for pm1 in -1:2:1) for pm2 in -1:2:1))
    else
        g(pms, rs, ss) = double_Gamma((β+1/β)/2 + abs(pms'rs)*β/2 + (pms'ss)/2/β, β, tol) # ' denotes the scalar product
        rs = [V1.r, V2.r, V3.r]
        ss = [V1.s, V2.s, V3.s]
        res=1
        pm = [-1, +1]
        for pm1 in pm
            for pm2 in pm
                for pm3 in pm
                    pms = [pm1, pm2, pm3]
                    res /= g(pms, rs, ss)
                end
            end
        end
        return Complex{BigFloat}(res)
    end
end

function omega(c, V1, V2, V3, tol)
    id = Field(c, Kac=true, r=1, s=1, degenerate=true, diagonal=true)
    return Cref(c, V1, V2, V3, tol) * sqrt(Cref(c, id, id, id, tol)/Cref(c, id, V1, V1, tol)/Cref(c, id, V2, V2, tol)/Cref(c, id, V3, V3, tol))
end
#+end_src
