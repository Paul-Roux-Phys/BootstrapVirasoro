<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-12 Tue 09:44 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JuliVirBootstrap Documentation</title>
<meta name="author" content="Paul ROUX" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">JuliVirBootstrap Documentation</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orged61eb7">1. Conformal bootstrap equations in 2D</a>
<ul>
<li><a href="#orgedc451b">Notations, parametrisations</a></li>
<li><a href="#org5f96a3e">Four point functions on the sphere</a>
<ul>
<li><a href="#org3ac5de1">Zamolodchikov&rsquo;s recursion for four-point blocks</a></li>
</ul>
</li>
<li><a href="#org949da86">One point functions on the torus</a>
<ul>
<li><a href="#org8c521ed">Zamolodchikov&rsquo;s recursion for torus one-point blocks</a></li>
</ul>
</li>
<li><a href="#org3ad253d">Logarithmic blocks</a></li>
<li><a href="#orge4b1bfb">Relation between sphere four-point blocks and torus one-point blocks</a></li>
<li><a href="#orgdf8f598">Crossing symmetry for four-point functions on the sphere</a></li>
<li><a href="#org886f679">Modular invariance for one-point functions on the torus</a></li>
</ul>
</li>
<li><a href="#org23657e3">2. Code of the package</a>
<ul>
<li><a href="#orgf84aaef">Main module</a></li>
<li><a href="#org2a8132f">The <code>CFTData</code> module</a>
<ul>
<li><a href="#org5eccbd3">Header</a></li>
<li><a href="#orgfb91912">Central charge</a></li>
<li><a href="#org92f472d">Fields</a></li>
<li><a href="#org08df67a">End of module</a></li>
</ul>
</li>
<li><a href="#org4746e4c">The <code>FourPointCorrelationFunctions</code> module</a></li>
<li><a href="#orgdee3545">The <code>OnePointCorrelationFunctions</code> module</a></li>
<li><a href="#org33198f0">Virasoro conformal blocks</a>
<ul>
<li><a href="#orgcc2fce6">The <code>FourPointBlocksSphere</code> module</a></li>
</ul>
</li>
<li><a href="#org7525fec">One-point conformal blocks on the torus</a>
<ul>
<li><a href="#orgc94cd32">The <code>OnePointBlocksTorus</code> module</a></li>
</ul>
</li>
<li><a href="#org54597ea">Special functions</a></li>
<li><a href="#orgc1ceafd">Unit testing</a></li>
<li><a href="#org28c8455">Development tests</a>
<ul>
<li><a href="#orga35c5ba">Relation between four-point blocks on the sphere and one-point blocks on the torus</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orged61eb7" class="outline-2">
<h2 id="orged61eb7"><span class="section-number-2">1.</span> Conformal bootstrap equations in 2D</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgedc451b" class="outline-3">
<h3 id="orgedc451b">Notations, parametrisations</h3>
<div class="outline-text-3" id="text-orgedc451b">
</div>
<ul class="org-ul">
<li><a id="org733541b"></a>Central charge<br />
<div class="outline-text-5" id="text-org733541b">
<p>
We parametrise the central charge of our theories in terms of variables \(B\), \(b\) or \(\beta\) related by
</p>

<p>
\[c = 13 + 6B + 6 B^{-1} \quad , \quad B = b^2 = -\beta^2, \quad B = \frac{c-13 \pm \sqrt{(c-1)(c-25)}}{12}\]
</p>
</div>
</li>
<li><a id="org441be97"></a>Fields<br />
<div class="outline-text-5" id="text-org441be97">
<p>
We parametrise the conformal dimensions \((\Delta, \bar\Delta)\) of fields in terms of variables \(P, p, \delta\), related by
</p>

<p>
\[
\Delta = \frac{c-1}{24} + \delta  \quad , \quad \delta = -P^2 = p^2
\]
</p>

<p>
The variable \(P\) is called the momentum. Moreover, we introduce the following parametrisation of dimensions in terms of Kac indices \(r, s\):
</p>

<p>
\[P_{(r,s)}=\frac{1}{2}(b r + b^{-1}s)\]
</p>

<p>
Or equivalently
</p>

<p>
\[p_{(r,s)} = -\frac{1}{2} (\beta r - \beta^{-1}s)\]
</p>

<p>
where \(r,s\) are arbitrary numbers. We say the field is degenerate if \(r,s\in \mathbb Z\) and \(rs > 0\).
This convention is consistent with the one in <a href="https://gitlab.com/s.g.ribault/Bootstrap_Virasoro.git">Sylvain&rsquo;s code</a>.
</p>

<p>
In loop models, we denote \(V_{(r,s)}\) a non-diagonal field of left and right momenta \((P_{(r,s)},P_{(r,-s)})\).
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5f96a3e" class="outline-3">
<h3 id="org5f96a3e">Four point functions on the sphere</h3>
<div class="outline-text-3" id="text-org5f96a3e">
<p>
Because of conformal invariance, computation of any four-point correlation function reduces to the computation of
</p>

<p>
\[ \mathcal G(x) = \langle V_{1}(x) V_{2}(0) V_{3}(\infty) V_{4}(1) \rangle \]
</p>

<p>
Four-point correlation functions can be written in terms of Virasoro blocks as
</p>

\begin{align}
  \mathcal G(x) = \sum_{k \in \mathcal S} \frac{C_{12k} C_{k34}}{B_{k}} \mathcal G_{\Delta_k}^{(s)}(c |\Delta_{1}, \dots, \Delta_{4}|z)\end{align}

<p>
We call \(\mathcal G_{\Delta_k}^{(s)}(c |\Delta_{1}, \dots, \Delta_{4}|z)\) a (non-chiral) conformal block.
In the case of a non-logarithmic theory, conformal blocks factorise as
</p>

\begin{align}
  \mathcal G_{\Delta_k}^{(s)}(c |\Delta_{1}, \dots, \Delta_{4}|z) = \left| \mathcal F^{(s)}_{\Delta_{k}}(c | \Delta_{1}, \dots, \Delta_{4} | z) \right|^{2}
\end{align}

<p>
where we have introduced the notation \(\left|\mathcal F(\Delta, z)\right|^2 = \mathcal{F}(\Delta, z) \mathcal{F}(\bar\Delta, \bar z)\), and \(\mathcal F^{(s)}_{\Delta_k}\) is called a Virasoro block (also called chiral conformal block).
</p>

<p>
The coefficients \(C_{ijk}\) are the three-point structure constants.
</p>

<p>
Conformal blocks are characterized by the normalization conditions
</p>

\begin{align}
 \mathcal{G}^{(s)}_\Delta(x) & \underset{x\to 0}{=} \left| x^{\Delta-\Delta_1-\Delta_2}\right|^2 \left(1+O(x)\right)
 \\
 \mathcal{G}^{(t)}_\Delta(x) & \underset{x\to 1}{=} \left|(1-x)^{\Delta-\Delta_1-\Delta_4}\right|^2 \left(1+O(1-x)\right)
 \\
 \mathcal{G}^{(u)}_\Delta(x) & \underset{x\to \infty}{=} \left|\left(\frac{1}{x}\right)^{\Delta+\Delta_1-\Delta_3} \right|^2\left(1+O\left(\frac{1}{x}\right)\right)
\end{align}

<p>
Together with the invariance of \(\left\langle \prod_{i=1}^4 V_{\Delta_i}(z_i) \right\rangle\) under permutations, this leads to the relations
</p>

\begin{align}
\mathcal{G}^{(t)}_{\Delta}(\Delta_1,\Delta_2,\Delta_3,\Delta_4|x)
&= (-1)^{S_1+S_2+S_3+S_4}
\mathcal{G}^{(s)}_{\Delta}(\Delta_1,\Delta_4,\Delta_3,\Delta_2|1-x)
\\
\mathcal{G}^{(u)}_\Delta(\Delta_1,\Delta_2,\Delta_3,\Delta_4|x)
&= (-1)^{S_1+S_2+S_3+S_4}
\left|x^{-2\Delta_1}\right|^2 \mathcal{G}^{(s)}_\Delta(\Delta_1,\Delta_3,\Delta_2,\Delta_4|\tfrac{1}{x})
\end{align}

<p>
where \(S=\Delta-\bar\Delta\) is the conformal spin, which we assume to be integer.
</p>
</div>
<div id="outline-container-org3ac5de1" class="outline-4">
<h4 id="org3ac5de1">Zamolodchikov&rsquo;s recursion for four-point blocks</h4>
<div class="outline-text-4" id="text-org3ac5de1">
<p>
Four-point blocks can be computed efficiently thanks to <a href="https://en.wikipedia.org/wiki/Virasoro_conformal_block">Zamolodchikov&rsquo;s recursion</a>.
</p>

<p>
We introduce a variable \(q\) related to \(z\) through
</p>

<p>
\[
z = \frac{\theta_2(q)^4}{\theta_3(q)^4}, \quad q = e^{-\pi\frac{K(1-x)}{ K(x)}}
\]
</p>

<p>
where
</p>

<p>
\[
\theta_3(q) = \sum_{n\in\mathbb{Z}} q^{n^2} \quad , \quad \theta_2(q) = 2q^\frac14\sum_{n=0}^\infty q^{n(n+1)}
\]
</p>

<p>
are Jacobi special \(\theta\)-functions, and \(K(x)\) is the elliptic \(K\) function.
</p>

<p>
In terms of these variables, our chiral \(s\)-channel conformal block is
</p>

<p>
\[
\mathcal{F}^{(s)}_{\delta}(c | \Delta_{1}, \dots, \Delta_{4} | x) =  x^{E_0} (1-x)^{E_1} \theta_3(q)^{-4E_2}
(16q)^{\delta} H_{\delta}(c | \Delta_{1},\dots, \Delta_{4} | q)
\]
</p>

<p>
where we use the exponents
</p>

<p>
\[
E_0 = -\delta_1-\delta_2-\frac{c-1}{24} \quad , \quad E_1 = -\delta_1-\delta_4-\frac{c-1}{24} \quad ,
\quad E_2 = \delta_1+\delta_2+\delta_3+\delta_4+\frac{c-1}{24}
\]
</p>

<p>
The non-trivial coefficient is the series
</p>

<p>
\[
H_{\delta}(q) = 1 + \sum_{N=1}^{N_{max}} \sum_{mn\leq N} C_{m,n}^N \frac{(16q)^N}{\delta-\delta_{(m,n)}}
\]
</p>

<p>
Where the coefficient \(C_{m,n}^N\) is defined by the recursive formula
</p>

<p>
\[
C^N_{m,n} = R_{m,n}\left(\delta_{N-mn,0} + \sum_{m'n'\leq N-mn} \frac{C^{N-mn}_{m',n'}}{\delta_{(m,-n)}-\delta_{(m',n')}} \right)
\]
</p>

<p>
And the coefficents \(R_{m,n}\) can be written
</p>

<p>
\[
R_{m,n} = \frac{1}{2}\frac{1}{D_{mn}}
\prod_{r\overset{2}{=} 1-m}^{m-1}
\prod_{s\overset{2}{=}1-n}^{n-1}
\sqrt{(\delta_2-\delta_1)^2 -2\delta_{(r,s)}(\delta_1+\delta_2) + \delta_{(r,s)}^2}
\sqrt{(\delta_3-\delta_4)^2 -2\delta_{(r,s)}(\delta_3+\delta_4) + \delta_{(r,s)}^2}
\]
</p>

<p>
We do not actually take square roots, because each factor appears twice, except the \((r,s)=(0,0)\) factor which is however a perfect square. The normalization factor is
</p>

\begin{equation}
\label{orgf643c13}
D_{m,n} = mn \prod_{r=1}^{m-1} r^2B \left(r^2B - \frac{n^2}{B}\right)
\prod_{s=1}^{n-1} \frac{s^2}{B}\left(\frac{s^2}{B} - m^2B\right)
\prod_{r=1}^{m-1} \prod_{s=1}^{n-1} \left(r^2B -\frac{s^2}{B} \right)^2.
\end{equation}
</div>
</div>
</div>
<div id="outline-container-org949da86" class="outline-3">
<h3 id="org949da86">One point functions on the torus</h3>
<div class="outline-text-3" id="text-org949da86">
<p>
A one-point function on the torus can be written
</p>

\begin{align}
 \mathcal G(x) = <V_{\Delta_1}(x)> = \operatorname{Tr} (q^{L_0-\frac{c}{24}} \bar q^{\bar L_{0}-\frac{c}{24}} V_{\Delta_{1}}(x))
\end{align}

<p>
Because of translation invariance, one-point functions on the torus do not depend on the field&rsquo;s position. The trace can be written as
</p>

\begin{align}
  \mathcal G(x) &= \sum_{V_{\Delta} \in \mathcal S} < V_{\sigma} | V_{\Delta_{1}}(x) |V_{\sigma}> \\
                   &= \sum_{V_{\Delta} \in \mathcal S} C_{k k x} \mathcal G_{\Delta} (\tau, c, \Delta_{1} | x)
\end{align}

<p>
The conformal block \(\mathcal G_\Delta(\tau, c, \Delta_1|x)\) again factorises for non-logarithmic theories, and we write \(\mathcal F_\Delta(\tau, c, \Delta_1 | x)\) the corresponding Virasoro block.
</p>
</div>
<div id="outline-container-org8c521ed" class="outline-4">
<h4 id="org8c521ed">Zamolodchikov&rsquo;s recursion for torus one-point blocks</h4>
<div class="outline-text-4" id="text-org8c521ed">
<p>
Like four-point blocks, torus one-point blocks can be computed recursively. We introduce \(H\) defined by
</p>

\begin{align}
  \mathcal F_{\Delta}(\tau, c, \Delta_{1} | x) = \frac{q^{\delta}}{\eta(q)} H^{\text{torus}}_{\Delta}(\tau, c, \Delta_{1} | q),
\end{align}

<p>
where \(q=e^{2i\pi \tau}\).
The recursion formula for \(H^{\text{torus}}_{\Delta}(\tau, c, \Delta_{1} | q)\) is
</p>

\begin{align}
  H_{\Delta}^{\text{torus}} (\tau, c, \Delta_{1} | q) = 1 + \sum_{N=1}^{N_{\text{max}}}\sum C^{N, \text{torus}}_{m,n} \frac{q^N}{\delta - \delta_{(m,n)}}
\end{align}

<p>
The coefficients \(C_{m,n}^{N,\text{torus}}\) have the recursive representation
</p>

\begin{equation}
\label{org2bad01e}
C^{N,\text{torus}}_{m,n} = R^{\text{torus}}_{m,n}\left(\delta_{N-mn,0} + \sum_{m'n'\leq N-mn} \frac{C^{N-mn}_{m',n'}}{\delta_{(m,-n)}-\delta_{(m',n')}} \right)
\end{equation}

<p>
An expression for the \(R_{m,n}^{\text{torus}}\) can be found on <a href="https://en.wikipedia.org/wiki/Virasoro_conformal_block">this wikipedia article</a>. It can be rewritten
</p>

<p>
\[
R_{m,n}^{\text{torus}} = \frac{1}{2 D_{m,n}} \prod_{r\overset2=1-2m}^{2m-1} \prod_{s\overset2=1-2n}^{2n-1} \sqrt{\delta_{(r,s)} - \delta_1}
\]
</p>

<p>
where we do not actually take square roots, because each factor appears twice. The normalization factor is the same \(D_{m,n}\) as in the \eqref{orgf643c13} case <a href="Dmn">Dmn</a>
</p>
</div>
</div>
</div>
<div id="outline-container-org3ad253d" class="outline-3">
<h3 id="org3ad253d">Logarithmic blocks</h3>
<div class="outline-text-3" id="text-org3ad253d">
<p>
See <a href="https://arxiv.org/abs/2007.04190">this paper</a> for more detail (<a href="file:///Users/Paul/Downloads/2007.04190.pdf">here</a> on my laptop).
</p>

<p>
In loop models the action of \(L_0\) is not diagonalisable, said otherwise some of the modules are logarithmic.
The structure of a logarithmic module is the following:
</p>

<div id="org1deff62" class="figure">
<p><img src="./imgs/logarithmic_module.png" alt="logarithmic_module.png" />
</p>
</div>

<p>
here \(\mathcal L V_{(r,s)}\) and \(\bar{\mathcal L} V_{(r,s)}\) are non-diagonal primary fields.
</p>
</div>
</div>
<div id="outline-container-orge4b1bfb" class="outline-3">
<h3 id="orge4b1bfb">Relation between sphere four-point blocks and torus one-point blocks</h3>
<div class="outline-text-3" id="text-orge4b1bfb">
<p>
The recursion formulas for torus one-point blocks and sphere four-point blocks imply that four point blocks on the sphere are related to one-point blocks on the torus through the relation
</p>

\begin{align}
H^{\text{torus}}_{P}(\tau, c | P_{1} | q^{2}) = H_{\sqrt{2}P}\left(c' \left|\left. P_{(0,\frac12)}, \frac{P_{1}}{\sqrt{2}}, P_{(0,\frac12)}, P_{(0,\frac12)} \right.\right| q \right)
\end{align}

<p>
where
</p>
<ul class="org-ul">
<li>\(c'\) is related to \(c\) via \(\beta'=\frac\beta{\sqrt 2}\).</li>
<li>Fields on the RHS have dimensions \(\Delta = \frac{c'-1}{24} - P^2\).</li>
</ul>

<p>
Our code successfully reproduces this relation:
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">import</span> Pkg; Pkg.activate(<span style="color: #718c00;">"."</span>)
<span style="color: #8959a8;">using</span> JuliVirBootstrap, BenchmarkTools, EllipticFunctions
<span style="color: #8959a8;">import</span> JuliVirBootstrap.FourPointBlocksSphere.qfromx
q = JuliVirBootstrap.FourPointBlocksSphere.qfromx(<span style="color: #f5871f; font-weight: bold;">0.05</span>)

left=<span style="color: #f5871f; font-weight: bold;">1</span>;
right=<span style="color: #f5871f; font-weight: bold;">2</span>;
c_torus = CentralCharge(<span style="color: #718c00;">"b"</span>, <span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im);
c_sphere = CentralCharge(<span style="color: #718c00;">"b"</span>, (<span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im)<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>))

P = <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im
P1 = <span style="color: #f5871f; font-weight: bold;">0.41</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1.03</span>im
V_torus_chan = Field(c_torus, <span style="color: #718c00;">"P"</span>, P, diagonal=<span style="color: #f5871f;">true</span>)
&#948;_torus = V_torus_chan[<span style="color: #718c00;">"&#948;"</span>][left]
&#948;11_torus = Field(c_torus, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>, diagonal=<span style="color: #f5871f;">true</span>)[<span style="color: #718c00;">"&#948;"</span>][left]
V_torus_ext = Field(c_torus, <span style="color: #718c00;">"P"</span>, P1, diagonal=<span style="color: #f5871f;">true</span>)
corr_torus = OnePointCorrelation

V_sphere_chan = Field(c_sphere, <span style="color: #718c00;">"P"</span>, sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>)<span style="color: #bb9200;">*</span>P, diagonal=<span style="color: #f5871f;">true</span>)
&#948;_sphere = V_sphere_chan[<span style="color: #718c00;">"&#948;"</span>][left]
&#948;21_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>, diagonal=<span style="color: #f5871f;">true</span>)[<span style="color: #718c00;">"&#948;"</span>][left]
&#948;12_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>)[<span style="color: #718c00;">"&#948;"</span>][left]
V_sphere_ext = Field(c_sphere, <span style="color: #718c00;">"P"</span>, P1<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>), diagonal=<span style="color: #f5871f;">true</span>)
VKac_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>)

corr_torus = OnePointCorrelation(c_torus, V_torus_ext)
block_torus = OnePointBlockTorus(V_torus_chan)

corr_sphere = FourPointCorrelation(c_sphere, [VKac_sphere, V_sphere_ext, VKac_sphere,VKac_sphere])
block_sphere = FourPointBlockSphere(<span style="color: #718c00;">"s"</span>, V_sphere_chan)

h1 = JuliVirBootstrap.OnePointBlocksTorus.H(q<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">5</span>, block_torus, corr_torus, left)
h2 = JuliVirBootstrap.FourPointBlocksSphere.H(q, <span style="color: #f5871f; font-weight: bold;">5</span>, block_sphere, corr_sphere, left)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia">println(<span style="color: #718c00;">"torus block = $h1"</span>)
println(<span style="color: #718c00;">"sphere block = $h2"</span>)
</pre>
</div>
<p>
torus block = 1.0000059915273005 - 1.1912765043504052e-5im
sphere block = 1.000005991527301 - 1.1912765042311957e-5im
</p>
</div>
</div>
<div id="outline-container-orgdf8f598" class="outline-3">
<h3 id="orgdf8f598">Crossing symmetry for four-point functions on the sphere</h3>
</div>

<div id="outline-container-org886f679" class="outline-3">
<h3 id="org886f679">Modular invariance for one-point functions on the torus</h3>
</div>
</div>
<div id="outline-container-org23657e3" class="outline-2">
<h2 id="org23657e3"><span class="section-number-2">2.</span> Code of the package</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgf84aaef" class="outline-3">
<h3 id="orgf84aaef">Main module</h3>
<div class="outline-text-3" id="text-orgf84aaef">
<p>
The module <code>JuliVirBootstrap</code> is the main module of this package, and it includes the sub-modules.
</p>

<ul class="org-ul">
<li><code>CFTData</code> provides types for central charges and fields.</li>
<li><code>CorrelationFunctions</code> provides types for one-point and four-point correlation functions, as well as methods for computing coefficients appearing in their conformal blocks.</li>
<li><code>VirasoroConformalBlocks</code> provides types for representing four-point conformal blocks on the sphere and one-point conformal blocks on the torus, as well as methods for computing them.</li>
</ul>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">===========================================================================================#</span>

<span style="color: #8959a8;">module</span> JuliVirBootstrap

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Central charges and fields</span>
<span style="color: #07c365;">===========================================================================================#</span>
include(<span style="color: #718c00;">"CFTData.jl"</span>)
<span style="color: #8959a8;">using</span> .CFTData
<span style="color: #8959a8;">export</span> CentralCharge, Field

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Correlation functions</span>
<span style="color: #07c365;">===========================================================================================#</span>
include(<span style="color: #718c00;">"CorrelationFunctions.jl"</span>)
<span style="color: #8959a8;">using</span> .FourPointCorrelationFunctions
<span style="color: #8959a8;">export</span> FourPointCorrelation

<span style="color: #8959a8;">using</span> .OnePointCorrelationFunctions
<span style="color: #8959a8;">export</span> OnePointCorrelation

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Conformal blocks</span>
<span style="color: #07c365;">===========================================================================================#</span>
include(<span style="color: #718c00;">"ConformalBlocks.jl"</span>)
<span style="color: #8959a8;">using</span> .FourPointBlocksSphere
<span style="color: #8959a8;">export</span> FourPointBlockSphere, F_four_point_sphere

<span style="color: #8959a8;">using</span> .OnePointBlocksTorus
<span style="color: #8959a8;">export</span> OnePointBlockTorus, F_one_point_torus


<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Special functions</span>
<span style="color: #07c365;">===========================================================================================#</span>
include(<span style="color: #718c00;">"SpecialFunctions.jl"</span>)
<span style="color: #8959a8;">export</span> log_double_gamma, double_gamma


<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org2a8132f" class="outline-3">
<h3 id="org2a8132f">The <code>CFTData</code> module</h3>
<div class="outline-text-3" id="text-org2a8132f">
<p>
The file <a href="src/CFTData.jl">CFTData.jl</a> defines
</p>
<ul class="org-ul">
<li>a struct <code>CentralCharge</code> that represents a central charge \(c\) and contains the value of the four corresponding parameters \(b, B, \beta, c\)</li>
<li>a struct <code>Field</code> that represents a field \(V\). The field can be defined from its Kac indices \(r, s\), be diagonal, logarithmic, or degenerate. The struct contains booleans for these three characteristics, as well as rationals for \(r\) and \(s\), and the pairs of (left, right) values \((\Delta, \bar \Delta)\), \((p, \bar p)\), \((\delta, \bar \delta)\), \((P, \bar P)\).</li>
</ul>
</div>
<div id="outline-container-org5eccbd3" class="outline-4">
<h4 id="org5eccbd3">Header</h4>
<div class="outline-text-4" id="text-org5eccbd3">
<div class="org-src-container">
<pre class="src src-julia">
<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">CFTData.jl contains a module CFTData that provides types representing</span>
<span style="color: #07c365;">central charges and fields in 2D CFTs with Virasoro symmetry.</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">============================================================================================#</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Provides types representing central charges and fields in CFT.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">module</span> CFTData

<span style="color: #8959a8;">using</span> Match;

<span style="color: #8959a8;">export</span> CentralCharge, Field

<span style="color: #718c00;">"""print complex numbers in latex format"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>,<span style="color: #bb9200;">::MIME</span><span style="color: #718c00;">"text/latex"</span>,z<span style="color: #bb9200;">::Complex</span>)
    print(<span style="color: #718c00;">"$(real(z)) + $(imag(z))i"</span>)
<span style="color: #8959a8;">end</span>

</pre>
</div>
</div>
</div>
<div id="outline-container-orgfb91912" class="outline-4">
<h4 id="orgfb91912">Central charge</h4>
<div class="outline-text-4" id="text-orgfb91912">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Get B from given parameter"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Bfrom</span>(parameter, value)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> parameter <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"c"</span> <span style="color: #bb9200;">=&gt;</span> (value<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">13</span><span style="color: #bb9200;">+</span>sqrt(complex((value<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">*</span>(value<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">25</span>))))<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">12</span>
        <span style="color: #718c00;">"b"</span> <span style="color: #bb9200;">=&gt;</span> value<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
        <span style="color: #718c00;">"&#946;"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #bb9200;">-</span>value<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
        <span style="color: #718c00;">"B"</span> <span style="color: #bb9200;">=&gt;</span> value
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Get asked parameter from B"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Bto</span>(parameter, value)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> parameter <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"c"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">13</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">6</span><span style="color: #bb9200;">*</span>value<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">6</span><span style="color: #bb9200;">/</span>value
        <span style="color: #718c00;">"b"</span> <span style="color: #bb9200;">=&gt;</span> sqrt(complex(value))
        <span style="color: #718c00;">"&#946;"</span> <span style="color: #bb9200;">=&gt;</span> im<span style="color: #bb9200;">*</span>sqrt(complex(value))
        <span style="color: #718c00;">"B"</span> <span style="color: #bb9200;">=&gt;</span> value
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    CentralCharge{T}</span>
<span style="color: #718c00;">Object representing the central charge.</span>
<span style="color: #718c00;">Contains the values of the 4 parameters representing it.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">CentralCharge</span>{T}

    <span style="color: #07c365;">#</span><span style="color: #07c365;">= T is the type of the parameters; either Complex{Float64} or Complex{BigFloat}</span>
<span style="color: #07c365;">    for arbitrary precision. =#</span>
    values<span style="color: #bb9200;">::Dict</span>{String, T}

<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    CentralCharge(parameter, value)</span>

<span style="color: #718c00;">Constructor function for the CentralCharge type.</span>

<span style="color: #718c00;">Given one of the four parameters `"c"`, `"b"`, `"&#946;"`, `"B"` and its value,</span>
<span style="color: #718c00;">creates an object CentralCharge{T} where T is the type of `value`.</span>

<span style="color: #718c00;"># Example</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; setprecision(BigFloat, 20, base=10)</span>
<span style="color: #718c00;">julia&gt; charge = CentralCharge("&#946;", sqrt(big(2)))</span>
<span style="color: #718c00;">Central charge :</span>
<span style="color: #718c00;">B = -2.0 + 0.0im</span>
<span style="color: #718c00;">c = -2.0 + 0.0im</span>
<span style="color: #718c00;">b = 0.0 + 1.414213562373095048804im</span>
<span style="color: #718c00;">&#946; = -1.414213562373095048804 + 0.0im</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">CentralCharge</span>(parameter = <span style="color: #718c00;">"c"</span>, value = <span style="color: #f5871f; font-weight: bold;">1</span>)
    <span style="color: #07c365;"># </span><span style="color: #07c365;">Constructor</span>
    T=typeof(AbstractFloat(real(value)))
    B=Bfrom(parameter, value)
    dict=Dict(key <span style="color: #bb9200;">=&gt;</span> Bto(key, B) <span style="color: #8959a8;">for</span> key <span style="color: #8959a8;">in</span> (<span style="color: #718c00;">"c"</span>, <span style="color: #718c00;">"b"</span>, <span style="color: #718c00;">"&#946;"</span>, <span style="color: #718c00;">"B"</span>))
    CentralCharge{complex(T)}(dict)
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgea87f55"></a>Pretty printing<br />
<div class="outline-text-5" id="text-orgea87f55">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Display an object of type CentralCharge"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, charge<span style="color: #bb9200;">::CentralCharge</span>)
    println(<span style="color: #718c00;">"Central charge:"</span>)
    <span style="color: #8959a8;">for</span> (key, value) <span style="color: #8959a8;">in</span> charge.values
        println(io, <span style="color: #718c00;">"$key = $value"</span>)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display the value of the central charge in LaTeX format"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, <span style="color: #bb9200;">::MIME</span><span style="color: #718c00;">"text/latex"</span>, charge<span style="color: #bb9200;">::CentralCharge</span>, parameter)
    <span style="color: #8959a8;">if</span> parameter<span style="color: #bb9200;">==</span><span style="color: #718c00;">"&#946;"</span>
        print(<span style="color: #718c00;">"\\beta = "</span>)
    <span style="color: #8959a8;">else</span>
        print(parameter,<span style="color: #718c00;">" = "</span>)
    <span style="color: #8959a8;">end</span>
    show(io, MIME(<span style="color: #718c00;">"text/latex"</span>), charge[parameter])
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Overload of [] to access values in charge"""</span>
Base.<span style="color: #4271ae;">getindex</span>(charge<span style="color: #bb9200;">::CentralCharge</span>, key) = charge.values[key];
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org92f472d" class="outline-4">
<h4 id="org92f472d">Fields</h4>
<div class="outline-text-4" id="text-org92f472d">
<p>
Fields can be given from any of the four parameters \(\Delta, \delta, P, p\). Optional keyword arguments lets us choose whether the field is diagonal, degenerate, logarithmic. The field can also be defined from its r and s indices using the keyword argument Kac = true.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Get p from any given parameter"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">p_from</span>(parameter, value, charge<span style="color: #bb9200;">::CentralCharge</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> parameter <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"&#916;"</span> <span style="color: #bb9200;">=&gt;</span> sqrt(complex(value <span style="color: #bb9200;">-</span> (charge[<span style="color: #718c00;">"c"</span>]<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>))
        <span style="color: #718c00;">"&#948;"</span> <span style="color: #bb9200;">=&gt;</span> sqrt(complex(value))
        <span style="color: #718c00;">"P"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #bb9200;">-</span>im<span style="color: #bb9200;">*</span>value
        <span style="color: #718c00;">"p"</span> <span style="color: #bb9200;">=&gt;</span> value
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Get all parameters from p"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">p_to</span>(parameter, value, charge<span style="color: #bb9200;">::CentralCharge</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> parameter <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"&#916;"</span> <span style="color: #bb9200;">=&gt;</span> value<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> (charge[<span style="color: #718c00;">"c"</span>]<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
        <span style="color: #718c00;">"&#948;"</span> <span style="color: #bb9200;">=&gt;</span> value<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
        <span style="color: #718c00;">"P"</span> <span style="color: #bb9200;">=&gt;</span> im<span style="color: #bb9200;">*</span>value
        <span style="color: #718c00;">"p"</span> <span style="color: #bb9200;">=&gt;</span> value
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    Field{T}</span>
<span style="color: #718c00;">Object representing a conformal field.</span>
<span style="color: #718c00;">Contains the values of the 4 parameters `"&#916;"`,`"&#948;"`,`"P"`,`"p"` for its conformal dimension,</span>
<span style="color: #718c00;">and flags saying whether the field is in the Kac table, degenerate, logarithmic or diagonal.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">Field</span>{T}

    values<span style="color: #bb9200;">::Dict</span>{String, Vector{T}}
    isKac<span style="color: #bb9200;">::Bool</span>
    r<span style="color: #bb9200;">::Rational</span>
    s<span style="color: #bb9200;">::Rational</span>
    isdegenerate<span style="color: #bb9200;">::Bool</span>
    islogarithmic<span style="color: #bb9200;">::Bool</span>
    isdiagonal<span style="color: #bb9200;">::Bool</span>

<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    Field(charge, parameter, leftvalue, rightvalue; kwargs...)</span>

<span style="color: #718c00;">Constructor function for the Field type.</span>

<span style="color: #718c00;">Given a charge `charge`, one of the four parameters `"&#916;"`, `"&#948;"`, `"P"`, `"p"` and two values,</span>
<span style="color: #718c00;">create an object Field{T} (where T is the type of the values in `charge`) that represents a</span>
<span style="color: #718c00;">field of left and right dimensions given by leftvalue and rightvalue in the chosen</span>
<span style="color: #718c00;">parametrisation.</span>

<span style="color: #718c00;"># keyword arguments:</span>

<span style="color: #718c00;">- `Kac::Bool`: if set to true, the field can be constructed from the values of its r and s</span>
<span style="color: #718c00;">indices,</span>
<span style="color: #718c00;">- `r::Rational`,`s::Rational`: used in conjunction to `Kac=true`, must be given rational</span>
<span style="color: #718c00;">values,</span>
<span style="color: #718c00;">- `logarithmic::Bool`: set to True if the field is logarithmic,</span>
<span style="color: #718c00;">- `degenerate::Bool`: set to True if the field is degenerate,</span>
<span style="color: #718c00;">- `diagonal::Bool`: set to True to get a diagonal field ; only the leftvalue needs to be</span>
<span style="color: #718c00;">given.</span>

<span style="color: #718c00;"># Examples</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; charge = CentralCharge("b", big(0.5));</span>
<span style="color: #718c00;">julia&gt; field = Field(charge, Kac=true, r=0, s=1)</span>
<span style="color: #718c00;">Non-diagonal field with Kac indices r = 0//1, s = 1//1 and (left,right) dimensions:</span>
<span style="color: #718c00;">&#916; = ( 2.5625 + 0.0im, 2.5625 + 0.0im )</span>
<span style="color: #718c00;">P = ( -0.0 - 1.0im, 0.0 + 1.0im )</span>
<span style="color: #718c00;">&#948; = ( 1.0 - 0.0im, 1.0 + 0.0im )</span>
<span style="color: #718c00;">p = ( -1.0 + 0.0im, 1.0 + 0.0im )</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; charge = CentralCharge("&#946;", 1.5+im);</span>
<span style="color: #718c00;">julia&gt; Field(charge, "&#948;", 2, 3)</span>
<span style="color: #718c00;">Non-diagonal field with (left, right) dimensions:</span>
<span style="color: #718c00;">&#916; = ( 2.1579142011834325 - 0.6789940828402367im, 3.1579142011834316 - 0.6789940828402367im )</span>
<span style="color: #718c00;">P = ( 0.0 + 1.4142135623730951im, 0.0 + 1.7320508075688772im )</span>
<span style="color: #718c00;">&#948; = ( 2.0000000000000004 + 0.0im, 2.9999999999999996 + 0.0im )</span>
<span style="color: #718c00;">p = ( 1.4142135623730951 + 0.0im, 1.7320508075688772 + 0.0im )</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; charge = CentralCharge();</span>
<span style="color: #718c00;">julia&gt; Field(charge, "&#948;", 1, diagonal=true)</span>
<span style="color: #718c00;">Diagonal field of dimension:</span>
<span style="color: #718c00;">&#916; = 1.0 + 0.0im</span>
<span style="color: #718c00;">P = 0.0 + 1.0im</span>
<span style="color: #718c00;">&#948; = 1.0 + 0.0im</span>
<span style="color: #718c00;">p = 1.0 + 0.0im</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Field</span>(
    charge<span style="color: #bb9200;">::CentralCharge</span> = CentralCharge(<span style="color: #718c00;">"c"</span>, <span style="color: #f5871f; font-weight: bold;">1</span>),
    parameter = <span style="color: #718c00;">"&#916;"</span>,
    leftvalue = <span style="color: #f5871f; font-weight: bold;">0</span>, rightvalue = <span style="color: #f5871f; font-weight: bold;">0</span>;
    Kac = <span style="color: #f5871f;">false</span>, r = <span style="color: #f5871f; font-weight: bold;">0</span>, s = <span style="color: #f5871f; font-weight: bold;">0</span>,
    logarithmic = <span style="color: #f5871f;">false</span>, degenerate = <span style="color: #f5871f;">false</span>, diagonal = <span style="color: #f5871f;">false</span>
    )

    T=typeof(charge.values[<span style="color: #718c00;">"c"</span>])   <span style="color: #07c365;">#</span><span style="color: #07c365;">dimensions have the same type as central charges</span>
    <span style="color: #8959a8;">if</span> degenerate
        Kac = <span style="color: #f5871f;">true</span>
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">if</span> Kac
        pleft = <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>(charge[<span style="color: #718c00;">"&#946;"</span>]<span style="color: #bb9200;">*</span>r <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>charge[<span style="color: #718c00;">"&#946;"</span>]<span style="color: #bb9200;">*</span>s)
        pright = <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>(charge[<span style="color: #718c00;">"&#946;"</span>]<span style="color: #bb9200;">*</span>r <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>charge[<span style="color: #718c00;">"&#946;"</span>]<span style="color: #bb9200;">*</span>s)
    <span style="color: #8959a8;">else</span>
        pleft, pright = p_from.(parameter, [leftvalue, rightvalue], Ref(charge))
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">if</span> diagonal
        pright = pleft
    <span style="color: #8959a8;">end</span>
    values = Dict(key <span style="color: #bb9200;">=&gt;</span> p_to.(key, [pleft, pright], Ref(charge))
                  <span style="color: #8959a8;">for</span> key <span style="color: #8959a8;">in</span> (<span style="color: #718c00;">"&#916;"</span>, <span style="color: #718c00;">"&#948;"</span>, <span style="color: #718c00;">"P"</span>, <span style="color: #718c00;">"p"</span>)
                      )
    Field{complex(T)}(values, Kac, r, s, degenerate, logarithmic, diagonal)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Compute the spin &#916;left - &#916;right of a field."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">spin</span>(field<span style="color: #bb9200;">::Field</span>)
    <span style="color: #07c365;">#</span><span style="color: #07c365;">Computes the spin &#916;-&#916;bar</span>
    <span style="color: #8959a8;">if</span> field.isdiagonal
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">return</span> field[<span style="color: #718c00;">"&#916;"</span>][<span style="color: #f5871f; font-weight: bold;">1</span>] <span style="color: #bb9200;">-</span> field[<span style="color: #718c00;">"&#916;"</span>][<span style="color: #f5871f; font-weight: bold;">2</span>]
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org7c9be8b"></a>Pretty printing<br />
<div class="outline-text-5" id="text-org7c9be8b">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Display field"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>,field<span style="color: #bb9200;">::Field</span>)
    <span style="color: #07c365;">#</span><span style="color: #07c365;">Print fields</span>
    <span style="color: #8959a8;">if</span> field.isdiagonal
        println(<span style="color: #718c00;">"Diagonal field of dimension:"</span>)
        <span style="color: #8959a8;">for</span> (key, value) <span style="color: #8959a8;">in</span> field.values
            println(io, <span style="color: #718c00;">"  $key = $(value[1])"</span>)
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">else</span>
        print(<span style="color: #718c00;">"Non-diagonal field "</span>)
        <span style="color: #8959a8;">if</span> field.isKac
            print(<span style="color: #718c00;">"with Kac indices r = $(field.r), s = $(field.s) and "</span>)
        <span style="color: #8959a8;">else</span>
            print(<span style="color: #718c00;">"with "</span>)
        <span style="color: #8959a8;">end</span>
        println(<span style="color: #718c00;">"(left, right) dimensions:"</span>)
        <span style="color: #8959a8;">for</span> (key, value) <span style="color: #8959a8;">in</span> field.values
            println(io, <span style="color: #718c00;">"  $key = ($(value[1]), $(value[2]))"</span>)
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display dimension of field in latex format"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>,<span style="color: #bb9200;">::MIME</span><span style="color: #718c00;">"text/latex"</span>, field<span style="color: #bb9200;">::Field</span>,parameter)
    <span style="color: #8959a8;">if</span> field.isdiagonal
        <span style="color: #8959a8;">if</span> parameter <span style="color: #bb9200;">==</span> <span style="color: #718c00;">"&#916;"</span>
            print(<span style="color: #718c00;">"\\Delta = "</span>)
        <span style="color: #8959a8;">elseif</span> parameter <span style="color: #bb9200;">==</span> <span style="color: #718c00;">"&#948;"</span>
            print(<span style="color: #718c00;">"\\delta = "</span>)
        <span style="color: #8959a8;">else</span>
            print(parameter,<span style="color: #718c00;">" = "</span>)
        <span style="color: #8959a8;">end</span>
        show(io, MIME(<span style="color: #718c00;">"text/latex"</span>), field[parameter][<span style="color: #f5871f; font-weight: bold;">1</span>])
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">if</span> parameter<span style="color: #bb9200;">==</span><span style="color: #718c00;">"&#916;"</span>
            print(<span style="color: #718c00;">"(\\Delta, \\bar\\Delta) = "</span>)
        <span style="color: #8959a8;">elseif</span> parameter<span style="color: #bb9200;">==</span><span style="color: #718c00;">"&#948;"</span>
            print(<span style="color: #718c00;">"(\\delta, \\bar\\delta) = "</span>)
        <span style="color: #8959a8;">else</span>
            print(<span style="color: #718c00;">"($parameter, \\bar$parameter) = "</span>)
        <span style="color: #8959a8;">end</span>
        print(<span style="color: #718c00;">"("</span>); show(io, MIME(<span style="color: #718c00;">"text/latex"</span>), field[parameter][<span style="color: #f5871f; font-weight: bold;">1</span>]); print(<span style="color: #718c00;">", "</span>);
        show(io, MIME(<span style="color: #718c00;">"text/latex"</span>), field[parameter][<span style="color: #f5871f; font-weight: bold;">2</span>]); print(<span style="color: #718c00;">")"</span>)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #07c365;"># </span><span style="color: #07c365;">function Base.show(io::IO, arr::Vector{Field{T}}) where {T}</span>
<span style="color: #07c365;">#     </span><span style="color: #07c365;">println(io, "Vector{Field{$T}} with $(length(arr)) elements:")</span>
<span style="color: #07c365;">#     </span><span style="color: #07c365;">for (index, field) in enumerate(arr)</span>
<span style="color: #07c365;">#         </span><span style="color: #07c365;">print(io, "$(index): ")</span>
<span style="color: #07c365;">#         </span><span style="color: #07c365;">show(io, field)</span>
<span style="color: #07c365;">#         </span><span style="color: #07c365;">println()</span>
<span style="color: #07c365;">#     </span><span style="color: #07c365;">end</span>
<span style="color: #07c365;"># </span><span style="color: #07c365;">end</span>

<span style="color: #718c00;">"""Overload []"""</span>
Base.<span style="color: #4271ae;">getindex</span>(field<span style="color: #bb9200;">::Field</span>,key) = field.values[key];
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org08df67a" class="outline-4">
<h4 id="org08df67a">End of module</h4>
<div class="outline-text-4" id="text-org08df67a">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>

<p>
The file <a href="./src/CorrelationFunctions.jl">CorrelationFunctions.jl</a> provides structs and methods for representing and computing correlation functions.
</p>

<p>
It uses the types defined in <a href="#org2a8132f">The <code>CFTData</code> module</a>.
</p>
</div>
</div>
</div>
<div id="outline-container-org4746e4c" class="outline-3">
<h3 id="org4746e4c">The <code>FourPointCorrelationFunctions</code> module</h3>
<div class="outline-text-3" id="text-org4746e4c">
<p>
The module <code>FourPointCorrelationFunctions</code> defines
</p>

<ul class="org-ul">
<li><p>
a struct <code>FourPointCorrelation</code> that represents a four point function
</p>

<p>
\[
  < V_1(0) V_2(1) V_3(\infty) V_4(x)>
  \]
</p></li>

<li>a method <code>computeCNmn</code> that computes the coefficients \(C^N_{m,n}\) which serve to compute the conformal blocks that enter the expansion of the 4-pt function.</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgab46703"></a>Header<br />
<div class="outline-text-5" id="text-orgab46703">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">===========================================================================================#</span>

<span style="color: #8959a8;">module</span> FourPointCorrelationFunctions

<span style="color: #8959a8;">export</span> FourPointCorrelation, computeCNmn

<span style="color: #8959a8;">using</span> ..CFTData
<span style="color: #8959a8;">using</span> Match
<span style="color: #8959a8;">import</span> Memoization: <span style="color: #4d4d4c; font-weight: bold;">@memoize</span>
</pre>
</div>
</div>
</li>
<li><a id="org9818817"></a>Four-point function type<br />
<div class="outline-text-5" id="text-org9818817">
<p>
We create a struct <code>FourPointCorrelation</code> for representing a four-point function on the sphere, that is, a central charge and four external fields.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Struct representing a four-point function. Contains</span>
<span style="color: #718c00;">- a central charge</span>
<span style="color: #718c00;">- 4 external fields</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">FourPointCorrelation</span>{T}
    charge<span style="color: #bb9200;">::CentralCharge</span>{T}
    fields<span style="color: #bb9200;">::Vector</span>{Field{T}}
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">FourPointCorrelation</span>(charge<span style="color: #bb9200;">::CentralCharge</span>{T}, V1, V2, V3, V4) <span style="color: #8959a8;">where</span> {T}
    <span style="color: #8959a8;">return</span> FourPointCorrelation{T}(charge, [V1, V2, V3, V4])
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display a four-point function"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>)
    println(<span style="color: #718c00;">"Four-point correlation function: &lt; V_1 V_2 V_3 V_4 &gt; where "</span>)
    print(<span style="color: #718c00;">"V_1 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>])
    print(<span style="color: #718c00;">"V_2 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">2</span>])
    print(<span style="color: #718c00;">"V_3 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">3</span>])
    print(<span style="color: #718c00;">"V_4 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">4</span>])
<span style="color: #8959a8;">end</span>

<span style="color: #07c365;"># </span><span style="color: #07c365;">explicit names for the indices of left and right dimensions</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">left</span> = <span style="color: #f5871f; font-weight: bold;">1</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">right</span> = <span style="color: #f5871f; font-weight: bold;">2</span>
</pre>
</div>
</div>
</li>
<li><a id="org3c81133"></a>Compute \(C^N_{m,n}\)<br />
<div class="outline-text-5" id="text-org3c81133">
<p>
The function <code>permute_ext_fields</code> permutes the external fields such that the first two and last two are fused together in the channel.
</p>

<p>
The <code>@memoize</code> macro stores the result of the function such that subsequent calls with the same arguments only require a memory access.
</p>

<p>
The function <code>Rmn_zero_order</code> computes the order of a zero of R, to avoid computing 0/0 in \(\frac{R_{m,n}}{\delta - \delta_{r,s}}\). At generic central charge (non-rational) \(R_{m,n}\) is zero iff one of the two pairs of fused fields have Kac indices such that \(r_1 \pm r_2 \in \{1-m, 3-m, \dots, m-1\}\) or \(s_1 \pm s_2 \in \{1-n, 3-n, \dots, n-1\}\).
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #4271ae;">double_prod_in_Dmn</span>(m, n, B) = prod(prod((r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">-</span> s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #8959a8;">for</span> s in <span style="color: #f5871f; font-weight: bold;">1</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)

<span style="color: #4271ae;">&#948;rs</span>(r, s, B) = <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">4</span> <span style="color: #bb9200;">*</span> (B<span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">*</span>s <span style="color: #bb9200;">+</span> s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B)

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Dmn</span>(m, n, B)
    <span style="color: #8959a8;">if</span> m <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> n <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">treat cases m = 1, n=1 separately</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">1</span>
    <span style="color: #8959a8;">elseif</span> m <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">return</span> n <span style="color: #bb9200;">*</span> prod(s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">*</span> (s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">-</span> m<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
    <span style="color: #8959a8;">elseif</span> n <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">return</span> m <span style="color: #bb9200;">*</span> prod(r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">*</span> (r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">-</span> n<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
    <span style="color: #8959a8;">else</span>
        f1 = prod(r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">*</span> (r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">-</span> n<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
        f2 = prod(s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">*</span> (s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">-</span> m<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
        f3 = double_prod_in_Dmn(m, n, B)
        <span style="color: #8959a8;">return</span> m<span style="color: #bb9200;">*</span>n<span style="color: #bb9200;">*</span>f1<span style="color: #bb9200;">*</span>f2<span style="color: #bb9200;">*</span>f3
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Permute the external fields to get t- or u-channels from s-channel"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">permute_ext_fields</span>(corr<span style="color: #bb9200;">::FourPointCorrelation</span>, channel)
    Vs=corr.fields
    Vs = <span style="color: #4d4d4c; font-weight: bold;">@match</span> channel <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"s"</span> <span style="color: #bb9200;">=&gt;</span> [Vs[<span style="color: #f5871f; font-weight: bold;">1</span>], Vs[<span style="color: #f5871f; font-weight: bold;">2</span>], Vs[<span style="color: #f5871f; font-weight: bold;">3</span>], Vs[<span style="color: #f5871f; font-weight: bold;">4</span>]]
        <span style="color: #718c00;">"t"</span> <span style="color: #bb9200;">=&gt;</span> [Vs[<span style="color: #f5871f; font-weight: bold;">1</span>], Vs[<span style="color: #f5871f; font-weight: bold;">4</span>], Vs[<span style="color: #f5871f; font-weight: bold;">3</span>], Vs[<span style="color: #f5871f; font-weight: bold;">2</span>]]
        <span style="color: #718c00;">"u"</span> <span style="color: #bb9200;">=&gt;</span> [Vs[<span style="color: #f5871f; font-weight: bold;">1</span>], Vs[<span style="color: #f5871f; font-weight: bold;">3</span>], Vs[<span style="color: #f5871f; font-weight: bold;">2</span>], Vs[<span style="color: #f5871f; font-weight: bold;">4</span>]]
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> FourPointCorrelation(corr.charge, Vs)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Order of a pole of Rmn, assuming the central charge is generic"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Rmn_zero_order</span>(m, n, B, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, channel)

    order=<span style="color: #f5871f; font-weight: bold;">0</span>
    V=permute_ext_fields(corr, channel).fields

    <span style="color: #8959a8;">if</span><span style="color: #bb9200;"> !</span>((V[<span style="color: #f5871f; font-weight: bold;">1</span>].isKac <span style="color: #bb9200;">&amp;&amp;</span> V[<span style="color: #f5871f; font-weight: bold;">2</span>].isKac) <span style="color: #bb9200;">||</span> (V[<span style="color: #f5871f; font-weight: bold;">3</span>].isKac <span style="color: #bb9200;">&amp;&amp;</span> V[<span style="color: #f5871f; font-weight: bold;">4</span>].isKac))
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">end</span>

    r=[V[i].r <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>]
    s=[V[i].s <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>]

    <span style="color: #07c365;">#</span><span style="color: #07c365;">= Rmn is zero if r1 \pm r2 or r3 \pm r4 is an integer in 1-m:2:m-1, and</span>
<span style="color: #07c365;">    s1 \pm s2 or s3 \pm s4 is an integer in 1-n:2:n-1.</span>
<span style="color: #07c365;">    equivalently, if (|r1 \pm r2| &lt;= m-1 and r1-r2 - (m-1) % 2 == 0)</span>
<span style="color: #07c365;">    and (|s1 \pm s2| &lt;= n-1 and s1-s2 - (n-1) % 2 == 0)</span>
<span style="color: #07c365;">    =#</span>
    <span style="color: #8959a8;">for</span> pm <span style="color: #8959a8;">in</span> (<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">1</span>)
        <span style="color: #8959a8;">for</span> (i,j) <span style="color: #8959a8;">in</span> ((<span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">2</span>),(<span style="color: #f5871f; font-weight: bold;">3</span>,<span style="color: #f5871f; font-weight: bold;">4</span>))
            <span style="color: #8959a8;">if</span> V[i].isdegenerate <span style="color: #bb9200;">&amp;&amp;</span> V[j].isdegenerate
                <span style="color: #8959a8;">if</span> (abs(r[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>r[j]) <span style="color: #bb9200;">&lt;=</span> m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> (r[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>r[j]<span style="color: #bb9200;">-</span>(m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>))<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span>) <span style="color: #bb9200;">&amp;&amp;</span>
                    (abs(s[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>s[j]) <span style="color: #bb9200;">&lt;=</span> n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> (s[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>s[j]<span style="color: #bb9200;">-</span>(n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>))<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span>)
                    order <span style="color: #bb9200;">+=</span> <span style="color: #f5871f; font-weight: bold;">1</span>
                <span style="color: #8959a8;">end</span>
            <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>

    <span style="color: #8959a8;">return</span> order
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">helper_Rmn</span>(&#948;1, &#948;2, &#948;3, &#948;4, r, s, B)
    <span style="color: #8959a8;">if</span> r <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">&amp;&amp;</span> s <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> (&#948;2<span style="color: #bb9200;">-</span>&#948;1)<span style="color: #bb9200;">*</span>(&#948;3<span style="color: #bb9200;">-</span>&#948;4)
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">return</span> (((&#948;2<span style="color: #bb9200;">-</span>&#948;1)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#948;rs(r, s, B)<span style="color: #bb9200;">*</span>(&#948;1<span style="color: #bb9200;">+</span>&#948;2) <span style="color: #bb9200;">+</span> &#948;rs(r, s, B)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)
                <span style="color: #bb9200;">*</span>((&#948;3<span style="color: #bb9200;">-</span>&#948;4)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#948;rs(r, s, B)<span style="color: #bb9200;">*</span>(&#948;3<span style="color: #bb9200;">+</span>&#948;4) <span style="color: #bb9200;">+</span> &#948;rs(r, s, B)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>))
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Compute `Rmn`.</span>
<span style="color: #718c00;">lr indicates the left or right moving parts of the fields</span>
<span style="color: #718c00;">Cache the result.</span>
<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> value of regularisation</span>
<span style="color: #718c00;">"""</span>
<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> <span style="color: #8959a8;">function</span> Rmn(m, n, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, channel, lr)

    B = corr.charge[<span style="color: #718c00;">"B"</span>]
    Vs = permute_ext_fields(corr, channel).fields
    &#948;1 = Vs[<span style="color: #f5871f; font-weight: bold;">1</span>][<span style="color: #718c00;">"&#948;"</span>][lr]
    &#948;2 = Vs[<span style="color: #f5871f; font-weight: bold;">2</span>][<span style="color: #718c00;">"&#948;"</span>][lr]
    &#948;3 = Vs[<span style="color: #f5871f; font-weight: bold;">3</span>][<span style="color: #718c00;">"&#948;"</span>][lr]
    &#948;4 = Vs[<span style="color: #f5871f; font-weight: bold;">4</span>][<span style="color: #718c00;">"&#948;"</span>][lr]

    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, B, corr, channel) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">if</span> m <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span>
            res = prod(helper_Rmn(&#948;1, &#948;2, &#948;3, &#948;4, <span style="color: #f5871f; font-weight: bold;">0</span>, s, B) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">0</span>)
        <span style="color: #8959a8;">else</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">m &gt; 1</span>
            res = prod(prod(helper_Rmn(&#948;1, &#948;2, &#948;3, &#948;4, r, s, B)
                            <span style="color: #8959a8;">for</span> s in <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>m:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
            <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">m odd -&gt; treat r=0 term separately</span>
                res <span style="color: #bb9200;">*=</span> prod(helper_Rmn(&#948;1, &#948;2, &#948;3, &#948;4, <span style="color: #f5871f; font-weight: bold;">0</span>, s, B) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">0</span>)
            <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>

    <span style="color: #8959a8;">return</span> res<span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>Dmn(m, n, B))
<span style="color: #8959a8;">end</span>

<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> <span style="color: #8959a8;">function</span> computeCNmn(N, m, n, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, channel, lr)
    B = corr.charge[<span style="color: #718c00;">"B"</span>]
    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, B, corr, channel) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">elseif</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&gt;</span> N
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">elseif</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">==</span> N
        <span style="color: #8959a8;">return</span> Rmn(m, n, corr, channel, lr)
    <span style="color: #8959a8;">else</span>
        res = sum(sum(computeCNmn(N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n, mp, np, corr, channel, lr)<span style="color: #bb9200;">/</span>(&#948;rs(m, <span style="color: #bb9200;">-</span>n, B) <span style="color: #bb9200;">-</span> &#948;rs(mp, np, B))
                      <span style="color: #8959a8;">for</span> mp <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n <span style="color: #8959a8;">if</span> mp<span style="color: #bb9200;">*</span>np <span style="color: #bb9200;">&lt;=</span> N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
                  <span style="color: #8959a8;">for</span> np <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
        <span style="color: #8959a8;">return</span> Rmn(m, n, corr, channel, lr) <span style="color: #bb9200;">*</span> res
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org43af5d5"></a>End module<br />
<div class="outline-text-5" id="text-org43af5d5">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgdee3545" class="outline-3">
<h3 id="orgdee3545">The <code>OnePointCorrelationFunctions</code> module</h3>
<div class="outline-text-3" id="text-orgdee3545">
<p>
The module <code>OnePointCorrelationFunctions</code> defines
</p>

<ul class="org-ul">
<li>a struct <code>OnePointCorrelation</code> that represents a one point function \[
  < V >,
  \]</li>
<li>a method <code>computeCNmn</code> that computes the coefficients \(C^{N,\text{torus}}_{m,n}\) which serve to compute the conformal blocks that enter the expansion of the 1-pt function.</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org6f1e830"></a>Header<br />
<div class="outline-text-5" id="text-org6f1e830">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">module</span> OnePointCorrelationFunctions

<span style="color: #8959a8;">export</span> OnePointCorrelation, computeCNmn

<span style="color: #8959a8;">using</span> ..CFTData
<span style="color: #8959a8;">import</span> ..FourPointCorrelationFunctions: Dmn, &#948;rs <span style="color: #07c365;"># </span><span style="color: #07c365;">re-use the Dmn from four-point functions</span>
</pre>
</div>
</div>
</li>
<li><a id="org5247fa9"></a>One-point function type<br />
<div class="outline-text-5" id="text-org5247fa9">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">OnePointCorrelation</span>{T}
    charge<span style="color: #bb9200;">::CentralCharge</span>{T}
    field<span style="color: #bb9200;">::Field</span>{T}
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display a one-point function"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, corr<span style="color: #bb9200;">::OnePointCorrelation</span>)
    println(<span style="color: #718c00;">"One-point correlation function: &lt; V &gt; where "</span>)
    print(<span style="color: #718c00;">"V = "</span>); show(corr.field)
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="orgcf991c9"></a>Compute \(C^{N,\text{torus}}_{m,n}\)<br />
<div class="outline-text-5" id="text-orgcf991c9">
<p>
The computation of the \(C^{N,\text{torus}}_{m,n}\) is very similar to that of the <a href="#org3c81133">coefficients \(C^{N}_{m,n}\)</a>. We re-use much of the code.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Order of a pole of Rmn^torus, assuming the central charge is generic"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Rmn_zero_order</span>(m, n, corr<span style="color: #bb9200;">::OnePointCorrelation</span>)
    B = corr.charge[<span style="color: #718c00;">"B"</span>]
    V = corr.field
    <span style="color: #8959a8;">if</span> V.isKac <span style="color: #bb9200;">&amp;&amp;</span> V.r<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">==</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> V.s<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">==</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> abs(V.r) <span style="color: #bb9200;">&lt;=</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> abs(V.s) <span style="color: #bb9200;">&lt;=</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">1</span>
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Compute `Rmn^torus`.</span>
<span style="color: #718c00;">lr indicates the left or right moving parts of the fields</span>
<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> value of regularisation</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Rmn</span>(m, n, corr<span style="color: #bb9200;">::OnePointCorrelation</span>, lr)
    B = corr.charge[<span style="color: #718c00;">"B"</span>]
    V = corr.field
    &#948;1 = V[<span style="color: #718c00;">"&#948;"</span>][lr]
    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, corr) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">else</span>
        res = prod(prod(&#948;rs(r, s, B) <span style="color: #bb9200;">-</span> &#948;1 <span style="color: #8959a8;">for</span> r in <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">2</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">2</span>n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
        <span style="color: #8959a8;">return</span> res<span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>Dmn(m, n, B))
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">computeCNmn</span>(N, m, n, corr<span style="color: #bb9200;">::OnePointCorrelation</span>, lr)
    B = corr.charge[<span style="color: #718c00;">"B"</span>]
    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, corr) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">elseif</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&gt;</span> N
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">elseif</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">==</span> N
        <span style="color: #8959a8;">return</span> Rmn(m, n, corr, lr)
    <span style="color: #8959a8;">else</span>
        res = sum(sum(computeCNmn(N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n, mp, np, corr, lr)<span style="color: #bb9200;">/</span>(&#948;rs(m, <span style="color: #bb9200;">-</span>n, B)<span style="color: #bb9200;">-</span>&#948;rs(mp, np, B))
                      <span style="color: #8959a8;">for</span> mp <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n <span style="color: #8959a8;">if</span> mp<span style="color: #bb9200;">*</span>np <span style="color: #bb9200;">&lt;=</span> N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
                  <span style="color: #8959a8;">for</span> np <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
        <span style="color: #8959a8;">return</span> Rmn(m, n, corr, lr) <span style="color: #bb9200;">*</span> ((N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n<span style="color: #bb9200;">==</span><span style="color: #f5871f; font-weight: bold;">0</span>)<span style="color: #bb9200;">+</span>res)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="orgcf0d662"></a>End module<br />
<div class="outline-text-5" id="text-orgcf0d662">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org33198f0" class="outline-3">
<h3 id="org33198f0">Virasoro conformal blocks</h3>
<div class="outline-text-3" id="text-org33198f0">
<p>
The file <a href="./src/ConformalBlocks.jl">ConformalBlocks.jl</a> implements Zamolodchikov&rsquo;s recursion formula for computing four-point conformal blocks on the sphere and one-point conformal blocks on the torus.
</p>

<p>
It uses types from <a href="#org2a8132f">The <code>CFTData</code> module</a> and .
</p>
</div>
<div id="outline-container-orgcc2fce6" class="outline-4">
<h4 id="orgcc2fce6">The <code>FourPointBlocksSphere</code> module</h4>
<div class="outline-text-4" id="text-orgcc2fce6">
<p>
The module <code>FourPointBlocksSphere</code> exports
</p>

<ul class="org-ul">
<li>a struct <code>FourPointBlockSphere</code> that encapsulates the data needed to compute a 4pt conformal block, namely a channel, four external fields and the field propagating in the channel</li>
<li>a function <code>F_four_point_sphere(block, charge, x)</code> which computes the value of the non-chiral block \(\mathcal F_{\Delta}^{(s)}(\Delta_i | x)\) as defined in this paragraph.</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org91c37a6"></a>Header<br />
<div class="outline-text-5" id="text-org91c37a6">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">ConformalBlocks.jl contains modules that compute series expansions for</span>
<span style="color: #07c365;">Virasoro four-point conformal blocks on the sphere and Virasoro one-point conformal blocks</span>
<span style="color: #07c365;">on the torus.</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">===========================================================================================#</span>


<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Series expansion of four-point blocks on the sphere.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">module</span> FourPointBlocksSphere

<span style="color: #8959a8;">export</span> FourPointBlockSphere, F_four_point_sphere

<span style="color: #8959a8;">using</span> ..CFTData, ..FourPointCorrelationFunctions
<span style="color: #8959a8;">import</span> ..FourPointCorrelationFunctions: permute_ext_fields
<span style="color: #8959a8;">using</span> Match, EllipticFunctions, Memoization

</pre>
</div>
</div>
</li>
<li><a id="orgf949e0a"></a>Four-point block sphere type<br />
<div class="outline-text-5" id="text-orgf949e0a">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Struct FourPointBlockSphere</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    FourPointBlockSphere{T}</span>

<span style="color: #718c00;">Composite type that represents the list of arguments of a four-point conformal block:</span>
<span style="color: #718c00;">a channel and a field propagating in the channel. The external fields and central charge are</span>
<span style="color: #718c00;">provided in a `FourPointCorrelation` object.</span>

<span style="color: #718c00;"># Example</span>

<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; c = CentralCharge("c",0.5); V = Field(c, "&#948;", 0.6, diagonal = true);</span>
<span style="color: #718c00;">julia&gt; FourPointBlockSphere("s", V)</span>
<span style="color: #718c00;">Four-point block</span>
<span style="color: #718c00;">Channel:        s</span>
<span style="color: #718c00;">Channel Field:</span>
<span style="color: #718c00;">Diagonal field of dimension:</span>
<span style="color: #718c00;">  &#916; = 0.5791666666666667 + 0.0im</span>
<span style="color: #718c00;">  P = 0.0 + 0.7745966692414834im</span>
<span style="color: #718c00;">  &#948; = 0.6000000000000001 + 0.0im</span>
<span style="color: #718c00;">  p = 0.7745966692414834 + 0.0im</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">FourPointBlockSphere</span>{T}

    channel<span style="color: #bb9200;">::String</span>
    channelField<span style="color: #bb9200;">::Field</span>{T}

<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display blocks"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, block<span style="color: #bb9200;">::FourPointBlockSphere</span>)
    println(<span style="color: #718c00;">"Four-point block"</span>)
    println(<span style="color: #718c00;">"Channel:\t$(block.channel)"</span>)
    println(<span style="color: #718c00;">"Channel Field:"</span>)
    show(block.channelField)
    <span style="color: #07c365;"># </span><span style="color: #07c365;">println("External Fields:")</span>
    <span style="color: #07c365;"># </span><span style="color: #07c365;">print("1. "); show(block.extFields[1])</span>
    <span style="color: #07c365;"># </span><span style="color: #07c365;">print("2. "); show(block.extFields[2])</span>
    <span style="color: #07c365;"># </span><span style="color: #07c365;">print("3. "); show(block.extFields[3])</span>
    <span style="color: #07c365;"># </span><span style="color: #07c365;">print("4. "); show(block.extFields[4])</span>
<span style="color: #8959a8;">end</span>

<span style="color: #07c365;"># </span><span style="color: #07c365;">explicit names for the indices of left and right dimensions</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">left</span> = <span style="color: #f5871f; font-weight: bold;">1</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">right</span> = <span style="color: #f5871f; font-weight: bold;">2</span>
</pre>
</div>
</div>
</li>
<li><a id="org3b83c96"></a>Change of channel<br />
<div class="outline-text-5" id="text-org3b83c96">
<p>
The $t$- and $u$-channel blocks are computed from the $s$-channel one, using described above.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Get t- and u- channel blocks from s-channel block</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""Prefactor to get t- or u-channel blocks from the s-channel block"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">channelprefactor</span>(block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, x)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> block.channel <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"s"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #718c00;">"t"</span> <span style="color: #bb9200;">=&gt;</span> (<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">^</span>(sum(spin(corr.fields)))
        <span style="color: #718c00;">"u"</span> <span style="color: #bb9200;">=&gt;</span> (<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">^</span>(sum(spin.(corr.fields)))<span style="color: #bb9200;">*</span>abs2(x)<span style="color: #bb9200;">^</span>(<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>][<span style="color: #718c00;">"&#916;"</span>])
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Cross-ratio at which to evaluate the s-channel block to get t- or u-channel block"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">crossratio</span>(channel, x)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> channel <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"s"</span> <span style="color: #bb9200;">=&gt;</span> x
        <span style="color: #718c00;">"t"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>x
        <span style="color: #718c00;">"u"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>x
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org8b5bdbe"></a>Prefactors, elliptic nome<br />
<div class="outline-text-5" id="text-org8b5bdbe">
<p>
The nome \(q\) is related to \(x\) via
</p>

<p>
\[
q(x) = \exp(-\pi \frac{K(1-x)}{K(x)})
\]
</p>

<p>
where \(K\) is the elliptic \(K\) function. The inverse of this relation is
</p>

<p>
\[
x(q) = \left(\frac{\theta_{4}(q)}{\theta_{3}(q)}\right)^{2}
\]
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Set prefactors, relate the cross-ratio x and the elliptic nome q</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""Nome `q` from the cross-ratio `x`"""</span>
<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> qfromx(x) = exp(<span style="color: #bb9200;">-</span>&#960;<span style="color: #bb9200;">*</span>ellipticK(<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>x) <span style="color: #bb9200;">/</span> ellipticK(x))

<span style="color: #718c00;">""""Cross ratio `x` from the nome `q`"""</span>
<span style="color: #4271ae;">xfromq</span>(q) = jtheta2(<span style="color: #f5871f; font-weight: bold;">0</span>,q)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">4</span> <span style="color: #bb9200;">/</span> jtheta3(<span style="color: #f5871f; font-weight: bold;">0</span>,q)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">4</span>

<span style="color: #718c00;">"""Prefactor for getting the block F from H. The argument `lr` indicates if we are working</span>
<span style="color: #718c00;">with a left or right moving block"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">blockprefactor</span>(block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, x, lr)

    c = corr.charge[<span style="color: #718c00;">"c"</span>]
    e0 = <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>][<span style="color: #718c00;">"&#948;"</span>][lr] <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">2</span>][<span style="color: #718c00;">"&#948;"</span>][lr] <span style="color: #bb9200;">-</span> (c<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
    e1 = <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>][<span style="color: #718c00;">"&#948;"</span>][lr] <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">4</span>][<span style="color: #718c00;">"&#948;"</span>][lr] <span style="color: #bb9200;">-</span> (c<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
    e2 = sum(corr.fields[i][<span style="color: #718c00;">"&#948;"</span>][lr] <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>) <span style="color: #bb9200;">+</span> (c<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
    q=qfromx(x)

    <span style="color: #8959a8;">return</span> x<span style="color: #bb9200;">^</span>e0 <span style="color: #bb9200;">*</span> (<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>x)<span style="color: #bb9200;">^</span>e1 <span style="color: #bb9200;">*</span> jtheta3(<span style="color: #f5871f; font-weight: bold;">0</span>,q)<span style="color: #bb9200;">^</span>(<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">4</span><span style="color: #bb9200;">*</span>e2) <span style="color: #bb9200;">*</span> (<span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q)<span style="color: #bb9200;">^</span>block.channelField[<span style="color: #718c00;">"&#948;"</span>][<span style="color: #f5871f; font-weight: bold;">1</span>]
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Degenerate dimensions"""</span>
<span style="color: #4271ae;">&#948;rs</span>(r, s, B) = <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">4</span> <span style="color: #bb9200;">*</span> (B<span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">*</span>s <span style="color: #bb9200;">+</span> s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B)
</pre>
</div>
</div>
</li>
<li><a id="orgf0a6266"></a>Computation of the block<br />
<div class="outline-text-5" id="text-orgf0a6266">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Compute the conformal block</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""Compute the function ``H(q,&#948;)``."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">H</span>(q, Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, lr)
    &#948; = block.channelField[<span style="color: #718c00;">"&#948;"</span>][lr]
    B = corr.charge[<span style="color: #718c00;">"B"</span>]
    sq = <span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q
    res=<span style="color: #f5871f; font-weight: bold;">1</span>
    pow = <span style="color: #f5871f; font-weight: bold;">1</span>
    <span style="color: #8959a8;">for</span> N <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:Nmax
        sum_mn = sum(sum(computeCNmn(N, m, n, corr, block.channel, lr)<span style="color: #bb9200;">/</span>(&#948;<span style="color: #bb9200;">-</span>&#948;rs(m, n, B))
                         <span style="color: #8959a8;">for</span> n in <span style="color: #f5871f; font-weight: bold;">1</span>:N <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&lt;=</span> N) <span style="color: #8959a8;">for</span> m <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N)
        pow <span style="color: #bb9200;">*=</span> sq
        res <span style="color: #bb9200;">+=</span> pow <span style="color: #bb9200;">*</span> sum_mn
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> res
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    Fs_chiral(block::FourPointBlockSphere, corr::FourPointCorrelation, x, lr)</span>

<span style="color: #718c00;">Compute the chiral conformal block</span>

<span style="color: #718c00;">``\\mathcal F^{(s)}_{\\delta}(x)``</span>

<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Fs_chiral</span>(x, Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, lr)
    blockprefactor(block, corr, x, lr) <span style="color: #bb9200;">*</span> H(qfromx(x), Nmax, block, corr, lr)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Compute the chiral conformal block</span>

<span style="color: #718c00;">``\\mathcal F^{(\\text{chan})}_{\\delta}(x)``</span>

<span style="color: #718c00;">where `chan` is `s`, `t`, or `u`."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">block_chiral</span>(x, Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, lr)
    chan = block.channel
    Fs_chiral(crossratio(chan, x), Nmax, block, permute_ext_fields(corr, chan), lr)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Compute the non-chiral conformal block</span>

<span style="color: #718c00;">``\\mathcal F^{(\\text{chan})}_{\\delta}(x) \\overline{\\mathcal F}^{(\\text{chan})}_{\\delta}( \bar x )``</span>

<span style="color: #718c00;">where `chan` is `s`,`t` or `u`.</span>

<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> logarithmic blocks</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">F_four_point_sphere</span>(x, Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>)
    channelprefactor(block, corr, x) <span style="color: #bb9200;">*</span> <span style="color: #bb9200;">\</span>
        block_chiral(x, Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, left) <span style="color: #bb9200;">*</span> <span style="color: #bb9200;">\</span>
        conj(block_chiral(conj(x), Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, right))
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org2ceabe3"></a>End of module<br />
<div class="outline-text-5" id="text-org2ceabe3">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org7525fec" class="outline-3">
<h3 id="org7525fec">One-point conformal blocks on the torus</h3>
<div class="outline-text-3" id="text-org7525fec">
</div>
<div id="outline-container-orgc94cd32" class="outline-4">
<h4 id="orgc94cd32">The <code>OnePointBlocksTorus</code> module</h4>
<div class="outline-text-4" id="text-orgc94cd32">
<p>
The module <code>OnePointBlocksTorus</code> exports
</p>

<ul class="org-ul">
<li>a struct <code>OnePointBlockTorus</code> that encapsulates the data needed to compute a 4pt conformal block, namely an external field.</li>
<li>a function <code>F_one_point_torus(block, charge, x)</code> which computes the value of the non-chiral block \(\mathcal F_{\Delta}^{\text{torus}}(\Delta | q(x))\) as defined in .</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orga01aca6"></a>Header<br />
<div class="outline-text-5" id="text-orga01aca6">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Series expansion of one-point blocks on the torus</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">module</span> OnePointBlocksTorus

<span style="color: #8959a8;">using</span> ..CFTData, ..OnePointCorrelationFunctions
<span style="color: #8959a8;">import</span> EllipticFunctions: etaDedekind as &#951;

<span style="color: #8959a8;">export</span> OnePointBlockTorus, F_one_point_torus

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Struct containing the data required to compute a block: an external field</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">OnePointBlockTorus</span>{T}
    channelField<span style="color: #bb9200;">::Field</span>{T}
<span style="color: #8959a8;">end</span>

<span style="color: #07c365;"># </span><span style="color: #07c365;">explicit names for the indices of left and right dimensions</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">left</span> = <span style="color: #f5871f; font-weight: bold;">1</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">right</span> = <span style="color: #f5871f; font-weight: bold;">2</span>
</pre>
</div>
</div>
</li>
<li><a id="orga99be5c"></a>Computation of the block<br />
<div class="outline-text-5" id="text-orga99be5c">
<div class="org-src-container">
<pre class="src src-julia">
<span style="color: #4271ae;">qfromtau</span>(&#964;) = exp(<span style="color: #f5871f; font-weight: bold;">2</span>im<span style="color: #bb9200;">*</span>&#960;<span style="color: #bb9200;">*</span>&#964;)
<span style="color: #4271ae;">&#948;rs</span>(r, s, B) = <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">4</span> <span style="color: #bb9200;">*</span> (B<span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">*</span>s <span style="color: #bb9200;">+</span> s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B)

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Compute the conformal block</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    H(q, Nmax, block, corr, leftright)</span>
<span style="color: #718c00;">Compute the function  ``H^{\\text{torus}}(q,&#948;)``."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">H</span>(q, Nmax, block<span style="color: #bb9200;">::OnePointBlockTorus</span>, corr<span style="color: #bb9200;">::OnePointCorrelation</span>, lr)
    &#948; = block.channelField[<span style="color: #718c00;">"&#948;"</span>][lr]
    B = corr.charge[<span style="color: #718c00;">"B"</span>]
    res = <span style="color: #f5871f; font-weight: bold;">1</span>
    pow = <span style="color: #f5871f; font-weight: bold;">1</span>
    <span style="color: #8959a8;">for</span> N <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:Nmax
        sum_mn = sum(sum(computeCNmn(N, m, n, corr, lr)<span style="color: #bb9200;">/</span>(&#948;<span style="color: #bb9200;">-</span>&#948;rs(m, n, B))
                         <span style="color: #8959a8;">for</span> n in <span style="color: #f5871f; font-weight: bold;">1</span>:N <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&lt;=</span> N) <span style="color: #8959a8;">for</span> m <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N)
        pow <span style="color: #bb9200;">*=</span> q
        res <span style="color: #bb9200;">+=</span> pow <span style="color: #bb9200;">*</span> sum_mn
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> res
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    Fs_chiral(block::FourPointBlockSphere, corr::FourPointCorrelation, x, lr)</span>

<span style="color: #718c00;">Compute the chiral conformal block</span>

<span style="color: #718c00;">``\\mathcal F^{\text{torus}}_{\\delta}(x)``</span>

<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">block_chiral</span>(&#964;, Nmax, block<span style="color: #bb9200;">::OnePointBlockTorus</span>, corr<span style="color: #bb9200;">::OnePointCorrelation</span>, lr)
    &#948; = block.channelField[<span style="color: #718c00;">"&#948;"</span>][lr]
    <span style="color: #8959a8;">return</span> q<span style="color: #bb9200;">^</span>&#948;<span style="color: #bb9200;">/</span>&#951;(&#964;) <span style="color: #bb9200;">*</span> H(qfromtau(&#964;), Nmax, block, corr, lr)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Compute the non-chiral conformal block</span>

<span style="color: #718c00;">`` \\mathcal F_{\\Delta}^{(\\text{chan})}(\\Delta_i| x)``</span>

<span style="color: #718c00;">where ``\\text{chan}`` is `s`,`t` or `u`.</span>

<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> logarithmic blocks</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">F_one_point_torus</span>(&#964;, Nmax, block<span style="color: #bb9200;">::OnePointBlockTorus</span>, corr<span style="color: #bb9200;">::OnePointCorrelation</span>)
    block_chiral(&#964;, Nmax, block, corr, left) <span style="color: #bb9200;">*</span> conj(block_chiral(conj(&#964;), Nmax, block, corr, right))
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org0d32583"></a>End of module<br />
<div class="outline-text-5" id="text-org0d32583">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org54597ea" class="outline-3">
<h3 id="org54597ea">Special functions</h3>
<div class="outline-text-3" id="text-org54597ea">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">==================</span>

<span style="color: #07c365;">SpecialFunctions.jl computes the special functions relevant for our applications in 2D CFT.</span>

<span style="color: #07c365;">==================#</span>

<span style="color: #8959a8;">using</span> EllipticFunctions

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">log_double_gamma</span>(beta, w)
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">double_gamma</span>(beta, w)
    <span style="color: #8959a8;">return</span> exp(log_double_gamma(beta, w))
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc1ceafd" class="outline-3">
<h3 id="orgc1ceafd">Unit testing</h3>
<div class="outline-text-3" id="text-orgc1ceafd">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">using</span> JuliVirBootstrap
<span style="color: #8959a8;">using</span> Test

<span style="color: #4d4d4c; font-weight: bold;">@testset</span> <span style="color: #718c00;">"CFTData.jl"</span> <span style="color: #8959a8;">begin</span>

    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure the relation between b and &#946; does not change</span>
    c1 = CentralCharge(<span style="color: #718c00;">"c"</span>, <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1.1</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">2</span>im)
    b = c1[<span style="color: #718c00;">"b"</span>]
    c2 = CentralCharge(<span style="color: #718c00;">"b"</span>, b)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> c1[<span style="color: #718c00;">"c"</span>] <span style="color: #bb9200;">==</span> c2[<span style="color: #718c00;">"c"</span>]
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> c1[<span style="color: #718c00;">"&#946;"</span>] <span style="color: #bb9200;">==</span> c2[<span style="color: #718c00;">"&#946;"</span>]

    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure the relation between p and P does not change</span>
    left = <span style="color: #f5871f; font-weight: bold;">1</span>
    right = <span style="color: #f5871f; font-weight: bold;">2</span>
    V1 = Field(c1, <span style="color: #718c00;">"P"</span>, <span style="color: #f5871f; font-weight: bold;">0.5</span>, diagonal=<span style="color: #f5871f;">true</span>)
    p = V1[<span style="color: #718c00;">"p"</span>][left]
    V2 = Field(c1, <span style="color: #718c00;">"p"</span>, p, diagonal=<span style="color: #f5871f;">true</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> V1[<span style="color: #718c00;">"P"</span>] <span style="color: #bb9200;">==</span> V2[<span style="color: #718c00;">"P"</span>]

    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure the keyword diagonal also works for fields given from Kac indices</span>
    V1 = Field(c1, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">3</span>, s=<span style="color: #f5871f; font-weight: bold;">4</span>, diagonal=<span style="color: #f5871f;">true</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> V1[<span style="color: #718c00;">"&#916;"</span>][left] <span style="color: #bb9200;">==</span> V1[<span style="color: #718c00;">"&#916;"</span>][right]


    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure degenerate and diagonal work well together</span>
    V1 = Field(c1, Kac=<span style="color: #f5871f;">true</span>, degenerate=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">5</span>, diagonal=<span style="color: #f5871f;">true</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> V1[<span style="color: #718c00;">"&#916;"</span>][left] <span style="color: #bb9200;">==</span> V1[<span style="color: #718c00;">"&#916;"</span>][right]

<span style="color: #8959a8;">end</span>

<span style="color: #4d4d4c; font-weight: bold;">@testset</span> <span style="color: #718c00;">"FourPointCorrelationFunctions"</span> <span style="color: #8959a8;">begin</span>

    left=<span style="color: #f5871f; font-weight: bold;">1</span>
    right=<span style="color: #f5871f; font-weight: bold;">2</span>

    c = CentralCharge(<span style="color: #718c00;">"&#946;"</span>, <span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im)
    V1 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im, diagonal=<span style="color: #f5871f;">true</span>)
    V2 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">3.43</span>, diagonal=<span style="color: #f5871f;">true</span>)
    V3 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">0.13</span>, diagonal=<span style="color: #f5871f;">true</span>)
    V4 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">1.3</span>, diagonal=<span style="color: #f5871f;">true</span>)
    corr = FourPointCorrelation(c, V1, V2, V3, V4)

    <span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(JuliVirBootstrap.FourPointCorrelationFunctions.Rmn(<span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">1</span>, corr, <span style="color: #718c00;">"s"</span>, left),
                   <span style="color: #f5871f; font-weight: bold;">0.31097697185245077</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">0.70523695127635733</span>im, <span style="color: #07c365;"># </span><span style="color: #07c365;">value taken from Sylvain's code</span>
                   atol=<span style="color: #f5871f; font-weight: bold;">1e-8</span>)

    <span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(JuliVirBootstrap.FourPointCorrelationFunctions.Rmn(<span style="color: #f5871f; font-weight: bold;">3</span>, <span style="color: #f5871f; font-weight: bold;">3</span>, corr, <span style="color: #718c00;">"t"</span>, left),
                   <span style="color: #f5871f; font-weight: bold;">4.3964194233662846e-5</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1.1534661157146291e-5</span>im, <span style="color: #07c365;"># </span><span style="color: #07c365;">value taken from Sylvain's code</span>
                   atol=<span style="color: #f5871f; font-weight: bold;">1e-8</span>)

    <span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(JuliVirBootstrap.FourPointCorrelationFunctions.computeCNmn(<span style="color: #f5871f; font-weight: bold;">7</span>, <span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">3</span>, corr, <span style="color: #718c00;">"s"</span>, left),
                   <span style="color: #f5871f; font-weight: bold;">0.0019498393368877166</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">0.0026353877950837049</span>im, <span style="color: #07c365;"># </span><span style="color: #07c365;">value taken from Sylvain's code</span>
                   atol=<span style="color: #f5871f; font-weight: bold;">1e-8</span>)

<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org28c8455" class="outline-3">
<h3 id="org28c8455">Development tests</h3>
<div class="outline-text-3" id="text-org28c8455">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">import</span> Pkg; Pkg.activate(<span style="color: #718c00;">"."</span>)
<span style="color: #8959a8;">using</span> JuliVirBootstrap
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">using</span> JuliVirBootstrap, BenchmarkTools, EllipticFunctions

left=<span style="color: #f5871f; font-weight: bold;">1</span>;
right=<span style="color: #f5871f; font-weight: bold;">2</span>;

c = CentralCharge(<span style="color: #718c00;">"&#946;"</span>, big(<span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im));
V1 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im, diagonal=<span style="color: #f5871f;">true</span>);
V2 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">3.43</span>, diagonal=<span style="color: #f5871f;">true</span>);
V3 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">0.13</span>, diagonal=<span style="color: #f5871f;">true</span>);
V4 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">1.3</span>, diagonal=<span style="color: #f5871f;">true</span>);
V = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">0.1</span>, diagonal = <span style="color: #f5871f;">true</span>);

x = BigFloat(<span style="color: #718c00;">"0.05"</span>, RoundUp);
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">test</span>()
    corr = FourPointCorrelation(c, V1, V2, V3, V4)
    block = FourPointBlockSphere(<span style="color: #718c00;">"s"</span>, V)
    calc = JuliVirBootstrap.FourPointBlocksSphere.Fs_chiral(x, <span style="color: #f5871f; font-weight: bold;">5</span>, block, corr, left);
<span style="color: #8959a8;">end</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #4d4d4c; font-weight: bold;">@btime</span> test()
</pre>
</div>

<pre class="example">
test (generic function with 1 method)
1.052 ms (14047 allocations: 779.80 KiB)
2337.403601860713925958391009719678809055546365124340617423994215164154638728732 + 4771.392251761078219452023733430973991671048305871845481326523306698785531079742im
</pre>
</div>
<div id="outline-container-orga35c5ba" class="outline-4">
<h4 id="orga35c5ba">Relation between four-point blocks on the sphere and one-point blocks on the torus</h4>
<div class="outline-text-4" id="text-orga35c5ba">
<p>
Four point blocks on the sphere are related to one-point blocks on the torus through the relation
</p>

<p>
\[
\mathcal H^{\text{torus}}_{c, P}(P_{1} | q^{2}) = \mathcal H_{c', \sqrt{2}P'}\left(\left. P'_{(0,\frac12)}, \left(\frac{P_{1}}{\sqrt{2}}\right)', P'_{(0,\frac12)}, P'_{(0,\frac12)} \right| q \right)
\]
</p>

<p>
where
</p>
<ul class="org-ul">
<li>\(c'\) is related to \(c\) via \(\beta'=\frac\beta{\sqrt 2}\).</li>
<li>\(P'\) denotes the Virasoro module with primary field of dimension \(\Delta'(P') = \frac{c'-1}{24} - P'^{2}\)</li>
</ul>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">import</span> Pkg; Pkg.activate(<span style="color: #718c00;">"."</span>)
<span style="color: #8959a8;">using</span> JuliVirBootstrap, BenchmarkTools, EllipticFunctions

left=<span style="color: #f5871f; font-weight: bold;">1</span>;
right=<span style="color: #f5871f; font-weight: bold;">2</span>;

<span style="color: #8959a8;">import</span> JuliVirBootstrap.FourPointBlocksSphere.qfromx
c_torus = CentralCharge(<span style="color: #718c00;">"b"</span>, <span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im);
c_sphere = CentralCharge(<span style="color: #718c00;">"b"</span>, (<span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im)<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>))

q = JuliVirBootstrap.FourPointBlocksSphere.qfromx(<span style="color: #f5871f; font-weight: bold;">0.05</span>)

P = <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im
P1 = <span style="color: #f5871f; font-weight: bold;">0.41</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1.03</span>im
V_torus_chan = Field(c_torus, <span style="color: #718c00;">"P"</span>, P, diagonal=<span style="color: #f5871f;">true</span>)
&#948;_torus = V_torus_chan[<span style="color: #718c00;">"&#948;"</span>][left]
&#948;11_torus = Field(c_torus, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>, diagonal=<span style="color: #f5871f;">true</span>)[<span style="color: #718c00;">"&#948;"</span>][left]
V_torus_ext = Field(c_torus, <span style="color: #718c00;">"P"</span>, P1, diagonal=<span style="color: #f5871f;">true</span>)
corr_torus = OnePointCorrelation

V_sphere_chan = Field(c_sphere, <span style="color: #718c00;">"P"</span>, sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>)<span style="color: #bb9200;">*</span>P, diagonal=<span style="color: #f5871f;">true</span>)
&#948;_sphere = V_sphere_chan[<span style="color: #718c00;">"&#948;"</span>][left]
&#948;21_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>, diagonal=<span style="color: #f5871f;">true</span>)[<span style="color: #718c00;">"&#948;"</span>][left]
&#948;12_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>)[<span style="color: #718c00;">"&#948;"</span>][left]
V_sphere_ext = Field(c_sphere, <span style="color: #718c00;">"P"</span>, P1<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>), diagonal=<span style="color: #f5871f;">true</span>)
VKac_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>)

corr_torus = OnePointCorrelation(c_torus, V_torus_ext)
block_torus = OnePointBlockTorus(V_torus_chan)

corr_sphere = FourPointCorrelation(c_sphere, [VKac_sphere, V_sphere_ext, VKac_sphere,VKac_sphere])
block_sphere = FourPointBlockSphere(<span style="color: #718c00;">"s"</span>, V_sphere_chan)


C111_torus = JuliVirBootstrap.OnePointCorrelationFunctions.computeCNmn(<span style="color: #f5871f; font-weight: bold;">1</span>, <span style="color: #f5871f; font-weight: bold;">1</span>, <span style="color: #f5871f; font-weight: bold;">1</span>, corr_torus, left)

C212_sphere = JuliVirBootstrap.FourPointCorrelationFunctions.computeCNmn(<span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">1</span>, <span style="color: #f5871f; font-weight: bold;">2</span>, corr_sphere, <span style="color: #718c00;">"s"</span>, left)
C221_sphere = JuliVirBootstrap.FourPointCorrelationFunctions.computeCNmn(<span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">1</span>, corr_sphere, <span style="color: #718c00;">"s"</span>, left)

<span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> (C212_sphere<span style="color: #bb9200;">/</span>(&#948;_sphere<span style="color: #bb9200;">-</span>&#948;12_sphere) <span style="color: #bb9200;">+</span> C221_sphere<span style="color: #bb9200;">/</span>(&#948;_sphere<span style="color: #bb9200;">-</span>&#948;21_sphere))
C111_torus<span style="color: #bb9200;">/</span>(&#948;_torus<span style="color: #bb9200;">-</span>&#948;11_torus)

h1 = JuliVirBootstrap.OnePointBlocksTorus.H(q<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">5</span>, block_torus, corr_torus, left)
h2 = JuliVirBootstrap.FourPointBlocksSphere.H(q, <span style="color: #f5871f; font-weight: bold;">5</span>, block_sphere, corr_sphere, left)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia">println(<span style="color: #718c00;">"torus block = $h1 \nsphere block = $h2"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia"> o
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Paul ROUX</p>
<p class="date">Created: 2024-03-12 Tue 09:44</p>
</div>
</body>
</html>
