#+title: Three Point functions of loop models: numerical data
#+author: Paul Roux
#+date: <14-05-2024>
#+property: header-args:julia :tangle three_point.jl

* Analytical prediction

We compute the following three point structure constants:

 \begin{align}
\boxed{C^\text{ref}_{(r_1,s_1)(r_2,s_2)(r_3,s_3)} =\prod_{\epsilon_1,\epsilon_2,\epsilon_3=\pm} \Gamma_\beta^{-1} \left(\tfrac{\beta+\beta^{-1}}{2} + \tfrac{\beta}{2}\left|\textstyle{\sum_i} \epsilon_ir_i\right| + \tfrac{\beta^{-1}}{2}\textstyle{\sum_i} \epsilon_is_i\right)}\ ,
 \label{cref}
\end{align}

and we use

\begin{align}
  C^{\text{ref}}_{P_{(1,1)}(r,s)^{2}} &= K \prod_{\pm, \pm}\Gamma_{\beta}^{-1}(\beta^{\pm 1} + r\beta \pm s\beta^{-1}), \\
K &=\prod_{\pm} \Gamma_{\beta}^{-2}(\beta^{\pm 1})
\end{align}

#+begin_src julia
using Pkg; Pkg.activate(".");
using JuliVirBootstrap

setprecision(BigFloat, base=10, 16)

βs = [b for b in 1/sqrt(2)+0.01:0.01:sqrt(3/2)-0.01]
cs = [CentralCharge("β", β) for β in βs]
V10s = [Field(ci, Kac=true, r=1, s=0) for ci in cs]
V11s = [Field(ci, Kac=true, r=1, s=1) for ci in cs]

β = sqrt(2/3)
tol = 1e-6
Gb(w) = double_Gamma(w, β, tol)

function factor_K(c, tol)
    β = c["β"]
    return 1/prod(double_Gamma(β^pm, β, tol) for pm in -1:2:1)^2
end

function Cref(c, V1::Field{T}, V2, V3, tol) where {T}
    β = c["β"]
    V = [V1, V2, V3]
    r=zeros(T, 3)
    s=zeros(T, 3)
    # check if some of the fields are diagonal
    for (i, v) in enumerate(V)
        if v.isdiagonal
            r[i] = 0
            s[i] = 2*β*v["p"][1]
        else
            r[i] = v.r
            s[i] = v.s
        end
    end
    g(pms, rs, ss) = double_Gamma((β+1/β)/2 + abs(pms'rs)*β/2 + (pms'ss)/2/β, β, tol) # ' denotes the scalar product
    res=1
    pm = [-1, +1]
    for pm1 in pm
        for pm2 in pm
            for pm3 in pm
                pms = [pm1, pm2, pm3]
                res /= g(pms, r, s)
            end
        end
    end
    return res
end

function omega(c, V1, V2, V3, tol)
    id = Field(c, Kac=true, r=1, s=1, degenerate=true, diagonal=true)
    return Cref(c, V1, V2, V3, tol) * sqrt(Cref(c, id, id, id, tol)/Cref(c, id, V1, V1, tol)/Cref(c, id, V2, V2, tol)/Cref(c, id, V3, V3, tol))
end
#+end_src

#+begin_src julia
using Plots

ns = [real(-2*cos(π*c["β"]^2)) for c in cs];
ωs = [real(omega(c, V10s[i], V10s[i], V10s[i], tol)) for (i, c) in enumerate(cs)];
#+end_src
