<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-06-19 Wed 13:57 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BootstrapVirasoro Documentation</title>
<meta name="author" content="Paul ROUX" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">BootstrapVirasoro Documentation</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org96bf550">1. Overview</a></li>
<li><a href="#org36b95cf">2. Conformal bootstrap in 2D</a>
<ul>
<li><a href="#org650245e">2.1. Notations, parametrisations</a>
<ul>
<li><a href="#org6549ad4">Central charge</a></li>
<li><a href="#org1852170">Fields</a></li>
</ul>
</li>
<li><a href="#orgd6fcf03">2.2. Special functions</a>
<ul>
<li><a href="#org5f5a059">Digamma function</a></li>
<li><a href="#org1e8724b">Barne&rsquo;s G-function and the double Gamma function</a></li>
</ul>
</li>
<li><a href="#org0e0bb6e">2.3. Four point functions on the sphere</a>
<ul>
<li><a href="#org1a0c59b">Chiral and non chiral blocks</a></li>
<li><a href="#org6144674">Zamolodchikov&rsquo;s recursion for four-point blocks</a></li>
</ul>
</li>
<li><a href="#org0d316c4">2.4. One point functions on the torus</a>
<ul>
<li><a href="#org8001cca">Chiral and non-chiral blocks</a></li>
<li><a href="#org73baf46">Zamolodchikov&rsquo;s recursion for torus one-point blocks</a></li>
</ul>
</li>
<li><a href="#org955394a">2.5. Logarithmic blocks</a>
<ul>
<li><a href="#orgd7a686c">Logarithmic modules</a></li>
<li><a href="#orgc4bc9c4">Logarithmic blocks on the sphere</a></li>
<li><a href="#org2b66fce">Logarithmic blocks on the torus</a></li>
</ul>
</li>
<li><a href="#org4b0b086">2.6. Relation between sphere four-point blocks and torus one-point blocks</a></li>
<li><a href="#org6ee68bf">2.7. Crossing symmetry for four-point functions on the sphere</a></li>
<li><a href="#org06c61d1">2.8. Modular invariance for one-point functions on the torus</a></li>
</ul>
</li>
<li><a href="#org5ff77ff">3. Code of the package&#xa0;&#xa0;&#xa0;<span class="tag"><span class="noeval">noeval</span></span></a>
<ul>
<li><a href="#org41dd4d3">3.1. Main module</a></li>
<li><a href="#org0cd72b2">3.2. The <code>SpecialFunctions</code> module</a>
<ul>
<li><a href="#org8d37744">Header</a></li>
<li><a href="#org899e7cc">Regularized digamma Function</a></li>
<li><a href="#org22038cc">Double gamma function</a></li>
<li><a href="#org589ba90">End module</a></li>
</ul>
</li>
<li><a href="#org50e4783">3.3. The <code>CFTData</code> module</a>
<ul>
<li><a href="#orgda6695a">Header</a></li>
<li><a href="#orgde916af">Central charge</a></li>
<li><a href="#orgfbc6b85">Conformal dimensions and Fields</a></li>
<li><a href="#org49e60c3">End of module</a></li>
</ul>
</li>
<li><a href="#orga9ee159">3.4. The <code>FourPointCorrelationFunctions</code> module</a></li>
<li><a href="#org40fd3fe">3.5. The <code>OnePointCorrelationFunctions</code> module</a></li>
<li><a href="#org919d77c">3.6. The <code>FourPointBlocksSphere</code> module</a>
<ul>
<li><a href="#org25a3fc6">Header</a></li>
<li><a href="#org87c2eaf">Four-point block sphere type</a></li>
<li><a href="#org43def64">Change of channel</a></li>
<li><a href="#org66eaed1">Prefactors, elliptic nome</a></li>
<li><a href="#org6e78f76">Logarithmic structure constant \(\ell\)</a></li>
<li><a href="#org8716e00">Zamolodchikov recursion</a></li>
<li><a href="#org618325d">Computation of the block</a></li>
<li><a href="#org1f4b139">End of module</a></li>
</ul>
</li>
<li><a href="#org1c71ed5">3.7. Setting-up bootstrap equations</a>
<ul>
<li><a href="#org325a5d7">Multithreading</a></li>
</ul>
</li>
<li><a href="#org47c7214">3.8. Unit testing</a>
<ul>
<li><a href="#org099d13c">CFTData</a></li>
<li><a href="#orgde8d507">Four-point correlation functions</a></li>
<li><a href="#orge7d26ce">Four-point blocks</a></li>
<li><a href="#org45844e2">One-point blocks</a></li>
</ul>
</li>
<li><a href="#org90f88b6">3.9. Development tests</a>
<ul>
<li><a href="#orgc0404c0">Relation between four-point blocks on the sphere and one-point blocks on the torus</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org96bf550" class="outline-2">
<h2 id="org96bf550"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
This document contains a program for performing conformal bootstrap computations in 2D loop models.
</p>

<p>
The program relies on the assumption that the spectrum of the model contains degenerate fields \(V^d_{\langle1,s\rangle}\) (see below).
</p>
</div>
</div>
<div id="outline-container-org36b95cf" class="outline-2">
<h2 id="org36b95cf"><span class="section-number-2">2.</span> Conformal bootstrap in 2D</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org650245e" class="outline-3">
<h3 id="org650245e"><span class="section-number-3">2.1.</span> Notations, parametrisations</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org6549ad4" class="outline-4">
<h4 id="org6549ad4">Central charge</h4>
<div class="outline-text-4" id="text-org6549ad4">
<p>
We parametrise the central charge of our theories in terms of variables \(B\), \(b\) or \(\beta\) related by
</p>

<p>
\[c = 13 + 6B + 6 B^{-1} \quad , \quad B = b^2 = -\beta^2, \quad B = \frac{c-13 \pm \sqrt{(c-1)(c-25)}}{12}\]
</p>

<p>
By convention we keep \(\beta = ib\).
</p>
</div>
</div>
<div id="outline-container-org1852170" class="outline-4">
<h4 id="org1852170">Fields</h4>
<div class="outline-text-4" id="text-org1852170">
<p>
We parametrise the conformal dimensions \((\Delta, \bar\Delta)\) of fields in terms of variables \(P, p, \delta\), related by
</p>

<p>
\[
\Delta = \frac{c-1}{24} + \delta  \quad , \quad \delta = P^2 = -p^2
\]
</p>

<p>
The variable \(P\) is called the momentum. By convention, we always keep \(P=ip\).Moreover, we introduce the following parametrisation of dimensions in terms of Kac indices \(r, s\):
</p>

<p>
\[P_{(r,s)}=\frac{1}{2}(\beta r - \beta^{-1}s)\]
</p>

<p>
where \(r,s\) are arbitrary numbers. We say the field is degenerate if \(r,s\in \mathbb Z\) and \(rs > 0\).
This convention is different from the one in <a href="https://gitlab.com/s.g.ribault/Bootstrap_Virasoro.git">Sylvain&rsquo;s code</a>, but similar to our more recent conventions, such as in <a href="https://github.com/ribault/CFT-Review">Sylvain&rsquo;s review on solvable CFTs</a>.
</p>

<p>
In loop models, we denote \(V_{(r,s)}\) a non-diagonal field of left and right momenta \((P_{(r,s)},P_{(r,-s)})\).
</p>
</div>
</div>
</div>
<div id="outline-container-orgd6fcf03" class="outline-3">
<h3 id="orgd6fcf03"><span class="section-number-3">2.2.</span> Special functions</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Expressions of correlation functions in CFT involve special functions. In this paragraph we introduce some representations and regularisations of special functions.
</p>
</div>
<div id="outline-container-org5f5a059" class="outline-4">
<h4 id="org5f5a059">Digamma function</h4>
<div class="outline-text-4" id="text-org5f5a059">
<p>
The digamma function is defined for as
</p>

\begin{align}
  \psi(z) = \frac{\Gamma'(z)}{\Gamma(z)}
\end{align}

<p>
The function \(\psi\) has poles at negative integers. We regularise the digamma function thanks to the equation
</p>

\begin{align}
  \psi(1-x) - \psi(x) = \pi \operatorname{cot}(\pi x)
\end{align}

<p>
which means we use the regularization
</p>

\begin{align}
  \psi(-r) \underset{r\in\mathbb{N}}{=} \psi(r+1)
\end{align}
</div>
</div>
<div id="outline-container-org1e8724b" class="outline-4">
<h4 id="org1e8724b">Barne&rsquo;s G-function and the double Gamma function</h4>
<div class="outline-text-4" id="text-org1e8724b">
<p>
We need to compute the double Gamma function defined by the relations
</p>

\begin{align}
 \Gamma_{\beta}= \Gamma_{\beta^{-1}}, \quad, \Gamma_{\beta}\left( \frac{\beta + \beta^{-1}}{2} \right) = 1, \quad \Gamma_{\beta}(w + \beta) = \sqrt{2\pi} \frac{\beta^{\beta w-\frac{1}{2}}}{\Gamma(\beta w)} \Gamma_{\beta}(w)
\end{align}

<p>
(see <a href="https://en.wikipedia.org/wiki/Multiple_gamma_function">wikipedia article</a>).
</p>

<p>
It also obeys
</p>

\begin{align}
  \Gamma_{\beta}(w+\beta^{-1}) = \sqrt{2\pi} \frac{\beta^{-\beta^{-1}w+\frac12}}{\Gamma(\beta^{-1}w)} \Gamma_{\beta}(w).
\end{align}

<p>
For computing \(\Gamma_\beta\) it is convenient to use its relation to the Barne&rsquo;s \(G\) -function (see <a href="https://en.wikipedia.org/wiki/Barnes_G-function">wikipedia article</a>), which is related to \(\Gamma_\beta\) as
</p>

\begin{align}
\Gamma_\beta(w) = \frac{\Gamma_2(w|\beta,\beta^{-1})}{\Gamma_2\left(\frac{\beta+\beta^{-1}}{2}\middle|\beta,\beta^{-1}\right)} \quad , \quad
 \Gamma_2(w|\beta,\beta^{-1})=(2\pi)^{\frac{w}{2\beta}} \beta^{\frac{w}{2}(w-\beta-\beta^{-1})+1} G(\beta^{-1}w,\beta^{-2})^{-1}
\end{align}

<p>
According to the theorem 1 in <a href="https://arxiv.org/abs/2208.13876">arXiv:2208.13876</a>, the \(G\) function has the following product representation
</p>

\begin{align}
  G(z, \tau) = G_{N}(z, \tau) \exp\left(z^{3} R_{M,N}(z,\tau) + O(N^{-M-1})\right)
\end{align}

<p>
where \(G_N\) is defined in terms of Gamma and polygamma functions,
</p>

\begin{align}\label{eq:Barnes_{GN}}
 G_N(z,\tau) = \frac{1}{\tau\Gamma(z)} e^{a(\tau) \frac{z}{\tau}+b(\tau)\frac{z^2}{2\tau^2}}
 \prod_{m=1}^N \frac{\Gamma(m\tau)}{\Gamma(z+m\tau)}e^{z\psi(m\tau)+\frac{z^2}{2}\psi'(m\tau)}
\end{align}

<p>
while \(R_{M, N}\) is a linear combination of certain polynomials \(P_k\),
</p>

\begin{align}
R_{M, N}(z,\tau) = \sum_{k=1}^M (k-1)!(-\tau)^{-k-1}P_k(z, -\tau) N^{-k}
\end{align}

<p>
where the polynomials are defined recursively by \(P_1(z,\tau)=\frac16\), and
</p>

\begin{align}
P_n(z,\tau) = \frac{z^{n-1}}{(n+2)!}-\frac{1}{\tau}\sum_{k=1}^{n-1} \frac{(1+\tau)^{k+2}-1-\tau^{k+2}}{(k+2)!} P_{n-k}(z,\tau)
\end{align}

<p>
It remains to define the coefficients
</p>

\begin{align}
a(\tau) = \tfrac12\tau\log(2\pi\tau) +\tfrac12\log(\tau) -\tau C(\tau) \quad , \quad b(\tau) =-\tau\log(\tau) -\tau^2D(\tau)
\end{align}

<p>
where the modular forms \(C(\tau),D(\tau)\) are
</p>

\begin{align}\label{eq:modularC}
C(\tau) &= \frac{1}{2\tau}\log(2\pi) -\int_0^\infty dx\left[ \frac{e^{(1-\tau)x}}{2\sinh(x)\sinh(\tau x)}- \frac{e^{-2x}}{\tau x}\left(\frac{e^{x}}{2\sinh(x)}+1-\frac{\tau}{2}\right)\right]
\\
\label{eq:modularD}
D(\tau) &= \int_0^\infty dx\left[ \frac{x e^{(1-\tau)x}}{\sinh(x)\sinh(\tau x)} - \frac{e^{-2x}}{\tau x}\right]
\end{align}

<p>
(We rewrite denominators in terms of \(\sinh\) in order to minimize numerical errors.)
</p>

<p>
For numerical evaluation of these integrals, it is useful to know the expansion of their integrands as \(x\to 0\):
</p>

\begin{align}
C(x, \tau) = \frac{2}{\tau} - \frac32 + \frac{\tau}{6} + \left(\frac56 - \frac{2}{\tau} + \frac{\tau}{6}\right)x  + \left( \frac4{3\tau} - \frac23 + \frac1{18}\tau - \frac{1}{90}\tau^{3}\right) x^{2}\quad , \quad D_0 = \frac{3}{\tau}-1
\end{align}

<p>
The error is of order \(\left(\frac{eN}{M}\right)^{-M}\), and the computation time of order \(N+ M^2\). To minimize computation time while keeping the error of order \(10^{-d}\), we take values of the type
</p>

\begin{align}
N = 20M, \quad M = \frac{\log(10)}{\alpha\log(20)}d
\end{align}

<p>
where \(\alpha\) is a parameter for reducing \(M\), which otherwise is too high in practice.
Up to logarithmic factors, the computation time is of order \(d^2\), whereas it should be of order \(d\) for the integral formula.
</p>
</div>
</div>
</div>
<div id="outline-container-org0e0bb6e" class="outline-3">
<h3 id="org0e0bb6e"><span class="section-number-3">2.3.</span> Four point functions on the sphere</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org1a0c59b" class="outline-4">
<h4 id="org1a0c59b">Chiral and non chiral blocks</h4>
<div class="outline-text-4" id="text-org1a0c59b">
<p>
Because of conformal invariance, computation of any four-point correlation function on the sphere reduces to the computation of
</p>

<p>
\[ \mathcal G(x) = \langle V_{1}(x) V_{2}(0) V_{3}(\infty) V_{4}(1) \rangle \]
</p>

<p>
Four-point correlation functions can be written in terms of Virasoro blocks as
</p>

\begin{align}
  \mathcal G(x) = \sum_{k \in \mathcal S} \frac{C_{12k} C_{k34}}{B_{k}} \mathcal G_{\Delta_k}^{(s)}(c |\Delta_{1}, \dots, \Delta_{4}|z)\end{align}

<p>
We call \(\mathcal G_{\Delta_k}^{(s)}(c |\Delta_{1}, \dots, \Delta_{4}|z)\) a non-chiral conformal block.
In the case of a non-logarithmic theory, conformal blocks factorise as
</p>

\begin{align}
  \mathcal G_{\Delta_k}^{(s)}(c |\Delta_{1}, \dots, \Delta_{4}|z) = \left| \mathcal F^{(s)}_{\Delta_{k}}(c | \Delta_{1}, \dots, \Delta_{4} | z) \right|^{2}
\end{align}

<p>
where we have introduced the notation \(\left|\mathcal F(\Delta, z)\right|^2 = \mathcal{F}(\Delta, z) \mathcal{F}(\bar\Delta, \bar z)\), and \(\mathcal F^{(s)}_{\Delta_k}\) is called a Virasoro block (also called chiral conformal block).
</p>

<p>
The coefficients \(C_{ijk}\) are the three-point structure constants.
</p>

<p>
Conformal blocks are characterized by the normalization conditions
</p>

\begin{align}
 \mathcal{G}^{(s)}_\Delta(x) & \underset{x\to 0}{=} \left| x^{\Delta-\Delta_1-\Delta_2}\right|^2 \left(1+O(x)\right)
 \\
 \mathcal{G}^{(t)}_\Delta(x) & \underset{x\to 1}{=} \left|(1-x)^{\Delta-\Delta_1-\Delta_4}\right|^2 \left(1+O(1-x)\right)
 \\
 \mathcal{G}^{(u)}_\Delta(x) & \underset{x\to \infty}{=} \left|\left(\frac{1}{x}\right)^{\Delta+\Delta_1-\Delta_3} \right|^2\left(1+O\left(\frac{1}{x}\right)\right)
\end{align}

<p>
Together with the invariance of \(\left\langle \prod_{i=1}^4 V_{\Delta_i}(z_i) \right\rangle\) under permutations, this leads to the relations
</p>

\begin{align}
\mathcal{G}^{(t)}_{\Delta}(\Delta_1,\Delta_2,\Delta_3,\Delta_4|x)
&= (-1)^{S_1+S_2+S_3+S_4}
\mathcal{G}^{(s)}_{\Delta}(\Delta_1,\Delta_4,\Delta_3,\Delta_2|1-x)
\\
\mathcal{G}^{(u)}_\Delta(\Delta_1,\Delta_2,\Delta_3,\Delta_4|x)
&= (-1)^{S_1+S_2+S_3+S_4}
\left|x^{-2\Delta_1}\right|^2 \mathcal{G}^{(s)}_\Delta(\Delta_1,\Delta_3,\Delta_2,\Delta_4|\tfrac{1}{x})
\end{align}

<p>
where \(S=\Delta-\bar\Delta\) is the conformal spin, which we assume to be integer.
</p>
</div>
</div>
<div id="outline-container-org6144674" class="outline-4">
<h4 id="org6144674">Zamolodchikov&rsquo;s recursion for four-point blocks</h4>
<div class="outline-text-4" id="text-org6144674">
<p>
Four-point blocks can be computed efficiently thanks to <a href="https://en.wikipedia.org/wiki/Virasoro_conformal_block">Zamolodchikov&rsquo;s recursion</a>.
</p>

<p>
We introduce a variable \(q\) related to \(z\) through
</p>

<p>
\[
z = \frac{\theta_2(q)^4}{\theta_3(q)^4}, \quad q = e^{-\pi\frac{K(1-x)}{ K(x)}}
\]
</p>

<p>
where
</p>

<p>
\[
\theta_3(q) = \sum_{n\in\mathbb{Z}} q^{n^2} \quad , \quad \theta_2(q) = 2q^\frac14\sum_{n=0}^\infty q^{n(n+1)}
\]
</p>


<p>
are Jacobi special \(\theta\)-functions, and \(K(x)\) is the elliptic \(K\) function.
</p>

<p>
In terms of these variables, our chiral \(s\)-channel conformal block is
</p>

\begin{align}
\label{eq:chiral_block}
\mathcal{F}^{(s)}_{\delta}(c | \Delta_{1}, \dots, \Delta_{4} | x) =  x^{E_0} (1-x)^{E_1} \theta_3(q)^{-4E_2}
(16q)^{\delta} H_{\delta}(c | \Delta_{1},\dots, \Delta_{4} | q)
\end{align}

<p>
where we use the exponents
</p>

<p>
\[
E_0 = -\delta_1-\delta_2-\frac{c-1}{24} \quad , \quad E_1 = -\delta_1-\delta_4-\frac{c-1}{24} \quad ,
\quad E_2 = \delta_1+\delta_2+\delta_3+\delta_4+\frac{c-1}{24}
\]
</p>

<p>
The non-trivial coefficient is the series
</p>

<p>
\[
H_{\delta}(q) = 1 + \sum_{N=1}^{N_{max}} \sum_{mn\leq N} C_{m,n}^N \frac{(16q)^N}{\delta-\delta_{(m,n)}}
\]
</p>

<p>
Where the coefficient \(C_{m,n}^N\) is defined by the recursive formula
</p>

<p>
\[
C^N_{m,n} = R_{m,n}\left(\delta_{N-mn,0} + \sum_{m'n'\leq N-mn} \frac{C^{N-mn}_{m',n'}}{\delta_{(m,-n)}-\delta_{(m',n')}} \right)
\]
</p>

<p>
And the coefficents \(R_{m,n}\) can be written
</p>

\begin{align}
 R_{m,n} = \frac{1}{2}\frac{1}{D_{mn}}
\prod_{r\overset{2}{=} 1-m}^{m-1}
\prod_{s\overset{2}{=}1-n}^{n-1}
&\sqrt{(\delta_2-\delta_1)^2 -2\delta_{(r,s)}(\delta_1+\delta_2) + \delta_{(r,s)}^2}\nonumber\\
&\sqrt{(\delta_3-\delta_4)^2 -2\delta_{(r,s)}(\delta_3+\delta_4) + \delta_{(r,s)}^2}
\end{align}

<p>
We do not actually take square roots, because each factor appears twice, except the \((r,s)=(0,0)\) factor which is however a perfect square. The normalization factor is
</p>

\begin{equation}
\label{orga9ecdf3}
D_{m,n} = mn \prod_{r=1}^{m-1} r^2B \left(r^2B - \frac{n^2}{B}\right)
\prod_{s=1}^{n-1} \frac{s^2}{B}\left(\frac{s^2}{B} - m^2B\right)
\prod_{r=1}^{m-1} \prod_{s=1}^{n-1} \left(r^2B -\frac{s^2}{B} \right)^2.
\end{equation}
</div>
</div>
</div>
<div id="outline-container-org0d316c4" class="outline-3">
<h3 id="org0d316c4"><span class="section-number-3">2.4.</span> One point functions on the torus</h3>
<div class="outline-text-3" id="text-2-4">
</div>
<div id="outline-container-org8001cca" class="outline-4">
<h4 id="org8001cca">Chiral and non-chiral blocks</h4>
<div class="outline-text-4" id="text-org8001cca">
<p>
A one-point function on the torus can be written
</p>

\begin{align}
 \mathcal G(x) = <V_{\Delta_1}(x)> = \operatorname{Tr} (q^{L_0-\frac{c}{24}} \bar q^{\bar L_{0}-\frac{c}{24}} V_{\Delta_{1}}(x))
\end{align}

<p>
Because of translation invariance, one-point functions on the torus do not depend on the field&rsquo;s position. The trace can be written as
</p>

\begin{align}
  \mathcal G(x) &= \sum_{V_{\Delta} \in \mathcal S} < V_{\sigma} | V_{\Delta_{1}}(x) |V_{\sigma}> \\
                   &= \sum_{V_{\Delta} \in \mathcal S} \frac{C_{\Delta \Delta \Delta_{1}}}{B_{\Delta}} \mathcal G_{\Delta} (\tau, c, \Delta_{1} | x)
\end{align}

<p>
The conformal block \(\mathcal G_\Delta(\tau, c, \Delta_1|x)\) factorises for non-logarithmic theories, and we write \(\mathcal F_\Delta(\tau, c, \Delta_1 | x)\) the corresponding Virasoro chiral block.
</p>
</div>
</div>
<div id="outline-container-org73baf46" class="outline-4">
<h4 id="org73baf46">Zamolodchikov&rsquo;s recursion for torus one-point blocks</h4>
<div class="outline-text-4" id="text-org73baf46">
<p>
Like four-point blocks, torus one-point blocks can be computed recursively. We introduce \(H\) defined by
</p>

\begin{align}
  \mathcal F_{\Delta}(\tau, c, \Delta_{1} | x) = \frac{q^{\delta}}{\eta(q)} H^{\text{torus}}_{\Delta}(\tau, c, \Delta_{1} | q),
\end{align}

<p>
where \(q=e^{2i\pi \tau}\).
The recursion formula for \(H^{\text{torus}}_{\Delta}(\tau, c, \Delta_{1} | q)\) is
</p>

\begin{align}
  H_{\Delta}^{\text{torus}} (\tau, c, \Delta_{1} | q) = 1 + \sum_{N=1}^{N_{\text{max}}}\sum C^{N, \text{torus}}_{m,n} \frac{q^N}{\delta - \delta_{(m,n)}}
\end{align}

<p>
The coefficients \(C_{m,n}^{N,\text{torus}}\) have the recursive representation
</p>

\begin{equation}
\label{org30f862c}
C^{N,\text{torus}}_{m,n} = R^{\text{torus}}_{m,n}\left(\delta_{N-mn,0} + \sum_{m'n'\leq N-mn} \frac{C^{N-mn}_{m',n'}}{\delta_{(m,-n)}-\delta_{(m',n')}} \right)
\end{equation}

<p>
An expression for the \(R_{m,n}^{\text{torus}}\) can be found on <a href="https://en.wikipedia.org/wiki/Virasoro_conformal_block">this wikipedia article</a>. It can be rewritten
</p>

<p>
\[
R_{m,n}^{\text{torus}} = \frac{1}{2 D_{m,n}} \prod_{r\overset2=1-2m}^{2m-1} \prod_{s\overset2=1-2n}^{2n-1} \sqrt{\delta_{(r,s)} - \delta_1}
\]
</p>

<p>
where we do not actually take square roots, because each factor appears twice. The normalization factor is the same \(D_{m,n}\) as in the \eqref{orga9ecdf3} case <a href="Dmn">Dmn</a>
</p>
</div>
</div>
</div>
<div id="outline-container-org955394a" class="outline-3">
<h3 id="org955394a"><span class="section-number-3">2.5.</span> Logarithmic blocks</h3>
<div class="outline-text-3" id="text-2-5">
<p>
See <a href="https://arxiv.org/abs/2007.04190">this paper</a> for more detail (<a href="file:///Users/Paul/Downloads/log_CFT_ribault_nivesvivat.pdf">here</a> on my laptop).
</p>
</div>
<div id="outline-container-orgd7a686c" class="outline-4">
<h4 id="orgd7a686c">Logarithmic modules</h4>
<div class="outline-text-4" id="text-orgd7a686c">
<p>
In loop models the action of \(L_0\) is not diagonalisable, said otherwise some of the modules are logarithmic.
The structure of a logarithmic module \(\mathcal W^\kappa_{(r,s)}\) is the following:
</p>


<div id="org37be78e" class="figure">
<p><img src="./imgs/logarithmic_module.png" alt="logarithmic_module.png" />
</p>
</div>

<p>
\(\mathcal L V_{(r,s)}\) and \(\bar{\mathcal L} V_{(r,s)}\) are non-diagonal primary fields. The parameter \(\kappa\) is fixed in the presence of \(V^d_{\langle1,2\rangle}\), in which case the logarithmic module is generated by
</p>

\begin{align}
  W^{-}_{(r,s)} = \partial_{P} V_{P_{(r,-s)}} - \mathcal{L}_{(r,s)} \bar{\mathcal{L}}_{(r,s)} \partial_{P} V_{P_{(r,s)}}
\end{align}

<p>
This is the necessary condition for the OPE
</p>

\begin{align}
  V^{d}_{\langle 1,s_{0}\rangle} V_{P_{(r,0)}+\epsilon}
\end{align}

<p>
to be finite.
</p>
</div>
</div>
<div id="outline-container-orgc4bc9c4" class="outline-4">
<h4 id="orgc4bc9c4">Logarithmic blocks on the sphere</h4>
<div class="outline-text-4" id="text-orgc4bc9c4">
<p>
The expression of logarithmic four-point blocks on the sphere can be found by assuming the holomorphicity of the 4-point function
</p>

\begin{align}
 Z(P) = \sum_{k\in\mathbb{Z}} D_{P+k\beta^{-1}} \left|\mathcal{F}_{P+k\beta^{-1}}\right|^2 +\sum_{r=1}^\infty \sum_{s\in\frac{1}{r}\mathbb{Z}} D_{(r,s)}(P) \mathcal{G}_{(r,s)}\ .
\end{align}

<p>
(argument made by Sylvain in the <a href="file:///Users/Paul/Documents/Cours suivis/Sylvain CFT review/CFT-Review/solvable.pdf">solvable.pdf</a> file on <a href="https://github.com/ribault/CFT-Review">GitHub</a>).
</p>

<p>
The coefficient \(D_P\) has a double pole at \(P_{(r,-s)}\). The blocks \(\mathcal F_{P}\) have a simple pole at \(P_{(r,s)}\), and we write
</p>

\begin{align}
  \mathcal{F}_{P} = \frac{R_{r,s}}{P-P_{(r,s)}} \mathcal{F}_{P_{(r,-s)}} + \mathcal{F}^{\text{reg}}_{P_{(r,s)}} + O(P-P_{(r,s)}).
\end{align}

<p>
Explicitly, using Zamolodchikov&rsquo;s recursion, \(\mathcal F^{\text{reg}}\) is written as
</p>

\begin{align}
  \mathcal{F}^{\text{reg}}_{P_{(r,s)}} = (\text{prefactor}) H^{\text{reg}}_{P_{(r,s)}},
\end{align}

<p>
where the prefactor is the prefactor in Zamolodchikov&rsquo;s recursion, and
</p>

\begin{align}
  H^{\text{reg}}_{P_{(r,s)}} = 1 + \sum_{m,n} \left( \frac{1}{P^{2}_{(r,s)} - P^{2}_{(m,n)}} \right)^{\text{reg}} (16q)^{mn} R_{m,n} H_{P_{(m,-n)}}
\end{align}

<p>
and
</p>

\begin{align}
\left( \frac{1}{P^{2}_{(r,s)} - P^{2}_{(m,n)}} \right)^{\text{reg}} =
\begin{cases}
\log 16q - \frac{1}{4P_{(r,s)}^{2}} \text{  if  } (m,n)=(r,s) \\
\frac{1}{P^{2}_{(r,s)} - P^{2}_{(m,n)}}  \text{  otherwise}
\end{cases}.
\end{align}


<p>
Analysing the poles of this expression (there are double poles and simple ones), one arrives at the following expression for the logarithmic blocks: for \((r, s) \in \mathbb{N}^{*}\),
</p>

\begin{align}\label{eq:log_block}
\mathcal{G}_{(r,s)} = (\mathcal{F}_{P_{(r,s)}}^{\text{reg}} - R_{r,s}& \mathcal{F}^{'}_{P_{(r,-s)}}) \bar{\mathcal{F}}_{P_{(r,-s)}} + \frac{R_{r,s}}{\bar R_{r,s}} \mathcal{F}_{P_{(r,-s)}} (\bar{\mathcal{F}}_{P_{(r,s)}}^{\text{reg}} - \bar{R}_{r,s} \bar{\mathcal{F}}^{'}_{P_{(r,-s)}})\nonumber \\
& +R_{r,s} \underbrace{\left( \frac{D^{'}_{P_{(r,s)}}}{D_{P_{(r,s)}}} - \lim_{P \to P_{(r,-s)}} \left[ \frac{2}{P-P_{(r,-s)}} + \frac{D_{P}^{'}}{D_{P}} \right] \right)}_{-\ell^{(1)-}_{(r,s)}}\left|\mathcal{F}_{P_{(r,-s)}}\right|^{2},
\end{align}

<p>
in which the primes denote derivatives with respect to the momentum \(P\). The derivative of the block is
</p>

\begin{align}
  \mathcal{F}_{P_{(r,-s)}}^{'} = (\text{prefactor}) H^{\text{der}}_{P_{(r,-s)}}, \quad \text{where} \quad H^{\text{der}}_{P} = 2P\log(16q) H_{P} + H_{P}^{'}.
\end{align}

<p>
The term \(\ell^{(1)-}_{(r,s)}\) can be computed as the order 1 term in the Taylor expansion of
</p>

\begin{align}
  \log \left( \epsilon^{2} \frac{D_{P_{(r,-s)}+\epsilon}}{D_{P_{(r,s)+\epsilon}}} \right) = \sum_{n\geq 0} \ell^{(n)-}_{(r,s)} \epsilon^{n}.
\end{align}

<p>
Explicitly,
</p>

\begin{align}
 \beta\ell^{(1)-}_{(r,s)} = 4\sum_{j=1-s}^s &\Big\{ \psi(-2\beta^{-1}P_{(r,j)}) +\psi(2\beta^{-1}P_{( r,-j)}) \Big\}
 -4\pi \cot(\pi s \beta^{-2})
 \\
 &-\sum_{j\overset{2}{=}1-s}^{s-1}\sum_{\pm,\pm}\Big\{
 \psi\left(\tfrac12-\beta^{-1}(P_{( r,j)}\pm P_1\pm P_2)\right)
 + \psi\left(\tfrac12+\beta^{-1}(P_{( r,j)}\pm \bar P_1\pm \bar P_2)\right)
 \Big\}
 \\
 &-\sum_{j\overset{2}{=}1-s}^{s-1}\sum_{\pm,\pm}\Big\{
 \psi\left(\tfrac12-\beta^{-1}(P_{( r,j)}\pm P_3\pm P_4)\right)
 + \psi\left(\tfrac12+\beta^{-1}(P_{( r,j)}\pm \bar P_3\pm \bar P_4)\right)
 \Big\}
\end{align}

<p>
For \((r, s) \in \mathbb{N}^{*}\), \(\mathcal G_{(r,s)}\) can actually be non-logarithmic, due to residues \(R_{(r,s)}\) and \(\bar R_{(r,s)}\) vanishing.
</p>
</div>
</div>
<div id="outline-container-org2b66fce" class="outline-4">
<h4 id="org2b66fce">Logarithmic blocks on the torus</h4>
<div class="outline-text-4" id="text-org2b66fce">
<p>
The argument we used for computing logarithmic blocks on the sphere can be transferred verbatim to the case of one point blocks on the torus. In particular, the <a href="eq:log_block">expression</a> of the logarithmic block is also valid for the torus one-point block, if we replace \(D_P\) by the corresponding structure constant on the torus, namely
</p>

\begin{align}
  D_{P} \to \frac{C^{\text{ref}}_{P,P, P_1}}{B_{P}}
\end{align}

<p>
where \(P_1\) is the momentum of the external field.
</p>
</div>
</div>
</div>
<div id="outline-container-org4b0b086" class="outline-3">
<h3 id="org4b0b086"><span class="section-number-3">2.6.</span> Relation between sphere four-point blocks and torus one-point blocks</h3>
<div class="outline-text-3" id="text-2-6">
<p>
The recursion formulas for torus one-point blocks and sphere four-point blocks imply that four point blocks on the sphere are related to one-point blocks on the torus through the relation
</p>

\begin{align}
H^{\text{torus}}_{P}(\tau, c | P_{1} | q^{2}) = H_{\sqrt{2}P}\left(c' \left|\left. P_{(0,\frac12)}, \frac{P_{1}}{\sqrt{2}}, P_{(0,\frac12)}, P_{(0,\frac12)} \right.\right| q \right)
\end{align}

<p>
where
</p>
<ul class="org-ul">
<li>\(c'\) is related to \(c\) via \(\beta'=\frac\beta{\sqrt 2}\).</li>
<li>Fields on the RHS have dimensions \(\Delta = \frac{c'-1}{24} - P^2\).</li>
</ul>

<p>
Our code successfully reproduces this relation:
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">import</span> Pkg; Pkg.activate(<span style="color: #718c00;">"."</span>)
<span style="color: #8959a8;">using</span> BootstrapVirasoro, BenchmarkTools, EllipticFunctions
<span style="color: #8959a8;">import</span> BootstrapVirasoro.FourPointBlocksSphere.qfromx
q = BootstrapVirasoro.FourPointBlocksSphere.qfromx(<span style="color: #f5871f; font-weight: bold;">0.05</span>)

left=<span style="color: #f5871f; font-weight: bold;">1</span>;
right=<span style="color: #f5871f; font-weight: bold;">2</span>;
c_torus = CentralCharge(<span style="color: #f5871f;">:b</span>, <span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im);
c_sphere = CentralCharge(<span style="color: #f5871f;">:b</span>, (<span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im)<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>))

P = <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im
P1 = <span style="color: #f5871f; font-weight: bold;">0.41</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1.03</span>im
V_torus_chan = Field(c_torus, <span style="color: #f5871f;">:P</span>, P, diagonal=<span style="color: #f5871f;">true</span>)
&#948;_torus = V_torus_chan.&#948;[left]
&#948;11_torus = Field(c_torus, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>, diagonal=<span style="color: #f5871f;">true</span>).&#948;[left]
V_torus_ext = Field(c_torus, <span style="color: #f5871f;">:P</span>, P1, diagonal=<span style="color: #f5871f;">true</span>)
corr_torus = OnePointCorrelation

V_sphere_chan = Field(c_sphere, <span style="color: #f5871f;">:P</span>, sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>)<span style="color: #bb9200;">*</span>P, diagonal=<span style="color: #f5871f;">true</span>)
&#948;_sphere = V_sphere_chan.&#948;[left]
&#948;21_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>, diagonal=<span style="color: #f5871f;">true</span>).&#948;[left]
&#948;12_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>).&#948;[left]
V_sphere_ext = Field(c_sphere, <span style="color: #f5871f;">:P</span>, P1<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>), diagonal=<span style="color: #f5871f;">true</span>)
VKac_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>)

corr_torus = OnePointCorrelation(c_torus, V_torus_ext)
block_torus = OnePointBlockTorus(V_torus_chan)

corr_sphere = FourPointCorrelation(c_sphere, [VKac_sphere, V_sphere_ext, VKac_sphere,VKac_sphere])
block_sphere = FourPointBlockSphere(<span style="color: #f5871f;">:s</span>, V_sphere_chan)

h1 = BootstrapVirasoro.OnePointBlocksTorus.H(q<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">5</span>, block_torus, corr_torus, left)
h2 = BootstrapVirasoro.FourPointBlocksSphere.H(q, <span style="color: #f5871f; font-weight: bold;">5</span>, block_sphere, corr_sphere, left)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia">println(<span style="color: #718c00;">"torus block = $h1"</span>)
println(<span style="color: #718c00;">"sphere block = $h2"</span>)
</pre>
</div>
<p>
torus block = 1.0000059915273005 - 1.1912765043504052e-5im
sphere block = 1.000005991527301 - 1.1912765042311957e-5im
</p>
</div>
</div>
<div id="outline-container-org6ee68bf" class="outline-3">
<h3 id="org6ee68bf"><span class="section-number-3">2.7.</span> Crossing symmetry for four-point functions on the sphere</h3>
</div>

<div id="outline-container-org06c61d1" class="outline-3">
<h3 id="org06c61d1"><span class="section-number-3">2.8.</span> Modular invariance for one-point functions on the torus</h3>
</div>
</div>
<div id="outline-container-org5ff77ff" class="outline-2">
<h2 id="org5ff77ff"><span class="section-number-2">3.</span> Code of the package&#xa0;&#xa0;&#xa0;<span class="tag"><span class="noeval">noeval</span></span></h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org41dd4d3" class="outline-3">
<h3 id="org41dd4d3"><span class="section-number-3">3.1.</span> Main module</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The module <code>BootstrapVirasoro</code> is the main module of this package, and it includes the sub-modules.
</p>

<ul class="org-ul">
<li><code>CFTData</code> provides types for central charges and fields.</li>
<li><code>CorrelationFunctions</code> provides types for one-point and four-point correlation functions, as well as methods for computing coefficients appearing in their conformal blocks.</li>
<li><code>VirasoroConformalBlocks</code> provides types for representing four-point conformal blocks on the sphere and one-point conformal blocks on the torus, as well as methods for computing them.</li>
</ul>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">===========================================================================================#</span>

<span style="color: #8959a8;">module</span> BootstrapVirasoro

<span style="color: #8959a8;">using</span> Latexify <span style="color: #07c365;"># </span><span style="color: #07c365;">print outputs in latex format</span>

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Special functions</span>
<span style="color: #07c365;">===========================================================================================#</span>
include(<span style="color: #718c00;">"SpecialFunctions.jl"</span>)
<span style="color: #8959a8;">using</span> .SpecialFunctions
<span style="color: #8959a8;">export</span> Barnes_G
<span style="color: #8959a8;">export</span> logdoublegamma, doublegamma

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Central charges and fields</span>
<span style="color: #07c365;">===========================================================================================#</span>
include(<span style="color: #718c00;">"CFTData.jl"</span>)
<span style="color: #8959a8;">using</span> .CFTData
<span style="color: #8959a8;">export</span> CentralCharge
<span style="color: #8959a8;">export</span> ConformalDimension
<span style="color: #8959a8;">export</span> Field, spin

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Correlation functions</span>
<span style="color: #07c365;">===========================================================================================#</span>

<span style="color: #8959a8;">abstract type</span> <span style="color: #bb9200;">CorrelationFunction</span> <span style="color: #8959a8;">end</span>

include(<span style="color: #718c00;">"CorrelationFunctions.jl"</span>)
<span style="color: #8959a8;">using</span> .FourPointCorrelationFunctions
<span style="color: #8959a8;">export</span> FourPointCorrelation

<span style="color: #8959a8;">using</span> .OnePointCorrelationFunctions
<span style="color: #8959a8;">export</span> OnePointCorrelation

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Conformal blocks</span>
<span style="color: #07c365;">===========================================================================================#</span>

<span style="color: #8959a8;">abstract type</span> <span style="color: #bb9200;">ConformalBlock</span> <span style="color: #8959a8;">end</span>

include(<span style="color: #718c00;">"ConformalBlocks.jl"</span>)
<span style="color: #8959a8;">using</span> .FourPointBlocksSphere
<span style="color: #8959a8;">export</span> FourPointBlockSphere
<span style="color: #8959a8;">export</span> block_chiral, block_non_chiral

<span style="color: #8959a8;">using</span> .OnePointBlocksTorus
<span style="color: #8959a8;">export</span> OnePointBlockTorus

<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0cd72b2" class="outline-3">
<h3 id="org0cd72b2"><span class="section-number-3">3.2.</span> The <code>SpecialFunctions</code> module</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org8d37744" class="outline-4">
<h4 id="org8d37744">Header</h4>
<div class="outline-text-4" id="text-org8d37744">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">==================</span>

<span style="color: #07c365;">SpecialFunctions.jl computes the special functions relevant for our applications in 2D CFT.</span>

<span style="color: #07c365;">==================#</span>

<span style="color: #8959a8;">module</span> SpecialFunctions

<span style="color: #8959a8;">import</span> SpecialFunctions as SF
<span style="color: #8959a8;">using</span> Memoization
<span style="color: #8959a8;">using</span> ArbNumerics <span style="color: #07c365;"># </span><span style="color: #07c365;">the SpecialFunctions package has no arbitrary-precision complex-variable gamma function, however the ArbNumerics does. We use this, and convert to a Complex{BigFloat}</span>
<span style="color: #8959a8;">using</span> QuadGK <span style="color: #07c365;"># </span><span style="color: #07c365;">numerical integration</span>

<span style="color: #8959a8;">export</span> loggamma, gamma
<span style="color: #8959a8;">export</span> digamma_reg, Barnes_G, logdoublegamma, doublegamma

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    cotpi(x) = cot(&#960; * x)</span>
<span style="color: #718c00;">"""</span>
<span style="color: #4271ae;">cotpi</span>(x) = SF._cotpi(x)

ArbNumerics.loggamma = ArbNumerics.lgamma <span style="color: #07c365;"># </span><span style="color: #07c365;">rename ArbNumerics' loggamma function</span>

<span style="color: #8959a8;">for</span> f <span style="color: #8959a8;">in</span> (<span style="color: #f5871f;">:gamma</span>, <span style="color: #f5871f;">:digamma</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@eval</span> <span style="color: #bb9200;">$</span>f(z<span style="color: #bb9200;">::Union</span>{Real, Complex{Float64}}) = SF.<span style="color: #bb9200;">$</span>f(z)
    <span style="color: #4d4d4c; font-weight: bold;">@eval</span> <span style="color: #bb9200;">$</span>f(z<span style="color: #bb9200;">::Complex</span>{BigFloat}) = Complex{BigFloat}(ArbNumerics.<span style="color: #bb9200;">$</span>f(ArbComplex(z, bits=precision(BigFloat))))
<span style="color: #8959a8;">end</span>

<span style="color: #4271ae;">trigamma</span>(z<span style="color: #bb9200;">::Union</span>{Float64, Complex{Float64}}) = SF.trigamma(z)
<span style="color: #4271ae;">trigamma</span>(z<span style="color: #bb9200;">::Union</span>{BigFloat, Complex{BigFloat}}) = BigFloat(ArbNumerics.polygamma(ArbComplex(<span style="color: #f5871f; font-weight: bold;">1</span>, bits=precision(BigFloat)), ArbComplex(z, bits=precision(BigFloat))))

<span style="color: #4271ae;">loggamma</span>(z<span style="color: #bb9200;">::Union</span>{Real, Complex{Float64}}) = SF.loggamma(z)
<span style="color: #4271ae;">loggamma</span>(z<span style="color: #bb9200;">::Complex</span>{BigFloat}) = Complex{BigFloat}(ArbNumerics.lgamma(ArbComplex(z, bits=precision(BigFloat))))


<span style="color: #4271ae;">polygamma</span>(n, z<span style="color: #bb9200;">::Union</span>{Real, Complex{Float64}}) = SF.polygamma(n, z)
<span style="color: #4271ae;">polygamma</span>(n, z<span style="color: #bb9200;">::Complex</span>{BigFloat}) = Complex{BigFloat}(polygamma(ArbComplex(n), ArbComplex(z, bits=precision(BigFloat))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org899e7cc" class="outline-4">
<h4 id="org899e7cc">Regularized digamma Function</h4>
<div class="outline-text-4" id="text-org899e7cc">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Regularised digamma function"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">digamma_reg</span>(z)
    <span style="color: #8959a8;">if</span> real(z) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> digamma(z)
    <span style="color: #8959a8;">elseif</span> isreal(z) <span style="color: #bb9200;">&amp;&amp;</span> real(z) <span style="color: #bb9200;">&lt;</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">&amp;&amp;</span> real(z)<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> digamma(<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>z)
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">return</span> digamma(<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>z) <span style="color: #bb9200;">-</span> oftype(z, &#960;)<span style="color: #bb9200;">*</span>cotpi(z)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org22038cc" class="outline-4">
<h4 id="org22038cc">Double gamma function</h4>
<div class="outline-text-4" id="text-org22038cc">
<p>
The function <code>log_Barnes_GN</code> is the logarithm of the function <a href="eq:Barnes_{GN}">G<sub>N</sub></a>.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">integrandC</span>(x, &#964;)
    x = big(x)
    <span style="color: #8959a8;">return</span> exp((<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>&#964;)<span style="color: #bb9200;">*</span>x)<span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>sinh(x)<span style="color: #bb9200;">*</span>sinh(&#964;<span style="color: #bb9200;">*</span>x)) <span style="color: #bb9200;">-</span> exp(<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>x)<span style="color: #bb9200;">/</span>(&#964;<span style="color: #bb9200;">*</span>x)<span style="color: #bb9200;">*</span>(exp(x)<span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>sinh(x))<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>&#964;<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span>)
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">modularC</span>(&#964;)
    P = precision(BigFloat, base=<span style="color: #f5871f; font-weight: bold;">10</span>)
    <span style="color: #07c365;">#</span><span style="color: #07c365;">temporarily increase precision to avoid artificial divergence around zero</span>
    setprecision(BigFloat, base=<span style="color: #f5871f; font-weight: bold;">10</span>, Int(floor(<span style="color: #f5871f; font-weight: bold;">1.3</span><span style="color: #bb9200;">*</span>P)))
    cutoff = big(<span style="color: #f5871f; font-weight: bold;">10</span><span style="color: #bb9200;">^</span>(<span style="color: #bb9200;">-</span>P<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">5</span>)) <span style="color: #07c365;"># </span><span style="color: #07c365;">to prevent artificial divergence around zero</span>
    tol = big(<span style="color: #f5871f; font-weight: bold;">10</span>)<span style="color: #bb9200;">^</span>P
    value, error = quadgk(x <span style="color: #bb9200;">-&gt;</span> integrandC(x, &#964;), cutoff, big(<span style="color: #f5871f;">Inf</span>), rtol = tol, order=<span style="color: #f5871f; font-weight: bold;">21</span>)
    C0 = (<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>&#964; <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">3</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> &#964;<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">6</span>)<span style="color: #bb9200;">*</span>cutoff <span style="color: #bb9200;">+</span> (<span style="color: #f5871f; font-weight: bold;">5</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">12</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>&#964; <span style="color: #bb9200;">+</span> &#964;<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">12</span>)<span style="color: #bb9200;">*</span>cutoff<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> (<span style="color: #f5871f; font-weight: bold;">4</span><span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">9</span><span style="color: #bb9200;">*</span>&#964;) <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">9</span> <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">54</span><span style="color: #bb9200;">*</span>&#964; <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">270</span><span style="color: #bb9200;">*</span>&#964;<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">3</span>)<span style="color: #bb9200;">*</span>cutoff<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">3</span>
    setprecision(BigFloat, base=<span style="color: #f5871f; font-weight: bold;">10</span>, P)
    <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#964;)<span style="color: #bb9200;">*</span>log(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>oftype(&#964;, &#960;)) <span style="color: #bb9200;">-</span> value <span style="color: #bb9200;">-</span> C0
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">integrandD</span>(x, &#964;)
    x = big(x)
    <span style="color: #8959a8;">return</span> x<span style="color: #bb9200;">*</span>exp((<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>&#964;)<span style="color: #bb9200;">*</span>x)<span style="color: #bb9200;">/</span>(sinh(x)<span style="color: #bb9200;">*</span>sinh(&#964;<span style="color: #bb9200;">*</span>x)) <span style="color: #bb9200;">-</span> exp(<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>x)<span style="color: #bb9200;">/</span>(&#964;<span style="color: #bb9200;">*</span>x)
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">modularD</span>(&#964;)
    P = precision(BigFloat, base=<span style="color: #f5871f; font-weight: bold;">10</span>)
    <span style="color: #07c365;">#</span><span style="color: #07c365;">temporarily increase precision to avoid artificial divergence around zero</span>
    setprecision(BigFloat, base=<span style="color: #f5871f; font-weight: bold;">10</span>, Int(floor(<span style="color: #f5871f; font-weight: bold;">1.3</span><span style="color: #bb9200;">*</span>P)))
    cutoff = big(<span style="color: #f5871f; font-weight: bold;">10</span><span style="color: #bb9200;">^</span>(<span style="color: #bb9200;">-</span>P<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">5</span>)) <span style="color: #07c365;"># </span><span style="color: #07c365;">to prevent artificial divergence around zero</span>
    tol = big(<span style="color: #f5871f; font-weight: bold;">10</span>)<span style="color: #bb9200;">^</span>P
    value, error = quadgk( x <span style="color: #bb9200;">-&gt;</span> integrandD(x, &#964;), big(<span style="color: #f5871f; font-weight: bold;">0</span>), big(<span style="color: #f5871f;">Inf</span>), rtol = tol, order=<span style="color: #f5871f; font-weight: bold;">21</span>)
    setprecision(BigFloat, base=<span style="color: #f5871f; font-weight: bold;">10</span>, P)
    <span style="color: #8959a8;">return</span> value
<span style="color: #8959a8;">end</span>

<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> <span style="color: #8959a8;">function</span> modularcoeff_a(&#964;)
    <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#964;<span style="color: #bb9200;">*</span>log(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>oftype(&#964;, &#960;)<span style="color: #bb9200;">*</span>&#964;) <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>log(&#964;) <span style="color: #bb9200;">-</span> &#964;<span style="color: #bb9200;">*</span>modularC(&#964;)
<span style="color: #8959a8;">end</span>

<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> <span style="color: #8959a8;">function</span> modularcoeff_b(&#964;)
    <span style="color: #8959a8;">return</span> <span style="color: #bb9200;">-</span>&#964;<span style="color: #bb9200;">*</span>log(&#964;) <span style="color: #bb9200;">-</span> &#964;<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>modularD(&#964;)
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">log_Barnes_GN</span>(N, z, &#964;)
    res = <span style="color: #f5871f; font-weight: bold;">0</span>
    res <span style="color: #bb9200;">+=</span> <span style="color: #bb9200;">-</span> log(&#964;) <span style="color: #bb9200;">-</span> loggamma(z)
    res <span style="color: #bb9200;">+=</span> modularcoeff_a(&#964;)<span style="color: #bb9200;">*</span>z<span style="color: #bb9200;">/</span>&#964; <span style="color: #bb9200;">+</span> modularcoeff_b(&#964;)<span style="color: #bb9200;">*</span>z<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#964;<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)
    res <span style="color: #bb9200;">+=</span> sum(loggamma(m<span style="color: #bb9200;">*</span>&#964;) <span style="color: #bb9200;">-</span> loggamma(z<span style="color: #bb9200;">+</span>m<span style="color: #bb9200;">*</span>&#964;) <span style="color: #bb9200;">+</span> z<span style="color: #bb9200;">*</span>digamma(m<span style="color: #bb9200;">*</span>&#964;)<span style="color: #bb9200;">+</span>z<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>trigamma(m<span style="color: #bb9200;">*</span>&#964;) <span style="color: #8959a8;">for</span> m <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N)
    <span style="color: #8959a8;">return</span> res
<span style="color: #8959a8;">end</span>

<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> <span style="color: #8959a8;">function</span> factorial_big(n)<span style="color: #bb9200;">::BigInt</span>
    <span style="color: #8959a8;">return</span> factorial(big(n))
<span style="color: #8959a8;">end</span>

<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> <span style="color: #8959a8;">function</span> polynomial_Pn(n, z, &#964;)
    <span style="color: #8959a8;">if</span> n <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">6</span>
    <span style="color: #8959a8;">else</span>
        term1 = z<span style="color: #bb9200;">^</span>(n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span>factorial_big(n<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">2</span>)
        <span style="color: #4271ae;">summand</span>(k) = ((<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">+</span>&#964;)<span style="color: #bb9200;">^</span>(k<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">2</span>) <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">-</span> &#964;<span style="color: #bb9200;">^</span>(k<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">2</span>))<span style="color: #bb9200;">/</span>(factorial_big(k<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">2</span>)<span style="color: #bb9200;">*</span>&#964;) <span style="color: #bb9200;">*</span> polynomial_Pn(n<span style="color: #bb9200;">-</span>k, z, &#964;)
        <span style="color: #8959a8;">return</span> term1 <span style="color: #bb9200;">-</span> sum(summand(k) <span style="color: #8959a8;">for</span> k <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">rest_RMN</span>(M, N, z, &#964;)
    <span style="color: #8959a8;">return</span> sum(factorial_big(k<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">*</span>(<span style="color: #bb9200;">-</span>&#964;)<span style="color: #bb9200;">^</span>(<span style="color: #bb9200;">-</span>k<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">*</span>polynomial_Pn(k, z, <span style="color: #bb9200;">-</span>&#964;)<span style="color: #bb9200;">/</span>N<span style="color: #bb9200;">^</span>k <span style="color: #8959a8;">for</span> k <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:M)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Numerical approximation of the logarithm of Barne's G-function, up to a given tolerance"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">log_Barnes_G</span>(z, &#964;, tol)
    z = complex(z)
    d = <span style="color: #bb9200;">-</span>log(tol)<span style="color: #bb9200;">/</span>log(<span style="color: #f5871f; font-weight: bold;">10</span>)
    M = BigInt(floor(<span style="color: #f5871f; font-weight: bold;">0.7</span><span style="color: #bb9200;">*</span>log(<span style="color: #f5871f; font-weight: bold;">10</span>)<span style="color: #bb9200;">/</span>log(<span style="color: #f5871f; font-weight: bold;">20</span>)<span style="color: #bb9200;">*</span>d))
    N = <span style="color: #f5871f; font-weight: bold;">20</span><span style="color: #bb9200;">*</span>M
    <span style="color: #8959a8;">return</span> log_Barnes_GN(N, z, &#964;) <span style="color: #bb9200;">+</span> z<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">3</span><span style="color: #bb9200;">*</span>rest_RMN(M, N, z, &#964;)
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Barnes_G</span>(z, &#964;, tol)
    <span style="color: #8959a8;">return</span> exp(log_Barnes_G(z, &#964;, tol))
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">log_Gamma_2</span>(w, &#946;, tol)
    &#946; = real(&#946;<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>&#946;) <span style="color: #bb9200;">&lt;</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #8959a8;">?</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>&#946; <span style="color: #8959a8;">:</span> &#946; <span style="color: #07c365;"># </span><span style="color: #07c365;">change &#946; -&gt; 1/&#946; if needed</span>
    <span style="color: #8959a8;">return</span> w<span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#946;)<span style="color: #bb9200;">*</span>log(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>oftype(&#946;, &#960;)) <span style="color: #bb9200;">+</span> (w<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>(w<span style="color: #bb9200;">-</span>&#946;<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>&#946;)<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">*</span>log(&#946;) <span style="color: #bb9200;">-</span> log_Barnes_G(w<span style="color: #bb9200;">/</span>&#946;, <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>&#946;<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>, tol)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">        logdoublegamma(w, &#946;, tol) = &#915;_&#946;(w)</span>

<span style="color: #718c00;">Compute the logarithm of the double gamma function &#915;_&#946;(w, &#946;) with precision tol</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">logdoublegamma</span>(w, &#946;, tol)
    <span style="color: #8959a8;">return</span> log_Gamma_2(w, &#946;, tol) <span style="color: #bb9200;">-</span> log_Gamma_2((&#946;<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>&#946;)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span>, &#946;, tol)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">        doublegamma(w, &#946;, tol)</span>

<span style="color: #718c00;">Compute the double gamma function &#915;_&#946;(w, &#946;) with precision tol</span>

<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">doublegamma</span>(w, &#946;, tol)
    exp(logdoublegamma(w, &#946;, tol))
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org589ba90" class="outline-4">
<h4 id="org589ba90">End module</h4>
<div class="outline-text-4" id="text-org589ba90">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org50e4783" class="outline-3">
<h3 id="org50e4783"><span class="section-number-3">3.3.</span> The <code>CFTData</code> module</h3>
<div class="outline-text-3" id="text-3-3">
<p>
The file <a href="src/CFTData.jl">CFTData.jl</a> defines
</p>
<ul class="org-ul">
<li>a type <code>CentralCharge</code> that represents a central charge \(c\).</li>
<li>a type <code>Field</code> that represents a field \(V\). The field can be defined from its Kac indices \(r, s\), be diagonal, logarithmic, or degenerate. The struct contains booleans for these three characteristics, as well as rationals for \(r\) and \(s\), and the pairs of (left, right) values \((\Delta, \bar \Delta)\), \((p, \bar p)\), \((\delta, \bar \delta)\), \((P, \bar P)\).</li>
</ul>
</div>
<div id="outline-container-orgda6695a" class="outline-4">
<h4 id="orgda6695a">Header</h4>
<div class="outline-text-4" id="text-orgda6695a">
<div class="org-src-container">
<pre class="src src-julia">
<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">CFTData.jl contains a module CFTData that provides types representing</span>
<span style="color: #07c365;">central charges and fields in 2D CFTs with Virasoro symmetry.</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">============================================================================================#</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Provides types representing central charges and fields in CFT.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">module</span> CFTData

<span style="color: #8959a8;">using</span> Match, Latexify;

<span style="color: #8959a8;">export</span> CentralCharge
<span style="color: #8959a8;">export</span> ConformalDimension
<span style="color: #8959a8;">export</span> Field, spin
</pre>
</div>
</div>
</div>
<div id="outline-container-orgde916af" class="outline-4">
<h4 id="orgde916af">Central charge</h4>
<div class="outline-text-4" id="text-orgde916af">
</div>
<ul class="org-ul">
<li><a id="org22fd77f"></a>Constructors, parametrisations<br />
<div class="outline-text-5" id="text-org22fd77f">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    CentralCharge{T}</span>

<span style="color: #718c00;">Type representing a central charge.</span>
<span style="color: #718c00;">T is expected to be a real or complex number, of standard or arbitrary precision</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">CentralCharge</span>{T <span style="color: #bb9200;">&lt;:</span> <span style="color: #bb9200;">Union</span>{AbstractFloat, Complex{Float64}, Complex{BigFloat}}}

    &#946;<span style="color: #bb9200;">::T</span>

<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Get B from given parameter"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Bfrom</span>(s<span style="color: #bb9200;">::Symbol</span>, x)
    a = (x<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">*</span>(x<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">25</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> s <span style="color: #8959a8;">begin</span>
        <span style="color: #f5871f;">:&#946;</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #bb9200;">-</span>x<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
        <span style="color: #f5871f;">:c</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #8959a8;">if</span> isreal(a) <span style="color: #bb9200;">&amp;&amp;</span> a <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
                 (x<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">13</span><span style="color: #bb9200;">+</span>sqrt((x<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">*</span>(x<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">25</span>)))<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">12</span>
              <span style="color: #8959a8;">else</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">a is complex</span>
                 (x<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">13</span><span style="color: #bb9200;">+</span>sqrt(complex((x<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">*</span>(x<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">25</span>))))<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">12</span>
              <span style="color: #8959a8;">end</span>
        <span style="color: #f5871f;">:b</span> <span style="color: #bb9200;">=&gt;</span> x<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
        <span style="color: #f5871f;">:B</span> <span style="color: #bb9200;">=&gt;</span> x
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Get asked parameter from B"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Bto</span>(s<span style="color: #bb9200;">::Symbol</span>, x)
    rx = sqrt(complex(x))
    res = <span style="color: #4d4d4c; font-weight: bold;">@match</span> s <span style="color: #8959a8;">begin</span>
        <span style="color: #f5871f;">:&#946;</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #bb9200;">-</span>im<span style="color: #bb9200;">*</span>rx
        <span style="color: #f5871f;">:c</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">13</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">6</span><span style="color: #bb9200;">*</span>x<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">6</span><span style="color: #bb9200;">/</span>x
        <span style="color: #f5871f;">:b</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #bb9200;">-</span>rx
        <span style="color: #f5871f;">:B</span> <span style="color: #bb9200;">=&gt;</span> x
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> isreal(res) <span style="color: #8959a8;">?</span> real(res) <span style="color: #8959a8;">:</span> res
<span style="color: #8959a8;">end</span>


<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">getproperty</span>(c<span style="color: #bb9200;">::CentralCharge</span>, s<span style="color: #bb9200;">::Symbol</span>)
    &#946; = Bto(<span style="color: #f5871f;">:&#946;</span>, Bfrom(<span style="color: #f5871f;">:&#946;</span>, getfield(c, <span style="color: #f5871f;">:&#946;</span>)))
    &#946; = isreal(&#946;) <span style="color: #8959a8;">?</span> real(&#946;) <span style="color: #8959a8;">:</span> &#946;
    <span style="color: #8959a8;">if</span> s <span style="color: #bb9200;">===</span> <span style="color: #f5871f;">:&#946;</span>
        &#946;
    <span style="color: #8959a8;">elseif</span> s <span style="color: #bb9200;">===</span> <span style="color: #f5871f;">:c</span>
        <span style="color: #f5871f; font-weight: bold;">13</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">6</span><span style="color: #bb9200;">*</span>&#946;<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">6</span><span style="color: #bb9200;">/</span>&#946;<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
    <span style="color: #8959a8;">elseif</span> s <span style="color: #bb9200;">===</span> <span style="color: #f5871f;">:B</span>
        <span style="color: #bb9200;">-</span>&#946;<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
    <span style="color: #8959a8;">elseif</span> s <span style="color: #bb9200;">===</span> <span style="color: #f5871f;">:b</span>
        <span style="color: #bb9200;">-</span>im<span style="color: #bb9200;">*</span>&#946;
    <span style="color: #8959a8;">elseif</span> s <span style="color: #bb9200;">===</span> <span style="color: #f5871f;">:n</span>
        <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>cos(oftype(&#946;, &#960;)<span style="color: #bb9200;">*</span>&#946;<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)
    <span style="color: #8959a8;">else</span>
        error(<span style="color: #718c00;">"$s is not a supported parametrisation of the central charge"</span>)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    CentralCharge(parameter, value)</span>

<span style="color: #718c00;">Constructor function for the CentralCharge type.</span>

<span style="color: #718c00;">Given one of the four parameters `c`, `b`, `&#946;`, `B` and its value,</span>
<span style="color: #718c00;">creates an object CentralCharge{T} where T is real if `&#946;` is real.</span>

<span style="color: #718c00;"># Example</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; setprecision(BigFloat, 20, base=10)</span>
<span style="color: #718c00;">julia&gt; CentralCharge(big"1.2")</span>
<span style="color: #718c00;">c = 0.1933333333333333332741, &#946; = 1.200000000000000000003</span>

<span style="color: #718c00;">```</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">CentralCharge</span>(s<span style="color: #bb9200;">::Symbol</span>, x)
    &#946; = Bto(<span style="color: #f5871f;">:&#946;</span>, Bfrom(s, x))
    CentralCharge(&#946;)
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="orgf931036"></a>Pretty printing<br />
<div class="outline-text-5" id="text-orgf931036">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Display an object of type CentralCharge"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, c<span style="color: #bb9200;">::CentralCharge</span>)
    println(<span style="color: #718c00;">"c = $(c.c), &#946; = $(c.&#946;)"</span>)
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgfbc6b85" class="outline-4">
<h4 id="orgfbc6b85">Conformal dimensions and Fields</h4>
<div class="outline-text-4" id="text-orgfbc6b85">
<p>
Fields can be given from any of the four parameters \(\Delta, \delta, P, p\). Optional keyword arguments lets us choose whether the field is diagonal, degenerate, logarithmic. The field can also be defined from its r and s indices using the keyword argument Kac = true.
</p>
</div>
<ul class="org-ul">
<li><a id="orge424c3c"></a>Conformal dimensions<br />
<div class="outline-text-5" id="text-orge424c3c">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Get P from any given parameter"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Pfrom</span>(s<span style="color: #bb9200;">::Symbol</span>, x, c<span style="color: #bb9200;">::CentralCharge</span>)
    res = <span style="color: #4d4d4c; font-weight: bold;">@match</span> s <span style="color: #8959a8;">begin</span>
        <span style="color: #f5871f;">:&#916;</span> <span style="color: #bb9200;">=&gt;</span> sqrt(complex(x <span style="color: #bb9200;">-</span> (c.c<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>))
        <span style="color: #f5871f;">:&#948;</span> <span style="color: #bb9200;">=&gt;</span> sqrt(complex(x))
        <span style="color: #f5871f;">:P</span> <span style="color: #bb9200;">=&gt;</span> x
        <span style="color: #f5871f;">:p</span> <span style="color: #bb9200;">=&gt;</span> im<span style="color: #bb9200;">*</span>x
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> isreal(res) <span style="color: #8959a8;">?</span> real(res) <span style="color: #8959a8;">:</span> res
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Get all parameters from P"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Pto</span>(s<span style="color: #bb9200;">::Symbol</span>, x, c<span style="color: #bb9200;">::CentralCharge</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> s <span style="color: #8959a8;">begin</span>
        <span style="color: #f5871f;">:&#916;</span> <span style="color: #bb9200;">=&gt;</span> x<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> (c.c<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
        <span style="color: #f5871f;">:&#948;</span> <span style="color: #bb9200;">=&gt;</span> x<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
        <span style="color: #f5871f;">:P</span> <span style="color: #bb9200;">=&gt;</span> x
        <span style="color: #f5871f;">:p</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #bb9200;">-</span>im<span style="color: #bb9200;">*</span>x
        <span style="color: #f5871f;">:w</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>cos(oftype(c.&#946;, &#960;)<span style="color: #bb9200;">*</span>c.&#946;<span style="color: #bb9200;">*</span>x)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    ConformalDimension{T}</span>
<span style="color: #718c00;">Type for encoding a conformal dimension, and conveniently access its values in all parametrisations</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">ConformalDimension</span>{T <span style="color: #bb9200;">&lt;:</span> <span style="color: #bb9200;">Union</span>{AbstractFloat, Complex{Float64}, Complex{BigFloat}}}

    c<span style="color: #bb9200;">::CentralCharge</span>{T}
    P<span style="color: #bb9200;">::T</span>
    isKac<span style="color: #bb9200;">::Bool</span>
    r<span style="color: #bb9200;">::Rational</span>
    s<span style="color: #bb9200;">::Rational</span>

<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">ConformalDimension</span>(c<span style="color: #bb9200;">::CentralCharge</span>{T}, sym<span style="color: #bb9200;">::Symbol</span>=<span style="color: #f5871f;">:P</span>, P=<span style="color: #f5871f; font-weight: bold;">0</span>; Kac=<span style="color: #f5871f;">false</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">0</span>) <span style="color: #8959a8;">where</span> {T}
    <span style="color: #8959a8;">if</span> Kac
        P = (r<span style="color: #bb9200;">*</span>c.&#946;<span style="color: #bb9200;">-</span>s<span style="color: #bb9200;">/</span>c.&#946;)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span>
    <span style="color: #8959a8;">else</span>
        P = Pto(<span style="color: #f5871f;">:P</span>, Pfrom(sym, P, c), c)
    <span style="color: #8959a8;">end</span>
    ConformalDimension{T}(c, P, Kac, r, s)
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">getproperty</span>(d<span style="color: #bb9200;">::ConformalDimension</span>, s<span style="color: #bb9200;">::Symbol</span>)
    c = getfield(d, <span style="color: #f5871f;">:c</span>)
    P = Pto(<span style="color: #f5871f;">:P</span>, Pfrom(<span style="color: #f5871f;">:P</span>, getfield(d, <span style="color: #f5871f;">:P</span>), c), c)
    P = isreal(P) <span style="color: #8959a8;">?</span> real(P) <span style="color: #8959a8;">:</span> P
    <span style="color: #8959a8;">if</span> s in (<span style="color: #f5871f;">:P</span>, <span style="color: #f5871f;">:p</span>, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f;">:&#948;</span>, <span style="color: #f5871f;">:w</span>)
        <span style="color: #8959a8;">return</span> Pto(s, P, c)
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">return</span> getfield(d, s)
    <span style="color: #8959a8;">end</span>
    res = isreal(res) <span style="color: #8959a8;">?</span> real(res) <span style="color: #8959a8;">:</span> res
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org003cdce"></a>Fields<br />
<div class="outline-text-5" id="text-org003cdce">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">const</span> <span style="color: #c82829;">left, right</span> = <span style="color: #f5871f; font-weight: bold;">1</span>, <span style="color: #f5871f; font-weight: bold;">2</span>


<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    Field{T}</span>
<span style="color: #718c00;">Object representing a conformal field.</span>
<span style="color: #718c00;">Contains the conformal dimensions, and flags saying whether the field has (rational) Kac indices, is degenerate, or diagonal.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">Field</span>{T <span style="color: #bb9200;">&lt;:</span> <span style="color: #bb9200;">Union</span>{AbstractFloat, Complex{Float64}, Complex{BigFloat}}}

    dim<span style="color: #bb9200;">::Tuple</span>{ConformalDimension{T}, ConformalDimension{T}}
    isdiagonal<span style="color: #bb9200;">::Bool</span>
    isdegenerate<span style="color: #bb9200;">::Bool</span>

<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">   </span><span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> update the examples</span>
<span style="color: #718c00;">    Field(charge, parameter, leftvalue, rightvalue; kwargs...)</span>

<span style="color: #718c00;">Constructor function for the Field type.</span>

<span style="color: #718c00;">Given a charge `charge`, one of the four parameters `&#916;`, `&#948;`, `P`, `p` and two values,</span>
<span style="color: #718c00;">create an object `Field{T}` (where T is the type of the values in `charge`) that represents a</span>
<span style="color: #718c00;">field of left and right dimensions given by leftvalue and rightvalue in the chosen</span>
<span style="color: #718c00;">parametrisation.</span>
<span style="color: #718c00;">If given only one value for the parameters `&#916;`, `&#948;`, `P` or `p`, the field is diagonal by default</span>

<span style="color: #718c00;"># keyword arguments:</span>

<span style="color: #718c00;">- `Kac::Bool`: if set to true, the field can be constructed from the values of its r and s</span>
<span style="color: #718c00;">indices. By convention V_(r,s) has left and right momenta (P_(r,s), P_(r,-s))</span>
<span style="color: #718c00;">- `r::Rational`,`s::Rational`: used in conjunction to `Kac=true`, must be given rational</span>
<span style="color: #718c00;">values,</span>
<span style="color: #718c00;">- `degenerate::Bool`: set to True if the field is degenerate,</span>
<span style="color: #718c00;">- `diagonal::Bool`: set to True to get a diagonal field ; only the leftvalue needs to be</span>
<span style="color: #718c00;">given.</span>

<span style="color: #718c00;"># Examples</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; charge = CentralCharge(:b, big(0.5));</span>
<span style="color: #718c00;">julia&gt; field = Field(charge, Kac=true, r=0, s=1)</span>
<span style="color: #718c00;">Non-diagonal field with Kac indices r = 0//1, s = 1//1 and (left,right) dimensions:</span>
<span style="color: #718c00;">&#916; = ( 2.5625 + 0.0im, 2.5625 + 0.0im )</span>
<span style="color: #718c00;">  P = ( -0.0 - 1.0im, 0.0 + 1.0im )</span>
<span style="color: #718c00;">&#948; = ( 1.0 - 0.0im, 1.0 + 0.0im )</span>
<span style="color: #718c00;">p = ( -1.0 + 0.0im, 1.0 + 0.0im )</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; charge = CentralCharge(:&#946;, 1.5+im);</span>
<span style="color: #718c00;">julia&gt; Field(charge, "&#948;", 2, 3)</span>
<span style="color: #718c00;">Non-diagonal field with (left, right) dimensions:</span>
<span style="color: #718c00;">&#916; = ( 2.1579142011834325 - 0.6789940828402367im, 3.1579142011834316 - 0.6789940828402367im )</span>
<span style="color: #718c00;">P = ( 0.0 + 1.4142135623730951im, 0.0 + 1.7320508075688772im )</span>
<span style="color: #718c00;">&#948; = ( 2.0000000000000004 + 0.0im, 2.9999999999999996 + 0.0im )</span>
<span style="color: #718c00;">p = ( 1.4142135623730951 + 0.0im, 1.7320508075688772 + 0.0im )</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; charge = CentralCharge();</span>
<span style="color: #718c00;">julia&gt; Field(charge, "&#948;", 1, diagonal=true)</span>
<span style="color: #718c00;">Diagonal field of dimension:</span>
<span style="color: #718c00;">&#916; = 1.0 + 0.0im</span>
<span style="color: #718c00;">P = 0.0 + 1.0im</span>
<span style="color: #718c00;">&#948; = 1.0 + 0.0im</span>
<span style="color: #718c00;">p = 1.0 + 0.0im</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Field</span>(c<span style="color: #bb9200;">::CentralCharge</span>{T}, sym<span style="color: #bb9200;">::Symbol</span>=<span style="color: #f5871f;">:P</span>, dim=<span style="color: #f5871f; font-weight: bold;">0</span>;
               Kac=<span style="color: #f5871f;">false</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">0</span>, degenerate=<span style="color: #f5871f;">false</span>, diagonal=<span style="color: #f5871f;">false</span>) <span style="color: #8959a8;">where</span> {T}

    <span style="color: #8959a8;">if</span><span style="color: #bb9200;"> !</span>Kac
        <span style="color: #07c365;"># </span><span style="color: #07c365;">diagonal = true # a field not given from Kac indices is diagonal</span>
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">if</span> degenerate <span style="color: #07c365;"># </span><span style="color: #07c365;">degenerate fields are diagonal and must be given from Kac indices</span>
        Kac = <span style="color: #f5871f;">true</span>
        diagonal = <span style="color: #f5871f;">true</span>
    <span style="color: #8959a8;">end</span>
    dim_left = ConformalDimension(c, sym, dim, Kac=Kac, r=r, s=s)
    <span style="color: #8959a8;">if</span> diagonal
        dim_right = dim_left
    <span style="color: #8959a8;">else</span>
        <span style="color: #4d4d4c; font-weight: bold;">@assert</span> Kac<span style="color: #bb9200;">==</span><span style="color: #f5871f;">true</span> <span style="color: #718c00;">"A non-diagonal field must be given from Kac indices"</span>
        dim_right = ConformalDimension(c, sym, dim_left, Kac=Kac, r=r, s=<span style="color: #bb9200;">-</span>s)
    <span style="color: #8959a8;">end</span>

    Field{T}((dim_left, dim_right), diagonal, degenerate)
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">getproperty</span>(V<span style="color: #bb9200;">::Field</span>, s<span style="color: #bb9200;">::Symbol</span>)
    ds = getfield(V, <span style="color: #f5871f;">:dim</span>)
    <span style="color: #8959a8;">if</span> s <span style="color: #bb9200;">===</span> <span style="color: #f5871f;">:P</span>
        <span style="color: #8959a8;">return</span> ds[left].P, ds[right].P
    <span style="color: #8959a8;">elseif</span> s <span style="color: #bb9200;">===</span> <span style="color: #f5871f;">:&#916;</span>
        <span style="color: #8959a8;">return</span> ds[left].&#916;, ds[right].&#916;
    <span style="color: #8959a8;">elseif</span> s <span style="color: #bb9200;">===</span> <span style="color: #f5871f;">:p</span>
        <span style="color: #8959a8;">return</span> ds[left].p, ds[right].p
    <span style="color: #8959a8;">elseif</span> s <span style="color: #bb9200;">===</span> <span style="color: #f5871f;">:&#948;</span>
        <span style="color: #8959a8;">return</span> ds[left].&#948;, ds[right].&#948;
    <span style="color: #8959a8;">elseif</span> s in (<span style="color: #f5871f;">:r</span>, <span style="color: #f5871f;">:s</span>)
        <span style="color: #8959a8;">return</span> getfield(ds[left], s) <span style="color: #07c365;"># </span><span style="color: #07c365;">by convention V_(r,s) denotes the field with left right dimension P_(r, s), P_(r, -s)</span>
    <span style="color: #8959a8;">elseif</span> s <span style="color: #bb9200;">===</span> <span style="color: #f5871f;">:isKac</span>
        <span style="color: #8959a8;">return</span> (V.dim[left].isKac <span style="color: #bb9200;">&amp;&amp;</span> V.dim[right].isKac <span style="color: #bb9200;">&amp;&amp;</span> V.dim[left].r <span style="color: #bb9200;">==</span> V.dim[left].r <span style="color: #bb9200;">&amp;&amp;</span> V.dim[left].s <span style="color: #bb9200;">==</span> <span style="color: #bb9200;">-</span>V.dim[right].s)
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">return</span> getfield(V, s)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #07c365;"># </span><span style="color: #07c365;">Overload the == operator</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Base</span>.:(<span style="color: #bb9200;">==</span>)(V1<span style="color: #bb9200;">::Field</span>, V2<span style="color: #bb9200;">::Field</span>)
    <span style="color: #8959a8;">return</span> V1.&#916; <span style="color: #bb9200;">==</span> V2.&#916;
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Compute the spin &#916;left - &#916;right of a field."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">spin</span>(V<span style="color: #bb9200;">::Field</span>)<span style="color: #bb9200;">::Rational</span>
    <span style="color: #8959a8;">if</span> V.isdiagonal
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">elseif</span> V.isKac
        <span style="color: #8959a8;">return</span> V.r<span style="color: #bb9200;">*</span>V.s
    <span style="color: #8959a8;">else</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">this should never happen</span>
        <span style="color: #8959a8;">return</span> V.&#916;[<span style="color: #f5871f; font-weight: bold;">1</span>] <span style="color: #bb9200;">-</span> V.&#916;[<span style="color: #f5871f; font-weight: bold;">2</span>]
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org6050277"></a>Pretty printing<br />
<div class="outline-text-5" id="text-org6050277">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, d<span style="color: #bb9200;">::ConformalDimension</span>)
    <span style="color: #8959a8;">if</span> d.isKac
        print(io, <span style="color: #718c00;">"Kac indices r = $(d.r), s=$(d.s)"</span>)
    <span style="color: #8959a8;">else</span>
        print(io, <span style="color: #718c00;">"&#916; = $(d.&#916;), P = $(d.P)"</span>)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, V<span style="color: #bb9200;">::Field</span>)
    <span style="color: #8959a8;">if</span> V.isdiagonal
        print(io, <span style="color: #718c00;">"Diagonal $(typeof(V)) with "</span>)
        show(V.dim[left])
    <span style="color: #8959a8;">else</span>
        println(io, <span style="color: #718c00;">"Non-diagonal $(typeof(V))"</span>)
        print(io, <span style="color: #718c00;">"left: "</span>)
        show(V.dim[left])
        print(io, <span style="color: #718c00;">"\nright: "</span>)
        show(V.dim[right])
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org49e60c3" class="outline-4">
<h4 id="org49e60c3">End of module</h4>
<div class="outline-text-4" id="text-org49e60c3">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga9ee159" class="outline-3">
<h3 id="orga9ee159"><span class="section-number-3">3.4.</span> The <code>FourPointCorrelationFunctions</code> module</h3>
<div class="outline-text-3" id="text-3-4">
<p>
The module <code>FourPointCorrelationFunctions</code> defines
</p>

<ul class="org-ul">
<li><p>
a struct <code>FourPointCorrelation</code> that represents a four point function
</p>

<p>
\[
  < V_1(0) V_2(1) V_3(\infty) V_4(x)>
  \]
</p></li>

<li>a method <code>computeCNmn</code> that computes the coefficients \(C^N_{m,n}\) which serve to compute the conformal blocks that enter the expansion of the 4-pt function.</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgf004735"></a>Header<br />
<div class="outline-text-5" id="text-orgf004735">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">===========================================================================================#</span>

<span style="color: #8959a8;">module</span> FourPointCorrelationFunctions

<span style="color: #8959a8;">export</span> FourPointCorrelation, computeCNmn

<span style="color: #8959a8;">using</span> ..CFTData
<span style="color: #8959a8;">using</span> Match
<span style="color: #8959a8;">import</span> Memoization: <span style="color: #4d4d4c; font-weight: bold;">@memoize</span>
</pre>
</div>
</div>
</li>
<li><a id="org5a0532d"></a>Four-point correlation type<br />
<div class="outline-text-5" id="text-org5a0532d">
<p>
We create a struct <code>FourPointCorrelation</code> for representing a four-point function on the sphere, that is, a central charge and four external fields.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Struct representing a four-point function. Contains</span>
<span style="color: #718c00;">- a central charge</span>
<span style="color: #718c00;">- 4 external fields</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">FourPointCorrelation</span>{T}
    charge<span style="color: #bb9200;">::CentralCharge</span>{T}
    fields<span style="color: #bb9200;">::Vector</span>{Field{T}}
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">FourPointCorrelation</span>(c<span style="color: #bb9200;">::CentralCharge</span>, V1, V2, V3, V4)
    <span style="color: #8959a8;">return</span> FourPointCorrelation(c, [V1, V2, V3, V4])
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display a four-point function"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>)
    print(<span style="color: #718c00;">"Four-point correlation function: &lt; V_1 V_2 V_3 V_4 &gt; where "</span>)
    print(<span style="color: #718c00;">"\nV_1 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>])
    print(<span style="color: #718c00;">"\nV_2 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">2</span>])
    print(<span style="color: #718c00;">"\nV_3 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">3</span>])
    print(<span style="color: #718c00;">"\nV_4 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">4</span>])
<span style="color: #8959a8;">end</span>

<span style="color: #07c365;"># </span><span style="color: #07c365;">explicit names for the indices of left and right dimensions</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">left</span> = <span style="color: #f5871f; font-weight: bold;">1</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">right</span> = <span style="color: #f5871f; font-weight: bold;">2</span>
</pre>
</div>
</div>
</li>
<li><a id="orge8ed650"></a>Compute \(C^N_{m,n}\)<br />
<div class="outline-text-5" id="text-orge8ed650">
<p>
The function <code>permute_ext_fields</code> permutes the external fields such that the first two and last two are fused together in the channel.
</p>

<p>
The function <code>Rmn_zero_order</code> computes the order of a zero of R, to avoid computing 0/0 in \(\frac{R_{m,n}}{\delta - \delta_{r,s}}\). At generic central charge (non-rational) \(R_{m,n}\) is zero iff one of the two pairs of fused fields have Kac indices such that \(r_1 \pm r_2 \in \{1-m, 3-m, \dots, m-1\}\) or \(s_1 \pm s_2 \in \{1-n, 3-n, \dots, n-1\}\).
</p>

<p>
When \(R_{m,n}=0\), we compute a regularisation of it, i.e. the \(O(\epsilon)\) term in the residue of the conformal block where the channel field&rsquo;s dimension is shifted by \(\epsilon\).
</p>

<p>
This is given by (some expression)
</p>

\begin{align}
&\left(\delta_2-\delta_1\right)_\text{reg} = 2p_2 \\
&\left((\delta_2-\delta_1)^2 -2\delta_{(r,s)}(\delta_1+\delta_2) + \delta_{(r,s)}^2\right)_\text{reg} = 8p_1p_2p_{(r,s)}
\end{align}

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #4271ae;">double_prod_in_Dmn</span>(m, n, B) = prod(prod((r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">-</span> s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #8959a8;">for</span> s in <span style="color: #f5871f; font-weight: bold;">1</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)

<span style="color: #4271ae;">&#948;rs</span>(r, s, B) = <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">4</span> <span style="color: #bb9200;">*</span> (B<span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">*</span>s <span style="color: #bb9200;">+</span> s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B)

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Dmn</span>(m, n, B)
    <span style="color: #8959a8;">if</span> m <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> n <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">treat cases m = 1, n=1 separately</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">1</span>
    <span style="color: #8959a8;">elseif</span> m <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">return</span> n <span style="color: #bb9200;">*</span> prod(s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">*</span> (s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">-</span> m<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
    <span style="color: #8959a8;">elseif</span> n <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">return</span> m <span style="color: #bb9200;">*</span> prod(r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">*</span> (r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">-</span> n<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
    <span style="color: #8959a8;">else</span>
        f1 = prod(r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">*</span> (r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">-</span> n<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
        f2 = prod(s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">*</span> (s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">-</span> m<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
        f3 = double_prod_in_Dmn(m, n, B)
        <span style="color: #8959a8;">return</span> m<span style="color: #bb9200;">*</span>n<span style="color: #bb9200;">*</span>f1<span style="color: #bb9200;">*</span>f2<span style="color: #bb9200;">*</span>f3
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Order of a zero of Rmn, assuming the central charge is generic. Also return the indices of the vanishing term."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Rmn_zero_order</span>(m, n, corr<span style="color: #bb9200;">::FourPointCorrelation</span>)
    B = corr.charge.B
    order = <span style="color: #f5871f; font-weight: bold;">0</span>
    V=corr.fields

    <span style="color: #8959a8;">if</span><span style="color: #bb9200;"> !</span>((V[<span style="color: #f5871f; font-weight: bold;">1</span>].isKac <span style="color: #bb9200;">&amp;&amp;</span> V[<span style="color: #f5871f; font-weight: bold;">2</span>].isKac) <span style="color: #bb9200;">||</span> (V[<span style="color: #f5871f; font-weight: bold;">3</span>].isKac <span style="color: #bb9200;">&amp;&amp;</span> V[<span style="color: #f5871f; font-weight: bold;">4</span>].isKac))
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">end</span>

    r=[V[i].r <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>]
    s=[V[i].s <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>]

    <span style="color: #07c365;">#</span><span style="color: #07c365;">= Rmn is zero if r1 \pm r2 or r3 \pm r4 is an integer in 1-m:2:m-1, and</span>
<span style="color: #07c365;">    s1 \pm s2 or s3 \pm s4 is an integer in 1-n:2:n-1.</span>
<span style="color: #07c365;">    equivalently, if (|r1 \pm r2| &lt;= m-1 and r1-r2 - (m-1) % 2 == 0)</span>
<span style="color: #07c365;">    and (|s1 \pm s2| &lt;= n-1 and s1-s2 - (n-1) % 2 == 0)</span>
<span style="color: #07c365;">    =#</span>
    <span style="color: #8959a8;">for</span> pm <span style="color: #8959a8;">in</span> (<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">1</span>)
        <span style="color: #8959a8;">for</span> (i,j) <span style="color: #8959a8;">in</span> ((<span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">2</span>), (<span style="color: #f5871f; font-weight: bold;">3</span>,<span style="color: #f5871f; font-weight: bold;">4</span>))
            <span style="color: #8959a8;">if</span> V[i].isKac <span style="color: #bb9200;">&amp;&amp;</span> V[j].isKac
                <span style="color: #8959a8;">if</span> (abs(r[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>r[j]) <span style="color: #bb9200;">&lt;=</span> m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> (r[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>r[j]<span style="color: #bb9200;">-</span>(m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>))<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span>) <span style="color: #bb9200;">&amp;&amp;</span>
                    (abs(s[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>s[j]) <span style="color: #bb9200;">&lt;=</span> n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> (s[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>s[j]<span style="color: #bb9200;">-</span>(n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>))<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span>)
                    order <span style="color: #bb9200;">+=</span> <span style="color: #f5871f; font-weight: bold;">1</span>
                <span style="color: #8959a8;">end</span>
            <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>

    <span style="color: #8959a8;">return</span> order
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Compute one of the terms in the double product of Rmn"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Rmn_term</span>(r, s, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, lr)
    B = corr.charge.B
    V = corr.fields
    &#948; = [V[i].&#948;[lr] <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>]
    <span style="color: #8959a8;">if</span> r<span style="color: #bb9200;"> !=</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">||</span> s<span style="color: #bb9200;"> !=</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> (((&#948;[<span style="color: #f5871f; font-weight: bold;">2</span>]<span style="color: #bb9200;">-</span>&#948;[<span style="color: #f5871f; font-weight: bold;">1</span>])<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#948;rs(r, s, B)<span style="color: #bb9200;">*</span>(&#948;[<span style="color: #f5871f; font-weight: bold;">1</span>]<span style="color: #bb9200;">+</span>&#948;[<span style="color: #f5871f; font-weight: bold;">2</span>]) <span style="color: #bb9200;">+</span> &#948;rs(r, s, B)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)
                <span style="color: #bb9200;">*</span>((&#948;[<span style="color: #f5871f; font-weight: bold;">3</span>]<span style="color: #bb9200;">-</span>&#948;[<span style="color: #f5871f; font-weight: bold;">4</span>])<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#948;rs(r, s, B)<span style="color: #bb9200;">*</span>(&#948;[<span style="color: #f5871f; font-weight: bold;">3</span>]<span style="color: #bb9200;">+</span>&#948;[<span style="color: #f5871f; font-weight: bold;">4</span>]) <span style="color: #bb9200;">+</span> &#948;rs(r, s, B)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>))
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">return</span> (&#948;[<span style="color: #f5871f; font-weight: bold;">2</span>]<span style="color: #bb9200;">-</span>&#948;[<span style="color: #f5871f; font-weight: bold;">1</span>])<span style="color: #bb9200;">*</span>(&#948;[<span style="color: #f5871f; font-weight: bold;">3</span>]<span style="color: #bb9200;">-</span>&#948;[<span style="color: #f5871f; font-weight: bold;">4</span>])
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Compute the regularization of a term in the double product of Rmn"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Rmn_term_reg</span>(r, s, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, lr)
    V = corr.fields
    <span style="color: #8959a8;">if</span> r<span style="color: #bb9200;"> !=</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">||</span> s<span style="color: #bb9200;"> !=</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">8</span><span style="color: #bb9200;">*</span>V[<span style="color: #f5871f; font-weight: bold;">1</span>].P[lr]<span style="color: #bb9200;">*</span>V[<span style="color: #f5871f; font-weight: bold;">2</span>].P[lr]<span style="color: #bb9200;">*</span>Field(corr.charge, Kac=<span style="color: #f5871f;">true</span>, r=r, s=s)
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>V[<span style="color: #f5871f; font-weight: bold;">2</span>].P[lr]
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Compute `Rmn`.</span>
<span style="color: #718c00;">lr indicates the left or right moving parts of the fields</span>
<span style="color: #718c00;">Cache the result.</span>
<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> value of regularisation</span>
<span style="color: #718c00;">"""</span>
<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> <span style="color: #8959a8;">function</span> Rmn(m, n, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, lr)

    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, corr) <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">if</span> m <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span>
            res = prod(Rmn_term(<span style="color: #f5871f; font-weight: bold;">0</span>, s, corr, lr) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">0</span>)
        <span style="color: #8959a8;">else</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">m &gt; 1</span>
            res = prod(prod(Rmn_term(r, s, corr, lr)
                            <span style="color: #8959a8;">for</span> s in <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>m:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
            <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">m odd -&gt; treat r=0 term separately</span>
                res <span style="color: #bb9200;">*=</span> prod(Rmn_term(<span style="color: #f5871f; font-weight: bold;">0</span>, s, corr, lr) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">0</span>)
            <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">if</span> m <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span>
            res = <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>

    <span style="color: #8959a8;">return</span> res<span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>Dmn(m, n, corr.charge.B))
<span style="color: #8959a8;">end</span>

<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> <span style="color: #8959a8;">function</span> computeCNmn(N, m, n, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, lr)
    B = corr.charge.B
    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, corr) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">elseif</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&gt;</span> N
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">elseif</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">==</span> N
        <span style="color: #8959a8;">return</span> Rmn(m, n, corr, lr)
    <span style="color: #8959a8;">else</span>
        res = sum(sum(computeCNmn(N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n, mp, np, corr, lr)<span style="color: #bb9200;">/</span>(&#948;rs(m, <span style="color: #bb9200;">-</span>n, B) <span style="color: #bb9200;">-</span> &#948;rs(mp, np, B))
                      <span style="color: #8959a8;">for</span> mp <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n <span style="color: #8959a8;">if</span> mp<span style="color: #bb9200;">*</span>np <span style="color: #bb9200;">&lt;=</span> N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
                  <span style="color: #8959a8;">for</span> np <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
        <span style="color: #8959a8;">return</span> Rmn(m, n, corr, lr) <span style="color: #bb9200;">*</span> res
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org1556327"></a>End module<br />
<div class="outline-text-5" id="text-org1556327">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org40fd3fe" class="outline-3">
<h3 id="org40fd3fe"><span class="section-number-3">3.5.</span> The <code>OnePointCorrelationFunctions</code> module</h3>
<div class="outline-text-3" id="text-3-5">
<p>
The module <code>OnePointCorrelationFunctions</code> defines
</p>

<ul class="org-ul">
<li>a struct <code>OnePointCorrelation</code> that represents a one point function \[
  < V >,
  \]</li>
<li>a method <code>computeCNmn</code> that computes the coefficients \(C^{N,\text{torus}}_{m,n}\) which serve to compute the conformal blocks that enter the expansion of the 1-pt function.</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org511ed9e"></a>Header<br />
<div class="outline-text-5" id="text-org511ed9e">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">module</span> OnePointCorrelationFunctions

<span style="color: #8959a8;">export</span> OnePointCorrelation, computeCNmn

<span style="color: #8959a8;">using</span> ..CFTData
<span style="color: #8959a8;">import</span> ..FourPointCorrelationFunctions: Dmn, &#948;rs <span style="color: #07c365;"># </span><span style="color: #07c365;">re-use the Dmn from four-point functions</span>
</pre>
</div>
</div>
</li>
<li><a id="orgc3c5b57"></a>One-point function type<br />
<div class="outline-text-5" id="text-orgc3c5b57">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">OnePointCorrelation</span>{T}
    charge<span style="color: #bb9200;">::CentralCharge</span>{T}
    field<span style="color: #bb9200;">::Field</span>{T}
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display a one-point function"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, corr<span style="color: #bb9200;">::OnePointCorrelation</span>)
    println(<span style="color: #718c00;">"One-point correlation function: &lt; V &gt; where "</span>)
    print(<span style="color: #718c00;">"V = "</span>); show(corr.field)
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="orgf55e504"></a>Compute \(C^{N,\text{torus}}_{m,n}\)<br />
<div class="outline-text-5" id="text-orgf55e504">
<p>
The computation of the \(C^{N,\text{torus}}_{m,n}\) is very similar to that of the <a href="#orge8ed650">coefficients \(C^{N}_{m,n}\)</a>. We re-use much of the code.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Order of a pole of Rmn^torus, assuming the central charge is generic"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Rmn_zero_order</span>(m, n, corr<span style="color: #bb9200;">::OnePointCorrelation</span>)
    B = corr.charge.B
    V = corr.field
    <span style="color: #8959a8;">if</span> V.isKac <span style="color: #bb9200;">&amp;&amp;</span> V.r<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">==</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> V.s<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">==</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> abs(V.r) <span style="color: #bb9200;">&lt;=</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> abs(V.s) <span style="color: #bb9200;">&lt;=</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">1</span>
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Compute `Rmn^torus`.</span>
<span style="color: #718c00;">lr indicates the left or right moving parts of the fields</span>
<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> value of regularisation</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Rmn</span>(m, n, corr<span style="color: #bb9200;">::OnePointCorrelation</span>, lr)
    B = corr.charge.B
    V = corr.field
    &#948;1 = V.&#948;[lr]
    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, corr) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">else</span>
        res = prod(prod(&#948;rs(r, s, B) <span style="color: #bb9200;">-</span> &#948;1 <span style="color: #8959a8;">for</span> r in <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">2</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">2</span>n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
        <span style="color: #8959a8;">return</span> res<span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>Dmn(m, n, B))
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">computeCNmn</span>(N, m, n, corr<span style="color: #bb9200;">::OnePointCorrelation</span>, lr)
    B = corr.charge.B
    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, corr) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">elseif</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&gt;</span> N
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">elseif</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">==</span> N
        <span style="color: #8959a8;">return</span> Rmn(m, n, corr, lr)
    <span style="color: #8959a8;">else</span>
        res = sum(sum(computeCNmn(N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n, mp, np, corr, lr)<span style="color: #bb9200;">/</span>(&#948;rs(m, <span style="color: #bb9200;">-</span>n, B)<span style="color: #bb9200;">-</span>&#948;rs(mp, np, B))
                      <span style="color: #8959a8;">for</span> mp <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n <span style="color: #8959a8;">if</span> mp<span style="color: #bb9200;">*</span>np <span style="color: #bb9200;">&lt;=</span> N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
                  <span style="color: #8959a8;">for</span> np <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
        <span style="color: #8959a8;">return</span> Rmn(m, n, corr, lr) <span style="color: #bb9200;">*</span> ((N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n<span style="color: #bb9200;">==</span><span style="color: #f5871f; font-weight: bold;">0</span>)<span style="color: #bb9200;">+</span>res)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org0a077e7"></a>End module<br />
<div class="outline-text-5" id="text-org0a077e7">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org919d77c" class="outline-3">
<h3 id="org919d77c"><span class="section-number-3">3.6.</span> The <code>FourPointBlocksSphere</code> module</h3>
<div class="outline-text-3" id="text-3-6">
<p>
The module <code>FourPointBlocksSphere</code> exports
</p>

<ul class="org-ul">
<li>a struct <code>FourPointBlockSphere</code> that encapsulates the data needed to compute a 4pt conformal block, namely a channel, four external fields and the field propagating in the channel</li>
<li>a function <code>block_chiral(x, Nmax, block::FourPointBlockSphere, corr::FourPointCorrelation, lr)</code> which computes the value of the non-chiral block \(\mathcal F_{\Delta}^{(s)}(\Delta_i | x)\) as defined in <a href="#org6144674">this paragraph</a>.</li>
<li>a function <code>block_non_chiral(x, Nmax, block::FourPointBlockSphere, corr::FourPointCorrelation)</code> which computes the value of the non-chiral block \(\mathcal G_{\Delta}^{(s)}(\Delta_i | x)\) as defined in <a href="#org6144674">this paragraph</a>.</li>
</ul>
</div>
<div id="outline-container-org25a3fc6" class="outline-4">
<h4 id="org25a3fc6">Header</h4>
<div class="outline-text-4" id="text-org25a3fc6">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">ConformalBlocks.jl contains modules that compute Virasoro four-point conformal blocks on the</span>
<span style="color: #07c365;">sphere and Virasoro one-point conformal blocks on the torus.</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">===========================================================================================#</span>


<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Computation of four-point blocks on the sphere.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">module</span> FourPointBlocksSphere

<span style="color: #8959a8;">export</span> FourPointBlockSphere, block_chiral, block_non_chiral

<span style="color: #8959a8;">using</span> ..CFTData, ..FourPointCorrelationFunctions
<span style="color: #8959a8;">using</span> Match, EllipticFunctions, Memoization
<span style="color: #8959a8;">import</span> ..FourPointCorrelationFunctions: Rmn
<span style="color: #8959a8;">import</span> ..BootstrapVirasoro.SpecialFunctions: digamma_reg

<span style="color: #07c365;"># </span><span style="color: #07c365;">explicit names for the indices of left and right dimensions</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">left</span> = <span style="color: #f5871f; font-weight: bold;">1</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">right</span> = <span style="color: #f5871f; font-weight: bold;">2</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org87c2eaf" class="outline-4">
<h4 id="org87c2eaf">Four-point block sphere type</h4>
<div class="outline-text-4" id="text-org87c2eaf">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Struct FourPointBlockSphere</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    FourPointBlockSphere{T}</span>

<span style="color: #718c00;">Composite type that represents a four-point conformal block:</span>
<span style="color: #718c00;">a channel and a field propagating in the channel. The external fields and central charge are</span>
<span style="color: #718c00;">provided in a `FourPointCorrelation` object.</span>

<span style="color: #718c00;"># Example</span>

<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; c = CentralCharge(:c,0.5); V = Field(c, :&#948;, 0.6, diagonal = true);</span>
<span style="color: #718c00;">julia&gt; FourPointBlockSphere(:s, V)</span>
<span style="color: #718c00;">Four-point block</span>
<span style="color: #718c00;">Channel:        s</span>
<span style="color: #718c00;">Channel Field:</span>
<span style="color: #718c00;">Diagonal field of dimension:</span>
<span style="color: #718c00;">  &#916; = 0.5791666666666667 + 0.0im</span>
<span style="color: #718c00;">  P = 0.0 + 0.7745966692414834im</span>
<span style="color: #718c00;">  &#948; = 0.6000000000000001 + 0.0im</span>
<span style="color: #718c00;">  p = 0.7745966692414834 + 0.0im</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">FourPointBlockSphere</span>{T}

    corr<span style="color: #bb9200;">::FourPointCorrelation</span>{T}
    channel<span style="color: #bb9200;">::Symbol</span>
    channelfield<span style="color: #bb9200;">::Field</span>{T}
    _seriescoeffs_lr<span style="color: #bb9200;">::Tuple</span>{Dict{Tuple{Int, Int, Int}, T}, Dict{Tuple{Int, Int, Int}, T}}
    _Nmax<span style="color: #bb9200;">::Int</span>

<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Permute the external fields to get t- or u-channels from s-channel."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">permute_ext_fields</span>(corr<span style="color: #bb9200;">::FourPointCorrelation</span>, chan<span style="color: #bb9200;">::Symbol</span>)<span style="color: #bb9200;">::FourPointCorrelation</span>
    Vs=corr.fields
    Vs = <span style="color: #4d4d4c; font-weight: bold;">@match</span> chan <span style="color: #8959a8;">begin</span>
        <span style="color: #f5871f;">:s</span> <span style="color: #bb9200;">=&gt;</span> [Vs[<span style="color: #f5871f; font-weight: bold;">1</span>], Vs[<span style="color: #f5871f; font-weight: bold;">2</span>], Vs[<span style="color: #f5871f; font-weight: bold;">3</span>], Vs[<span style="color: #f5871f; font-weight: bold;">4</span>]]
        <span style="color: #f5871f;">:t</span> <span style="color: #bb9200;">=&gt;</span> [Vs[<span style="color: #f5871f; font-weight: bold;">1</span>], Vs[<span style="color: #f5871f; font-weight: bold;">4</span>], Vs[<span style="color: #f5871f; font-weight: bold;">3</span>], Vs[<span style="color: #f5871f; font-weight: bold;">2</span>]]
        <span style="color: #f5871f;">:u</span> <span style="color: #bb9200;">=&gt;</span> [Vs[<span style="color: #f5871f; font-weight: bold;">1</span>], Vs[<span style="color: #f5871f; font-weight: bold;">3</span>], Vs[<span style="color: #f5871f; font-weight: bold;">2</span>], Vs[<span style="color: #f5871f; font-weight: bold;">4</span>]]
        _ <span style="color: #bb9200;">=&gt;</span> error(<span style="color: #718c00;">"The parameter $chan is not a valid channel"</span>)
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> FourPointCorrelation(corr.charge, Vs)
<span style="color: #8959a8;">end</span>


<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">FourPointBlockSphere</span>(corr<span style="color: #bb9200;">::FourPointCorrelation</span>{T}, s<span style="color: #bb9200;">::Symbol</span>, V<span style="color: #bb9200;">::Field</span>{T}; Nmax=<span style="color: #f5871f; font-weight: bold;">10</span>) <span style="color: #8959a8;">where</span> {T}
    corr_permuted = permute_ext_fields(corr, s)
    coeff_left = Dict{Tuple{Int,Int,Int}, T}( ((N, m, n) <span style="color: #bb9200;">=&gt;</span> computeCNmn(N, m, n, corr_permuted, left))
                       <span style="color: #8959a8;">for</span> n in <span style="color: #f5871f; font-weight: bold;">1</span>:Nmax <span style="color: #8959a8;">for</span> m in <span style="color: #f5871f; font-weight: bold;">1</span>:Nmax <span style="color: #8959a8;">for</span> N <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:Nmax
                           <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&lt;=</span> N)
    coeff_right = Dict{Tuple{Int,Int,Int}, T}( ((N, m, n) <span style="color: #bb9200;">=&gt;</span> computeCNmn(N, m, n, corr_permuted, right))
                        <span style="color: #8959a8;">for</span> n in <span style="color: #f5871f; font-weight: bold;">1</span>:Nmax <span style="color: #8959a8;">for</span> m in <span style="color: #f5871f; font-weight: bold;">1</span>:Nmax <span style="color: #8959a8;">for</span> N <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:Nmax
                            <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&lt;=</span> N)
    <span style="color: #8959a8;">return</span> FourPointBlockSphere(corr_permuted, s, V, (coeff_left, coeff_right), Nmax)
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, block<span style="color: #bb9200;">::FourPointBlockSphere</span>)
    print(<span style="color: #718c00;">"Four-point block, for the "</span>)
    show(block.corr); print(<span style="color: #718c00;">"\n"</span>)
    println(<span style="color: #718c00;">"Channel:\t$(block.channel)"</span>)
    println(<span style="color: #718c00;">"Channel Field:"</span>)
    show(block.channelfield)
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org43def64" class="outline-4">
<h4 id="org43def64">Change of channel</h4>
<div class="outline-text-4" id="text-org43def64">
<p>
The \(t\) and \(u\) channel blocks are computed from the \(s\) channel one, using described above.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Get t- and u- channel blocks from s-channel block</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""Prefactor to get t- or u-channel blocks from the s-channel block"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">channelprefactor_chiral</span>(block<span style="color: #bb9200;">::FourPointBlockSphere</span>, x)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> block.channel <span style="color: #8959a8;">begin</span>
        <span style="color: #f5871f;">:s</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #f5871f;">:t</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #f5871f;">:u</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>x<span style="color: #bb9200;">^</span>(<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>block.corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>].&#916;[left])
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">channelprefactor_non_chiral</span>(block<span style="color: #bb9200;">::FourPointBlockSphere</span>, x)
    <span style="color: #8959a8;">return</span> channelprefactor_chiral(block, x)<span style="color: #bb9200;">*</span>channelprefactor_chiral(block, conj(x))
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Sign (-1)^{S_1+S_2+S_3+S_4} when changing from s to t or u channels"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">channel_sign</span>(block<span style="color: #bb9200;">::FourPointBlockSphere</span>, x)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> block.channel <span style="color: #8959a8;">begin</span>
        <span style="color: #f5871f;">:s</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #f5871f;">:t</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">(-1)^(sum(spin.(corr.fields)))</span>
        <span style="color: #f5871f;">:u</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">(-1)^(sum(spin.(corr.fields)))</span>
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Cross-ratio at which to evaluate the s-channel block to get t- or u-channel block"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">crossratio</span>(channel, x)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> channel <span style="color: #8959a8;">begin</span>
        <span style="color: #f5871f;">:s</span> <span style="color: #bb9200;">=&gt;</span> x
        <span style="color: #f5871f;">:t</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>x
        <span style="color: #f5871f;">:u</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>x
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org66eaed1" class="outline-4">
<h4 id="org66eaed1">Prefactors, elliptic nome</h4>
<div class="outline-text-4" id="text-org66eaed1">
<p>
The nome \(q\) is related to \(x\) via
</p>

\begin{align}
q(x) = \exp(-\pi \frac{K(1-x)}{K(x)})
\end{align}

<p>
where \(K\) is the elliptic \(K\) function. The inverse of this relation is
</p>

\begin{align}
x(q) = \left(\frac{\theta_{4}(q)}{\theta_{3}(q)}\right)^{2}
\end{align}


<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Set prefactors, relate the cross-ratio x and the elliptic nome q</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""Nome `q` from the cross-ratio `x`"""</span>
<span style="color: #4271ae;">qfromx</span>(x) = exp(<span style="color: #bb9200;">-</span>oftype(x, &#960;)<span style="color: #bb9200;">*</span>ellipticK(<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>x)<span style="color: #bb9200;">/</span>ellipticK(x))

<span style="color: #718c00;">"""Cross ratio `x` from the nome `q`"""</span>
<span style="color: #4271ae;">xfromq</span>(q) = jtheta2(<span style="color: #f5871f; font-weight: bold;">0</span>,q)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">4</span> <span style="color: #bb9200;">/</span> jtheta3(<span style="color: #f5871f; font-weight: bold;">0</span>,q)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">4</span>

<span style="color: #718c00;">"""Prefactor for getting the block F from H. The argument `lr` indicates if we are working</span>
<span style="color: #718c00;">with a left or right moving block"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">blockprefactor</span>(block<span style="color: #bb9200;">::FourPointBlockSphere</span>, x, lr)

    corr = block.corr
    c = corr.charge.c
    e0 = <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>].&#948;[lr] <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">2</span>].&#948;[lr] <span style="color: #bb9200;">-</span> (c<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
    e1 = <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>].&#948;[lr] <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">4</span>].&#948;[lr] <span style="color: #bb9200;">-</span> (c<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
    e2 = sum(corr.fields[i].&#948;[lr] <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>) <span style="color: #bb9200;">+</span> (c<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
    q=qfromx(x)

    <span style="color: #8959a8;">return</span> Complex(x)<span style="color: #bb9200;">^</span>e0 <span style="color: #bb9200;">*</span> (Complex(<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>x))<span style="color: #bb9200;">^</span>e1 <span style="color: #bb9200;">*</span> jtheta3(<span style="color: #f5871f; font-weight: bold;">0</span>,q)<span style="color: #bb9200;">^</span>(<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">4</span><span style="color: #bb9200;">*</span>e2) <span style="color: #bb9200;">*</span> (<span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q)<span style="color: #bb9200;">^</span>block.channelfield.&#948;[lr]
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Degenerate dimensions"""</span>
<span style="color: #4271ae;">&#948;rs</span>(r, s, B) = <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">4</span> <span style="color: #bb9200;">*</span> (B<span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">*</span>s <span style="color: #bb9200;">+</span> s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B)
</pre>
</div>
</div>
</div>
<div id="outline-container-org6e78f76" class="outline-4">
<h4 id="org6e78f76">Logarithmic structure constant \(\ell\)</h4>
<div class="outline-text-4" id="text-org6e78f76">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #4271ae;">&#946;m1P</span>(B, r, s) = <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>(r<span style="color: #bb9200;">+</span>s<span style="color: #bb9200;">/</span>B) <span style="color: #07c365;"># </span><span style="color: #07c365;">\beta^{-1}P_{(r,s)}</span>

<span style="color: #718c00;">"""Factor \ell_{(r,s)} that appears in logarithmic blocks"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">ell</span>(corr, r, s)
    c = corr.charge
    B, &#946; = c.B, c.&#946;
    &#946;m1P_ext = [[corr.fields[i].P[left]<span style="color: #bb9200;">/</span>&#946; <span style="color: #8959a8;">for</span> i in <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>], [corr.fields[i].P[right]<span style="color: #bb9200;">/</span>&#946; <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>]]

    <span style="color: #4271ae;">term1</span>(j) = digamma_reg(<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#946;m1P(B, r, j)) <span style="color: #bb9200;">+</span> digamma_reg(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#946;m1P(B, r, <span style="color: #bb9200;">-</span>j))

    res = <span style="color: #bb9200;">-</span>big(<span style="color: #f5871f; font-weight: bold;">4</span>)<span style="color: #bb9200;">*</span>oftype(B, &#960;)<span style="color: #bb9200;">/</span>tan(oftype(B, &#960;)<span style="color: #bb9200;">*</span>s<span style="color: #bb9200;">/</span>B)

    <span style="color: #4271ae;">term3</span>(j, lr, pm1, pm2, a, b) = digamma_reg(<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> (lr <span style="color: #bb9200;">==</span> left <span style="color: #8959a8;">?</span> <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #8959a8;">:</span> <span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">*</span>&#946;m1P(B, r, j) <span style="color: #bb9200;">+</span> pm1<span style="color: #bb9200;">*</span>&#946;m1P_ext[lr][a] <span style="color: #bb9200;">+</span> pm2<span style="color: #bb9200;">*</span>&#946;m1P_ext[lr][b])

    <span style="color: #8959a8;">return</span> res <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">4</span><span style="color: #bb9200;">*</span>sum(term1(j) <span style="color: #8959a8;">for</span> j <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>s:s) <span style="color: #bb9200;">-</span>
        sum(term3(j, lr, pm1, pm2, a, b)
                        <span style="color: #8959a8;">for</span> pm1 <span style="color: #8959a8;">in</span> (<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">1</span>)
                        <span style="color: #8959a8;">for</span> pm2 <span style="color: #8959a8;">in</span> (<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">1</span>)
                        <span style="color: #8959a8;">for</span> j <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>s:<span style="color: #f5871f; font-weight: bold;">2</span>:s<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>
                        <span style="color: #8959a8;">for</span> (a,b) <span style="color: #8959a8;">in</span> ((<span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">2</span>), (<span style="color: #f5871f; font-weight: bold;">3</span>, <span style="color: #f5871f; font-weight: bold;">4</span>))
                        <span style="color: #8959a8;">for</span> lr <span style="color: #8959a8;">in</span> (left, right)
        )
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8716e00" class="outline-4">
<h4 id="org8716e00">Zamolodchikov recursion</h4>
<div class="outline-text-4" id="text-org8716e00">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">H_series_coeffN</span>(block, lr, N;
                         der=<span style="color: #f5871f;">false</span>, reg=<span style="color: #f5871f;">false</span>)

    V = block.channelfield
    P = V.P[lr]
    &#946; = block.corr.charge.&#946;

    res = <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">if</span><span style="color: #bb9200;"> !</span>reg <span style="color: #bb9200;">&amp;&amp; !</span>der
        <span style="color: #8959a8;">for</span> m <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N
            <span style="color: #8959a8;">for</span> n <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N
                <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&lt;=</span> N
                    Pmn = (&#946;<span style="color: #bb9200;">*</span>m<span style="color: #bb9200;">-</span>n<span style="color: #bb9200;">/</span>&#946;)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span>
                    res <span style="color: #bb9200;">+=</span> block._seriescoeffs_lr[lr][(N, m, n)]<span style="color: #bb9200;">/</span>(P<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">-</span>Pmn<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)
                <span style="color: #8959a8;">end</span>
            <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">return</span> res
    <span style="color: #8959a8;">elseif</span><span style="color: #bb9200;"> !</span>reg <span style="color: #bb9200;">&amp;&amp;</span> der
        <span style="color: #8959a8;">for</span> m <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N
            <span style="color: #8959a8;">for</span> n <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N
                <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&lt;=</span> N
                    Pmn = (&#946;<span style="color: #bb9200;">*</span>m<span style="color: #bb9200;">-</span>n<span style="color: #bb9200;">/</span>&#946;)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span>
                    res <span style="color: #bb9200;">-=</span> block._seriescoeffs_lr[lr][(N, m, n)]<span style="color: #bb9200;">/</span>(P<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">-</span>Pmn<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
                <span style="color: #8959a8;">end</span>
            <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>P<span style="color: #bb9200;">*</span>res
    <span style="color: #8959a8;">elseif</span> reg <span style="color: #bb9200;">&amp;&amp;</span> V.isKac <span style="color: #bb9200;">&amp;&amp;</span> V.r<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">==</span> V.s<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">&amp;&amp;</span> V.r <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">&amp;&amp;</span> (lr <span style="color: #bb9200;">==</span> left <span style="color: #bb9200;">&amp;&amp;</span> V.s <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">||</span> lr <span style="color: #bb9200;">==</span> right <span style="color: #bb9200;">&amp;&amp;</span> V.s <span style="color: #bb9200;">&lt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>)
        <span style="color: #8959a8;">for</span> m <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N
            <span style="color: #8959a8;">for</span> n <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N
                <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&lt;=</span> N
                    Pmn = (&#946;<span style="color: #bb9200;">*</span>m<span style="color: #bb9200;">-</span>n<span style="color: #bb9200;">/</span>&#946;)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span>
                    <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;"> !=</span> V.r <span style="color: #bb9200;">||</span> n<span style="color: #bb9200;"> !=</span> abs(V.s)
                        res <span style="color: #bb9200;">+=</span> block._seriescoeffs_lr[lr][(N, m, n)]<span style="color: #bb9200;">/</span>(P<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">-</span>Pmn<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)
                    <span style="color: #8959a8;">else</span>
                        res <span style="color: #bb9200;">-=</span> block._seriescoeffs_lr[lr][(N, m, n)]<span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">4</span><span style="color: #bb9200;">*</span>P<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)
                    <span style="color: #8959a8;">end</span>
                <span style="color: #8959a8;">end</span>
            <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">return</span> res
    <span style="color: #8959a8;">else</span>
        error(<span style="color: #718c00;">"Trying to compute the derivative of a regularised block"</span>)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    H_series(block, lr;</span>
<span style="color: #718c00;">      der = false, reg = false)</span>

<span style="color: #718c00;">Compute the coefficients of the series expansion of the function ``H(q,&#948;)``. If der=true, compute instead the series of the derivative of H with respect to P. If reg=true, compute instead the P dependent part of the coefficients of ``H^{\\text{reg}}``.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> <span style="color: #8959a8;">function</span> H_series(block<span style="color: #bb9200;">::FourPointBlockSphere</span>, lr;
                  der=<span style="color: #f5871f;">false</span>, reg=<span style="color: #f5871f;">false</span>)

    <span style="color: #4d4d4c; font-weight: bold;">@assert</span><span style="color: #bb9200;"> !</span>(der <span style="color: #bb9200;">&amp;&amp;</span> reg) <span style="color: #718c00;">"you should not compute the derivative of a regularised block"</span>

    <span style="color: #8959a8;">if</span><span style="color: #bb9200;"> !</span>der
        <span style="color: #8959a8;">return</span> vcat(<span style="color: #f5871f; font-weight: bold;">1</span>, [H_series_coeffN(block, lr, N, der=der, reg=reg) <span style="color: #8959a8;">for</span> N <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:block._Nmax]) <span style="color: #07c365;"># </span><span style="color: #07c365;">H = 1 + series</span>
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">return</span> [H_series_coeffN(block, lr, N, der=der, reg=reg) <span style="color: #8959a8;">for</span> N <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:block._Nmax]
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org618325d" class="outline-4">
<h4 id="org618325d">Computation of the block</h4>
<div class="outline-text-4" id="text-org618325d">
<p>
We compute \(H^{\text{der}}_{P}\) as
</p>

\begin{align}
H_{P}^{\text{der}} &= 2P\log(16q) H_{P} + H_{P}'
\end{align}

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Compute the conformal block</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    block_chiral(x, Nmax, block, lr)</span>

<span style="color: #718c00;">Compute the chiral conformal block</span>

<span style="color: #718c00;">``\\mathcal F^{(\\text{chan})}_{\\delta}(x)``</span>

<span style="color: #718c00;">where `chan` is `s`, `t`, or `u`."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">block_chiral</span>(x, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, lr;
                      der=<span style="color: #f5871f;">false</span>, reg=<span style="color: #f5871f;">false</span>)
    chan = block.channel
    P = block.channelfield.P[lr]
    x_chan = crossratio(chan, x)

    q = qfromx(x_chan)
    h = evalpoly(<span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q, H_series(block, lr, der=der, reg=reg))
    <span style="color: #8959a8;">if</span> reg
        V = block.channelfield
        <span style="color: #07c365;"># </span><span style="color: #07c365;">h += log(sq)*sum(block._seriescoeffs_lr[lr](N, V.r, abs(V.s))*(sq)^N for N in V.r*abs(V.s):block.Nmax) # log(16q) term in log(16q) - 1/4P^2</span>
        h <span style="color: #bb9200;">+=</span> log(<span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q)<span style="color: #bb9200;">*</span>(<span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q)<span style="color: #bb9200;">^</span>(V.r<span style="color: #bb9200;">*</span>abs(V.s))<span style="color: #bb9200;">*</span>evalpoly(<span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q, [block._seriescoeffs_lr[lr][(N, V.r, abs(V.s))] <span style="color: #8959a8;">for</span> N in V.r<span style="color: #bb9200;">*</span>abs(V.s):block._Nmax]) <span style="color: #07c365;"># </span><span style="color: #07c365;">log(16q) term in log(16q) - 1/4P^2</span>
    <span style="color: #8959a8;">elseif</span> der
        h <span style="color: #bb9200;">+=</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>P<span style="color: #bb9200;">*</span>log(<span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q)<span style="color: #bb9200;">*</span>evalpoly(<span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q, H_series(block, lr, der=<span style="color: #f5871f;">false</span>)) <span style="color: #07c365;"># </span><span style="color: #07c365;">H^der = 2Plog(16q)H + H'</span>
    <span style="color: #8959a8;">end</span>

    <span style="color: #8959a8;">return</span> channelprefactor_chiral(block, x_chan) <span style="color: #bb9200;">*</span> blockprefactor(block, x_chan, lr) <span style="color: #bb9200;">*</span> h
<span style="color: #8959a8;">end</span>

<span style="color: #4271ae;">block_chiral</span>(x, block, lr; der=<span style="color: #f5871f;">false</span>, reg=<span style="color: #f5871f;">false</span>) = block_chiral(x, block, lr; der=der, reg=reg)

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    block_non_chiral(x, Nmax, block)</span>

<span style="color: #718c00;">Compute the non-chiral conformal block G_(r,s) in the s channel.</span>

<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> regularise R_(r,s) / \bar{R}_(r,s)</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">block_non_chiral</span>(x, block<span style="color: #bb9200;">::FourPointBlockSphere</span>)

    x_chan = crossratio(block.channel, x)
    Vchan = block.channelfield

    <span style="color: #8959a8;">if</span><span style="color: #bb9200;"> !</span>Vchan.isKac <span style="color: #bb9200;">||</span> (Vchan.isKac <span style="color: #bb9200;">&amp;&amp;</span> (Vchan.r<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;"> !=</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">||</span> Vchan.s<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;"> !=</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">||</span> spin(Vchan) <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span>)) <span style="color: #07c365;"># </span><span style="color: #07c365;">non-logarithmic block</span>

        <span style="color: #8959a8;">return</span> block_chiral(x_chan, block, left) <span style="color: #bb9200;">*</span> block_chiral(conj(x_chan), block, right)

    <span style="color: #8959a8;">elseif</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">accidentally non-logarithmic block</span>
        <span style="color: #8959a8;">return</span>
    <span style="color: #8959a8;">else</span>
        <span style="color: #07c365;"># </span><span style="color: #07c365;">logarithmic block</span>
        corr = block.corr

        r, s = Vchan.r, Vchan.s

        <span style="color: #4d4d4c; font-weight: bold;">@assert</span><span style="color: #bb9200;"> !</span>(Vchan.r <span style="color: #bb9200;">&lt;</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">||</span> Vchan.s <span style="color: #bb9200;">&lt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>) <span style="color: #718c00;">"Trying to compute a logarithmic block with a negative index: r=$(Vchan.r), s=$(Vchan.s) .</span>
<span style="color: #718c00;">                                               This goes against the chosen convention"</span>
        c = corr.charge
        block1 = block
        block2 = FourPointBlockSphere(corr, <span style="color: #f5871f;">:s</span>, Field(c, Kac=<span style="color: #f5871f;">true</span>, r=r, s=<span style="color: #bb9200;">-</span>s), Nmax=block._Nmax) <span style="color: #07c365;"># </span><span style="color: #07c365;">block with momenta (P_(r,-s), P_(r,s)) in the channel</span>

        F_Prms = block_chiral(x_chan, block2, left) <span style="color: #07c365;"># </span><span style="color: #07c365;">F_{P_(r,-s)}</span>
        F_Prms_bar = block_chiral(conj(x_chan), block1, right) <span style="color: #07c365;"># </span><span style="color: #07c365;">\bar F_{P_(r,-s)}</span>
        F_der_Prms = block_chiral(x_chan, block2, left, der=<span style="color: #f5871f;">true</span>) <span style="color: #07c365;"># </span><span style="color: #07c365;">F'_{P_(r,-s)}</span>
        F_der_Prms_bar = block_chiral(conj(x_chan), block1, right, der=<span style="color: #f5871f;">true</span>) <span style="color: #07c365;"># </span><span style="color: #07c365;">\bar F'_{P_(r,-s)}</span>
        F_reg_Prs = block_chiral(x_chan, block1, left, reg=<span style="color: #f5871f;">true</span>) <span style="color: #07c365;"># </span><span style="color: #07c365;">F^reg_{P_(r,s)}</span>
        F_reg_Prs_bar = block_chiral(conj(x_chan), block2, right, reg=<span style="color: #f5871f;">true</span>) <span style="color: #07c365;"># </span><span style="color: #07c365;">\bar F^reg_{P_(r,s)}</span>

        R = Rmn(r, s, corr, left) <span style="color: #07c365;"># </span><span style="color: #07c365;">Vchan.P[left] = P_(r,s)</span>
        R_bar = Rmn(r, s, corr, right)

        term1 = (F_reg_Prs <span style="color: #bb9200;">-</span> R<span style="color: #bb9200;">*</span>F_der_Prms)<span style="color: #bb9200;">*</span>F_Prms_bar
        term2 = R<span style="color: #bb9200;">/</span>R_bar<span style="color: #bb9200;">*</span>F_Prms<span style="color: #bb9200;">*</span>(F_reg_Prs_bar <span style="color: #bb9200;">-</span> R_bar<span style="color: #bb9200;">*</span>F_der_Prms_bar)
        term3 = <span style="color: #bb9200;">-</span>R<span style="color: #bb9200;">*</span>ell(corr, r, s)<span style="color: #bb9200;">*</span>F_Prms<span style="color: #bb9200;">*</span>F_Prms_bar

        <span style="color: #07c365;"># </span><span style="color: #07c365;">return F_Prms, F_Prms_bar, F_der_Prms, F_der_Prms_bar, F_reg_Prs, F_reg_Prs_bar, ell(corr, r, s), R, R_bar</span>
        <span style="color: #8959a8;">return</span> channel_sign(block, x)<span style="color: #bb9200;">*</span>(term1<span style="color: #bb9200;">+</span>term2<span style="color: #bb9200;">+</span>term3)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    block_non_chiral(x, Nmax, block, corr)</span>

<span style="color: #718c00;">Compute the non-chiral conformal block G_(r,s) in the channel indicated in `block`.</span>

<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> regularise R_(r,s) / \bar{R}_(r,s)</span>
<span style="color: #718c00;">"""</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org1f4b139" class="outline-4">
<h4 id="org1f4b139">End of module</h4>
<div class="outline-text-4" id="text-org1f4b139">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1c71ed5" class="outline-3">
<h3 id="org1c71ed5"><span class="section-number-3">3.7.</span> Setting-up bootstrap equations</h3>
<div class="outline-text-3" id="text-3-7">
</div>
<div id="outline-container-org325a5d7" class="outline-4">
<h4 id="org325a5d7">Multithreading</h4>
<div class="outline-text-4" id="text-org325a5d7">
<p>
Setting-up bootstrap equations requires evaluating conformal blocks at hundreds of positions. We parallelize this computation.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">using</span> Pkg; Pkg.activate(<span style="color: #718c00;">"."</span>)
<span style="color: #8959a8;">using</span> BootstrapVirasoro

help(Field)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">evaluate_block</span>(positions, Nmax, corr, block)
    res = zeros(length(positions))
    threads.<span style="color: #4d4d4c; font-weight: bold;">@Threads</span> <span style="color: #8959a8;">for</span> (i,pos) <span style="color: #8959a8;">in</span> enumerate(positions)
        res[i] = G(corr, block, pos)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org47c7214" class="outline-3">
<h3 id="org47c7214"><span class="section-number-3">3.8.</span> Unit testing</h3>
<div class="outline-text-3" id="text-3-8">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">using</span> BootstrapVirasoro
<span style="color: #8959a8;">using</span> Test
</pre>
</div>
</div>
<div id="outline-container-org099d13c" class="outline-4">
<h4 id="org099d13c">CFTData</h4>
<div class="outline-text-4" id="text-org099d13c">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #4d4d4c; font-weight: bold;">@testset</span> <span style="color: #718c00;">"CFTData.jl"</span> <span style="color: #8959a8;">begin</span>

    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure the relation between b and &#946; does not change</span>
    c1 = CentralCharge(<span style="color: #f5871f;">:c</span>, <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1.1</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">2</span>im)
    b = c1.b
    c2 = CentralCharge(<span style="color: #f5871f;">:b</span>, b)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> c1.c <span style="color: #bb9200;">==</span> c2.c
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> c1.&#946; <span style="color: #bb9200;">==</span> c2.&#946;

    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure the relation between p and P does not change</span>
    left = <span style="color: #f5871f; font-weight: bold;">1</span>
    right = <span style="color: #f5871f; font-weight: bold;">2</span>
    V1 = Field(c1, <span style="color: #f5871f;">:P</span>, <span style="color: #f5871f; font-weight: bold;">0.5</span>, diagonal=<span style="color: #f5871f;">true</span>)
    p = V1.P[left]
    V2 = Field(c1, <span style="color: #f5871f;">:P</span>, p, diagonal=<span style="color: #f5871f;">true</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> V1.P <span style="color: #bb9200;">==</span> V2.P

    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure the keyword diagonal also works for fields given from Kac indices</span>
    V1 = Field(c1, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">3</span>, s=<span style="color: #f5871f; font-weight: bold;">4</span>, diagonal=<span style="color: #f5871f;">true</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> V1.&#948;[left] <span style="color: #bb9200;">==</span> V1.&#948;[right]


    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure degenerate and diagonal work well together</span>
    V1 = Field(c1, Kac=<span style="color: #f5871f;">true</span>, degenerate=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">5</span>, diagonal=<span style="color: #f5871f;">true</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> V1.&#948;[left] <span style="color: #bb9200;">==</span> V1.&#948;[right]

<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgde8d507" class="outline-4">
<h4 id="orgde8d507">Four-point correlation functions</h4>
<div class="outline-text-4" id="text-orgde8d507">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #4d4d4c; font-weight: bold;">@testset</span> <span style="color: #718c00;">"FourPointCorrelationFunctions"</span> <span style="color: #8959a8;">begin</span>

    left=<span style="color: #f5871f; font-weight: bold;">1</span>
    right=<span style="color: #f5871f; font-weight: bold;">2</span>

    c = CentralCharge(<span style="color: #f5871f;">:&#946;</span>, <span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im)
    V1 = Field(c, <span style="color: #f5871f;">:&#916;</span>, big<span style="color: #718c00;">"0.23"</span><span style="color: #bb9200;">+</span>big<span style="color: #718c00;">".11"</span><span style="color: #bb9200;">*</span>im, diagonal=<span style="color: #f5871f;">true</span>)
    V2 = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">3.43</span>, diagonal=<span style="color: #f5871f;">true</span>)
    V3 = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">0.13</span>, diagonal=<span style="color: #f5871f;">true</span>)
    V4 = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">1.3</span>, diagonal=<span style="color: #f5871f;">true</span>)
    corr = FourPointCorrelation(c, V1, V2, V3, V4)

    <span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(BootstrapVirasoro.FourPointCorrelationFunctions.Rmn(<span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">1</span>, corr, left),
                   <span style="color: #f5871f; font-weight: bold;">0.31097697185245077</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">0.70523695127635733</span>im, <span style="color: #07c365;"># </span><span style="color: #07c365;">value taken from Sylvain's code</span>
                   atol=<span style="color: #f5871f; font-weight: bold;">1e-8</span>)

    <span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(BootstrapVirasoro.FourPointCorrelationFunctions.computeCNmn(<span style="color: #f5871f; font-weight: bold;">7</span>, <span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">3</span>, corr, left),
                   <span style="color: #f5871f; font-weight: bold;">0.0019498393368877166</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">0.0026353877950837049</span>im, <span style="color: #07c365;"># </span><span style="color: #07c365;">value taken from Sylvain's code</span>
                   atol=<span style="color: #f5871f; font-weight: bold;">1e-8</span>)

<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orge7d26ce" class="outline-4">
<h4 id="orge7d26ce">Four-point blocks</h4>
<div class="outline-text-4" id="text-orge7d26ce">
</div>
<ul class="org-ul">
<li><a id="orgd00fa71"></a>Boilerplate<br />
<div class="outline-text-5" id="text-orgd00fa71">
<div class="org-src-container">
<pre class="src src-julia">
<span style="color: #4d4d4c; font-weight: bold;">@testset</span> <span style="color: #718c00;">"FourPointBlocks"</span> <span style="color: #8959a8;">begin</span>

    left=<span style="color: #f5871f; font-weight: bold;">1</span>;
    right=<span style="color: #f5871f; font-weight: bold;">2</span>;

    <span style="color: #8959a8;">import</span> BootstrapVirasoro.FourPointBlocksSphere.qfromx

</pre>
</div>
</div>
</li>
<li><a id="org13ad11b"></a>Series \(H\)<br />
<div class="outline-text-5" id="text-org13ad11b">
<div class="org-src-container">
<pre class="src src-julia">c = CentralCharge(<span style="color: #f5871f;">:b</span>, (<span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im)<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>))

q = BootstrapVirasoro.FourPointBlocksSphere.qfromx(<span style="color: #f5871f; font-weight: bold;">0.05</span>)

P = <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im
P1 = <span style="color: #f5871f; font-weight: bold;">0.41</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1.03</span>im

V_chan = Field(c, <span style="color: #f5871f;">:P</span>, sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>)<span style="color: #bb9200;">*</span>P, diagonal=<span style="color: #f5871f;">true</span>)
V_ext = Field(c, <span style="color: #f5871f;">:P</span>, P1<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>), diagonal=<span style="color: #f5871f;">true</span>)
VKac = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>)

corr = FourPointCorrelation(c, [VKac, V_ext, VKac,VKac])
block = FourPointBlockSphere(corr, <span style="color: #f5871f;">:s</span>, V_chan)

h = evalpoly(<span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q, BootstrapVirasoro.FourPointBlocksSphere.H_series(block, left))

<span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(h, <span style="color: #f5871f; font-weight: bold;">0.9999955375834808</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2.735498726466085e-6</span>im, atol=<span style="color: #f5871f; font-weight: bold;">1e-8</span>) <span style="color: #07c365;"># </span><span style="color: #07c365;">value from Sylvain's code</span>
</pre>
</div>
</div>
</li>
<li><a id="org0ec451c"></a>Prefactors, change of channel<br />
<div class="outline-text-5" id="text-org0ec451c">
<div class="org-src-container">
<pre class="src src-julia">setprecision(BigFloat, <span style="color: #f5871f; font-weight: bold;">128</span>)

c = CentralCharge(<span style="color: #f5871f;">:c</span>, big<span style="color: #718c00;">"0.1"</span>)
V1 = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">1</span>, diagonal=<span style="color: #f5871f;">true</span>)
V2 = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>)
V3 = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">3</span>, diagonal=<span style="color: #f5871f;">true</span>)
V4 = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">4</span>, diagonal=<span style="color: #f5871f;">true</span>)
corr = FourPointCorrelation(c, V1, V2, V3, V4)
V = Field(c, <span style="color: #f5871f;">:&#916;</span>, big<span style="color: #718c00;">"0.5"</span>, diagonal=<span style="color: #f5871f;">true</span>)
block_s = FourPointBlockSphere(corr, <span style="color: #f5871f;">:s</span>, V, Nmax=<span style="color: #f5871f; font-weight: bold;">50</span>)
block_t = FourPointBlockSphere(corr, <span style="color: #f5871f;">:t</span>, V, Nmax=<span style="color: #f5871f; font-weight: bold;">50</span>)
block_u = FourPointBlockSphere(corr, <span style="color: #f5871f;">:u</span>, V, Nmax=<span style="color: #f5871f; font-weight: bold;">50</span>)
x=big<span style="color: #718c00;">"0.05"</span>

<span style="color: #07c365;"># </span><span style="color: #07c365;">comparing to values from Sylvain's code</span>
<span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(block_chiral(x, block_s, left), big<span style="color: #718c00;">"1679.9121886897846270816517306779666391454311387606437056866150367"</span>, rtol = <span style="color: #f5871f; font-weight: bold;">1e-20</span>)
<span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(block_chiral(x, block_t, left), big<span style="color: #718c00;">"10841.2576587560092582414458316202779244541207"</span>,rtol = <span style="color: #f5871f; font-weight: bold;">1e-20</span>)
<span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(block_chiral(x, block_u, right), big<span style="color: #718c00;">"299.1846813850886027170806472436222922268361198327"</span> <span style="color: #bb9200;">-</span>big<span style="color: #718c00;">"2026.4731585077561510727121083232012071890514123"</span><span style="color: #bb9200;">*</span>im, rtol = <span style="color: #f5871f; font-weight: bold;">1e-20</span>)
</pre>
</div>
</div>
</li>
<li><a id="org3dbc7d3"></a>Asymptotics<br />
<div class="outline-text-5" id="text-org3dbc7d3">
<div class="org-src-container">
<pre class="src src-julia">setprecision(BigFloat, <span style="color: #f5871f; font-weight: bold;">64</span>)
left = <span style="color: #f5871f; font-weight: bold;">1</span>
right = <span style="color: #f5871f; font-weight: bold;">2</span>

c = CentralCharge(<span style="color: #f5871f;">:&#946;</span>, big<span style="color: #718c00;">".912"</span> <span style="color: #bb9200;">+</span> .<span style="color: #f5871f; font-weight: bold;">1</span>im)
V1 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">0</span>)
V2 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">3</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">3</span>)

corr = FourPointCorrelation(c, [V1, V1, V2, V1])
block_s = FourPointBlockSphere(corr, <span style="color: #f5871f;">:s</span>, V1, Nmax=<span style="color: #f5871f; font-weight: bold;">15</span>)
block_t = FourPointBlockSphere(corr, <span style="color: #f5871f;">:t</span>, V1, Nmax=<span style="color: #f5871f; font-weight: bold;">15</span>)

z = <span style="color: #f5871f; font-weight: bold;">1e-8</span> <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">1e-10</span>im
&#916;1 = V1.&#916;[left]

<span style="color: #4d4d4c; font-weight: bold;">@test</span> abs(<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>block_non_chiral(z, block_s)<span style="color: #bb9200;">*</span>z<span style="color: #bb9200;">^</span>&#916;1<span style="color: #bb9200;">*</span>conj(z)<span style="color: #bb9200;">^</span>&#916;1) <span style="color: #bb9200;">&lt;</span> <span style="color: #f5871f; font-weight: bold;">1e-5</span>
<span style="color: #4d4d4c; font-weight: bold;">@test</span> abs(<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>block_non_chiral(<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>z, block_t)<span style="color: #bb9200;">*</span>z<span style="color: #bb9200;">^</span>&#916;1<span style="color: #bb9200;">*</span>conj(z)<span style="color: #bb9200;">^</span>&#916;1) <span style="color: #bb9200;">&lt;</span> <span style="color: #f5871f; font-weight: bold;">1e-5</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">both blocks are close to one</span>

</pre>
</div>
</div>
</li>
<li><a id="orge93e0f6"></a>Derivative<br />
<div class="outline-text-5" id="text-orge93e0f6">
<div class="org-src-container">
<pre class="src src-julia">setprecision(BigFloat, <span style="color: #f5871f; font-weight: bold;">256</span>)

c = CentralCharge(<span style="color: #f5871f;">:&#946;</span>, big(<span style="color: #f5871f; font-weight: bold;">1.2</span> <span style="color: #bb9200;">+</span> .<span style="color: #f5871f; font-weight: bold;">1</span>im))
V1 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">0</span>)
V2 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">3</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">3</span>)

&#1013; = big(<span style="color: #f5871f; font-weight: bold;">1e-25</span>)
V = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">0.5</span>, diagonal=<span style="color: #f5871f;">true</span>)
Vshiftedp = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">0.5</span><span style="color: #bb9200;">+</span>&#1013;, diagonal=<span style="color: #f5871f;">true</span>)
Vshiftedm = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">0.5</span><span style="color: #bb9200;">-</span>&#1013;, diagonal=<span style="color: #f5871f;">true</span>)

corr = FourPointCorrelation(c, [V1, V1, V2, V1])
block = FourPointBlockSphere(corr, <span style="color: #f5871f;">:s</span>, V, Nmax=<span style="color: #f5871f; font-weight: bold;">50</span>)
block_shiftedp = FourPointBlockSphere(corr, <span style="color: #f5871f;">:s</span>, Vshiftedp, Nmax=<span style="color: #f5871f; font-weight: bold;">50</span>)
block_shiftedm = FourPointBlockSphere(corr, <span style="color: #f5871f;">:s</span>, Vshiftedm, Nmax=<span style="color: #f5871f; font-weight: bold;">50</span>)

block_der = block_chiral(z, block, left, der=<span style="color: #f5871f;">true</span>)
block_der_manual = (block_chiral(z, block_shiftedp, left) <span style="color: #bb9200;">-</span> block_chiral(z, block_shiftedm, left))<span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#1013;)

<span style="color: #4d4d4c; font-weight: bold;">@test</span> abs(block_der <span style="color: #bb9200;">-</span> block_der_manual) <span style="color: #bb9200;">&lt;</span> <span style="color: #f5871f; font-weight: bold;">1e-6</span>
</pre>
</div>
</div>
</li>
<li><a id="org2e09ced"></a>Logarithmic blocks<br />
<div class="outline-text-5" id="text-org2e09ced">
<div class="org-src-container">
<pre class="src src-julia">c = CentralCharge(<span style="color: #f5871f;">:&#946;</span>, big(.<span style="color: #f5871f; font-weight: bold;">8</span> <span style="color: #bb9200;">+</span> .<span style="color: #f5871f; font-weight: bold;">1</span>im))
V1 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>)
V2 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>)
V3 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>)
V4 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">3</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>)
V&#916; = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">0.5</span>, diagonal=<span style="color: #f5871f;">true</span>)

corr = FourPointCorrelation(c, [V1, V2, V3, V4])
corr&#916; = FourPointCorrelation(c, [V1, V2, V3, V&#916;])

ell = BootstrapVirasoro.FourPointBlocksSphere.ell(corr, <span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">1</span>)
ell&#916; = BootstrapVirasoro.FourPointBlocksSphere.ell(corr&#916;, <span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">1</span>)

<span style="color: #07c365;"># </span><span style="color: #07c365;">When all fields are degenerate</span>
<span style="color: #4d4d4c; font-weight: bold;">@test</span>  isapprox(ell, <span style="color: #f5871f; font-weight: bold;">8.2808044631395529307</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">9.7096599503345083802</span>im, rtol = <span style="color: #f5871f; font-weight: bold;">1e-8</span>) <span style="color: #07c365;"># </span><span style="color: #07c365;">comparing with Sylvain's code</span>
<span style="color: #07c365;"># </span><span style="color: #07c365;">When not all fields are degenerate</span>
<span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(ell&#916;, <span style="color: #f5871f; font-weight: bold;">11.392850199938978801</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">7.6477614372039684265</span>im, rtol = <span style="color: #f5871f; font-weight: bold;">1e-8</span>) <span style="color: #07c365;"># </span><span style="color: #07c365;">comparing with Sylvain's code</span>

c = CentralCharge(<span style="color: #f5871f;">:&#946;</span>, big(<span style="color: #f5871f; font-weight: bold;">1.2</span> <span style="color: #bb9200;">+</span> .<span style="color: #f5871f; font-weight: bold;">1</span>im))
V1 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>)
V2 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>)
V3 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>)
V4 = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>)

V = Field(c, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">3</span>)

x = <span style="color: #f5871f; font-weight: bold;">0.3</span> <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">0.1</span>im
Nmax = <span style="color: #f5871f; font-weight: bold;">26</span>
corr = FourPointCorrelation(c, [V1, V2, V3, V4])
<span style="color: #4271ae;">b</span>(channel) = FourPointBlockSphere(corr, channel, V)
<span style="color: #4271ae;">block_value</span>(b) = block_non_chiral(x, b)

<span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(block_value(b(<span style="color: #f5871f;">:s</span>)), <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">0.0062116451268237</span> <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">0.0009314731786393</span>im, rtol = <span style="color: #f5871f; font-weight: bold;">1e-5</span>) <span style="color: #07c365;"># </span><span style="color: #07c365;">comparing with Sylvain's code</span>
<span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(block_value(b(<span style="color: #f5871f;">:t</span>)), <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">0.15830875034149818</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">0.130335270628475</span>im, rtol = <span style="color: #f5871f; font-weight: bold;">1e-5</span>) <span style="color: #07c365;"># </span><span style="color: #07c365;">comparing with Sylvain's code</span>
<span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(block_value(b(<span style="color: #f5871f;">:u</span>)), <span style="color: #f5871f; font-weight: bold;">296.0639291056886</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">16.68222738906</span>im, rtol = <span style="color: #f5871f; font-weight: bold;">1e-3</span>) <span style="color: #07c365;"># </span><span style="color: #07c365;">comparing with Sylvain's code:</span><span style="color: #eab700; font-weight: bold;">TODO</span><span style="color: #07c365;"> precision problem</span>

<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org45844e2" class="outline-4">
<h4 id="org45844e2">One-point blocks</h4>
<div class="outline-text-4" id="text-org45844e2">
</div>
<ul class="org-ul">
<li><a id="org13eb290"></a>Comparing against sphere four-point blocks<br />
<div class="outline-text-5" id="text-org13eb290">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #4d4d4c; font-weight: bold;">@testset</span> <span style="color: #718c00;">"OnePointBlocks"</span> <span style="color: #8959a8;">begin</span>
    left=<span style="color: #f5871f; font-weight: bold;">1</span>;
    right=<span style="color: #f5871f; font-weight: bold;">2</span>;

    <span style="color: #8959a8;">import</span> BootstrapVirasoro.FourPointBlocksSphere.qfromx
    c_torus = CentralCharge(<span style="color: #f5871f;">:b</span>, <span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im);
    c_sphere = CentralCharge(<span style="color: #f5871f;">:b</span>, (<span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im)<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>))

    q = BootstrapVirasoro.FourPointBlocksSphere.qfromx(<span style="color: #f5871f; font-weight: bold;">0.05</span>)

    P = <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im
    P1 = <span style="color: #f5871f; font-weight: bold;">0.41</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1.03</span>im
    V_torus_chan = Field(c_torus, <span style="color: #f5871f;">:P</span>, P, diagonal=<span style="color: #f5871f;">true</span>)
    &#948;_torus = V_torus_chan.&#948;[left]
    &#948;11_torus = Field(c_torus, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>, diagonal=<span style="color: #f5871f;">true</span>).&#948;[left]
    V_torus_ext = Field(c_torus, <span style="color: #f5871f;">:P</span>, P1, diagonal=<span style="color: #f5871f;">true</span>)

    V_sphere_chan = Field(c_sphere, <span style="color: #f5871f;">:P</span>, sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>)<span style="color: #bb9200;">*</span>P, diagonal=<span style="color: #f5871f;">true</span>)
    &#948;_sphere = V_sphere_chan.&#948;[left]
    &#948;21_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>, diagonal=<span style="color: #f5871f;">true</span>).&#948;[left]
    &#948;12_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>).&#948;[left]
    V_sphere_ext = Field(c_sphere, <span style="color: #f5871f;">:P</span>, P1<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>), diagonal=<span style="color: #f5871f;">true</span>)
    VKac_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>)

    corr_torus = OnePointCorrelation(c_torus, V_torus_ext)
    block_torus = OnePointBlockTorus(V_torus_chan)

    corr_sphere = FourPointCorrelation(c_sphere, [VKac_sphere, V_sphere_ext, VKac_sphere,VKac_sphere])
    block_sphere = FourPointBlockSphere(<span style="color: #f5871f;">:s</span>, V_sphere_chan)

    h1 = BootstrapVirasoro.OnePointBlocksTorus.H(q<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">5</span>, block_torus, corr_torus, left)
    h2 = BootstrapVirasoro.FourPointBlocksSphere.H(q, <span style="color: #f5871f; font-weight: bold;">5</span>, block_sphere, corr_sphere, left)

    <span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(h1, h2, atol=<span style="color: #f5871f; font-weight: bold;">1e-12</span>)
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org90f88b6" class="outline-3">
<h3 id="org90f88b6"><span class="section-number-3">3.9.</span> Development tests</h3>
<div class="outline-text-3" id="text-3-9">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">import</span> Pkg; Pkg.activate(<span style="color: #718c00;">"."</span>)
<span style="color: #8959a8;">using</span> BootstrapVirasoro
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">using</span> BootstrapVirasoro, BenchmarkTools, EllipticFunctions

left=<span style="color: #f5871f; font-weight: bold;">1</span>;
right=<span style="color: #f5871f; font-weight: bold;">2</span>;

c = CentralCharge(<span style="color: #f5871f;">:&#946;</span>, big(<span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im));
V1 = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im, diagonal=<span style="color: #f5871f;">true</span>);
V2 = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">3.43</span>, diagonal=<span style="color: #f5871f;">true</span>);
V3 = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">0.13</span>, diagonal=<span style="color: #f5871f;">true</span>);
V4 = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">1.3</span>, diagonal=<span style="color: #f5871f;">true</span>);
V = Field(c, <span style="color: #f5871f;">:&#916;</span>, <span style="color: #f5871f; font-weight: bold;">0.1</span>, diagonal = <span style="color: #f5871f;">true</span>);

x = BigFloat(<span style="color: #718c00;">"0.05"</span>, RoundUp);
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">test</span>()
    corr = FourPointCorrelation(c, V1, V2, V3, V4)
    block = FourPointBlockSphere(<span style="color: #f5871f;">:s</span>, V)
    calc = BootstrapVirasoro.FourPointBlocksSphere.block_chiral_schan(x, <span style="color: #f5871f; font-weight: bold;">20</span>, block, corr, left);
<span style="color: #8959a8;">end</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #4d4d4c; font-weight: bold;">@btime</span> test()
</pre>
</div>

<pre class="example">
  90.034 ms (1095792 allocations: 59.37 MiB)
2337.403811916126625122326580582469276291308611169647345129357174845040805086673 + 4771.391284704253687680894658772605764303477461447331028240571631385564211692817im
</pre>
</div>
<div id="outline-container-orgc0404c0" class="outline-4">
<h4 id="orgc0404c0">Relation between four-point blocks on the sphere and one-point blocks on the torus</h4>
<div class="outline-text-4" id="text-orgc0404c0">
<p>
Four point blocks on the sphere are related to one-point blocks on the torus through the relation
</p>

<p>
\[
\mathcal H^{\text{torus}}_{c, P}(P_{1} | q^{2}) = \mathcal H_{c', \sqrt{2}P'}\left(\left. P'_{(0,\frac12)}, \left(\frac{P_{1}}{\sqrt{2}}\right)', P'_{(0,\frac12)}, P'_{(0,\frac12)} \right| q \right)
\]
</p>

<p>
where
</p>
<ul class="org-ul">
<li>\(c'\) is related to \(c\) via \(\beta'=\frac\beta{\sqrt 2}\).</li>
<li>\(P'\) denotes the Virasoro module with primary field of dimension \(\Delta'(P') = \frac{c'-1}{24} - P'^{2}\)</li>
</ul>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">import</span> Pkg; Pkg.activate(<span style="color: #718c00;">"."</span>)
<span style="color: #8959a8;">using</span> BootstrapVirasoro, BenchmarkTools, EllipticFunctions

left=<span style="color: #f5871f; font-weight: bold;">1</span>;
right=<span style="color: #f5871f; font-weight: bold;">2</span>;

<span style="color: #8959a8;">import</span> BootstrapVirasoro.FourPointBlocksSphere.qfromx
c_torus = CentralCharge(<span style="color: #f5871f;">:b</span>, <span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im);
c_sphere = CentralCharge(<span style="color: #f5871f;">:b</span>, (<span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im)<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>))

q = BootstrapVirasoro.FourPointBlocksSphere.qfromx(<span style="color: #f5871f; font-weight: bold;">0.05</span>)

P = <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im
P1 = <span style="color: #f5871f; font-weight: bold;">0.41</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1.03</span>im
V_torus_chan = Field(c_torus, <span style="color: #f5871f;">:P</span>, P, diagonal=<span style="color: #f5871f;">true</span>)
&#948;_torus = V_torus_chan.&#948;[left]
&#948;11_torus = Field(c_torus, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>, diagonal=<span style="color: #f5871f;">true</span>).&#948;[left]
V_torus_ext = Field(c_torus, <span style="color: #f5871f;">:P</span>, P1, diagonal=<span style="color: #f5871f;">true</span>)

V_sphere_chan = Field(c_sphere, <span style="color: #f5871f;">:P</span>, sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>)<span style="color: #bb9200;">*</span>P, diagonal=<span style="color: #f5871f;">true</span>)
&#948;_sphere = V_sphere_chan.&#948;[left]
&#948;21_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span>, diagonal=<span style="color: #f5871f;">true</span>).&#948;[left]
&#948;12_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">1</span>, s=<span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>).&#948;[left]
V_sphere_ext = Field(c_sphere, <span style="color: #f5871f;">:P</span>, P1<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>), diagonal=<span style="color: #f5871f;">true</span>)
VKac_sphere = Field(c_sphere, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">//</span><span style="color: #f5871f; font-weight: bold;">2</span>, diagonal=<span style="color: #f5871f;">true</span>)

corr_torus = OnePointCorrelation(c_torus, V_torus_ext)
block_torus = OnePointBlockTorus(V_torus_chan)

corr_sphere = FourPointCorrelation(c_sphere, [VKac_sphere, V_sphere_ext, VKac_sphere,VKac_sphere])
block_sphere = FourPointBlockSphere(<span style="color: #f5871f;">:s</span>, V_sphere_chan)

h1 = BootstrapVirasoro.OnePointBlocksTorus.H(q<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">5</span>, block_torus, corr_torus, left)
h2 = BootstrapVirasoro.FourPointBlocksSphere.H(q, <span style="color: #f5871f; font-weight: bold;">5</span>, block_sphere, corr_sphere, left)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia">println(<span style="color: #718c00;">"torus block = $h1 \nsphere block = $h2"</span>)
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Paul ROUX</p>
<p class="date">Created: 2024-06-19 Wed 13:57</p>
</div>
</body>
</html>
