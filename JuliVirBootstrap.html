<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-01 Fri 10:31 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JuliVirBootstrap Documentation</title>
<meta name="author" content="Paul ROUX" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">JuliVirBootstrap Documentation</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org80e9dfb">1. Main module</a></li>
<li><a href="#org8342cd9">2. CFT data: central charges and fields</a>
<ul>
<li><a href="#orgd487a07">Parametrisations</a>
<ul>
<li><a href="#org94d465f">Central charge</a></li>
<li><a href="#org5a2ac35">Fields</a></li>
</ul>
</li>
<li><a href="#orgd264e14">The <code>CFTData</code> module</a>
<ul>
<li><a href="#org253c6a5">Header</a></li>
<li><a href="#orgb505ef3">Central charge</a></li>
<li><a href="#orgd362125">Fields</a></li>
<li><a href="#orge777063">End of module</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6cb541b">3. Correlation Functions</a>
<ul>
<li><a href="#org3a17569">Four-point correlation functions on the sphere</a>
<ul>
<li><a href="#orgace1a5e">Four point functions in CFT</a></li>
<li><a href="#orgb1a73cd">Coefficients \(C^{N}_{m,n}\)</a></li>
<li><a href="#org48d60fd">The <code>FourPointCorrelationFunctions</code> module</a></li>
</ul>
</li>
<li><a href="#orgd74702b">One-point correlation functions on the torus</a>
<ul>
<li><a href="#org207aed6">One point functions in CFT</a></li>
<li><a href="#org9030346">Coefficients \(C^{N,\text{torus}}_{m,n}\)</a></li>
<li><a href="#org650eada">The <code>OnePointCorrelationFunctions</code> module</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6a01abe">4. Virasoro conformal blocks</a>
<ul>
<li><a href="#orgec4c276">Four-point conformal blocks on the sphere</a>
<ul>
<li><a href="#orgd501ab4">Four-point conformal blocks</a></li>
<li><a href="#org15d6d50">The <code>FourPointBlocksSphere</code> module</a></li>
</ul>
</li>
<li><a href="#one-point-conformal-blocks-on-the-torus">One-point conformal blocks on the torus</a>
<ul>
<li><a href="#one-point-blocks-on-the-torus">One point blocks on the torus</a></li>
<li><a href="#org8ad3b79">The <code>OnePointBlocksTorus</code> module</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge53bab8">5. Special functions</a></li>
<li><a href="#org59cc416">6. Unit testing</a></li>
<li><a href="#org5525354">7. Development tests</a>
<ul>
<li><a href="#orgb9ac7c1">Relation between four-point blocks on the sphere and one-point blocks on the torus</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org80e9dfb" class="outline-2">
<h2 id="org80e9dfb"><span class="section-number-2">1.</span> Main module</h2>
<div class="outline-text-2" id="text-1">
<p>
The module <code>JuliVirBootstrap</code> is the main module of this package, and it includes the sub-modules.
</p>

<ul class="org-ul">
<li><code>CFTData</code> provides types for central charges and fields.</li>
<li><code>CorrelationFunctions</code> provides types for one-point and four-point correlation functions, as well as methods for computing coefficients appearing in their conformal blocks.</li>
<li><code>VirasoroConformalBlocks</code> provides types for representing four-point conformal blocks on the sphere and one-point conformal blocks on the torus, as well as methods for computing them.</li>
</ul>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">===========================================================================================#</span>

<span style="color: #8959a8;">module</span> JuliVirBootstrap

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Central charges and fields</span>
<span style="color: #07c365;">===========================================================================================#</span>
include(<span style="color: #718c00;">"CFTData.jl"</span>)
<span style="color: #8959a8;">using</span> .CFTData
<span style="color: #8959a8;">export</span> CentralCharge, Field

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Correlation functions</span>
<span style="color: #07c365;">===========================================================================================#</span>
include(<span style="color: #718c00;">"CorrelationFunctions.jl"</span>)
<span style="color: #8959a8;">using</span> .FourPointCorrelationFunctions
<span style="color: #8959a8;">export</span> FourPointCorrelation

<span style="color: #8959a8;">using</span> .OnePointCorrelationFunctions
<span style="color: #8959a8;">export</span> OnePointCorrelation

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Conformal blocks</span>
<span style="color: #07c365;">===========================================================================================#</span>
include(<span style="color: #718c00;">"ConformalBlocks.jl"</span>)
<span style="color: #8959a8;">using</span> .FourPointBlocksSphere
<span style="color: #8959a8;">export</span> FourPointBlockSphere, F_four_point_sphere

<span style="color: #8959a8;">using</span> .OnePointBlocksTorus
<span style="color: #8959a8;">export</span> OnePointBlocksTorus, F_one_point_torus


<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Special functions</span>
<span style="color: #07c365;">===========================================================================================#</span>
include(<span style="color: #718c00;">"SpecialFunctions.jl"</span>)
<span style="color: #8959a8;">export</span> log_double_gamma, double_gamma


<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8342cd9" class="outline-2">
<h2 id="org8342cd9"><span class="section-number-2">2.</span> CFT data: central charges and fields</h2>
<div class="outline-text-2" id="text-2">
<p>
The file <a href="src/CFTData.jl">CFTData.jl</a> defines
</p>

<ul class="org-ul">
<li>a struct <code>CentralCharge</code> that represents a central charge \(c\) and contains the value of the four corresponding parameters \(b, B, \beta, c\)</li>
<li>a struct <code>Field</code> that represents a field \(V\). The field can be defined from its Kac indices \(r, s\), be diagonal, logarithmic, or degenerate. The struct contains booleans for these three characteristics, as well as rationals for \(r\) and \(s\), and the pairs of (left, right) values \((\Delta, \bar \Delta)\), \((p, \bar p)\), \((\delta, \bar \delta)\), \((P, \bar P)\).</li>
</ul>
</div>
<div id="outline-container-orgd487a07" class="outline-3">
<h3 id="orgd487a07">Parametrisations</h3>
<div class="outline-text-3" id="text-orgd487a07">
</div>
<div id="outline-container-org94d465f" class="outline-4">
<h4 id="org94d465f">Central charge</h4>
<div class="outline-text-4" id="text-org94d465f">
<p>
The central charge \(c\) can be parametrized by variables \(B\), \(b\) or \(\beta\) such that
</p>

<p>
\[
c = 13 + 6B + 6 B^{-1} \quad , \quad B = b^2 = -\beta^2
\]
</p>

<p>
Conversely, we have
</p>

<p>
\[
B = \frac{c-13 \pm \sqrt{(c-1)(c-25)}}{12}
\]
</p>

<p>
The central charge can be given directly or as a function of b,β,B. No matter what parameter is passed we compute B from it, then b,β,c. We ensure that the relation between b and &beta; never changes (square root branch).
</p>
</div>
</div>
<div id="outline-container-org5a2ac35" class="outline-4">
<h4 id="org5a2ac35">Fields</h4>
<div class="outline-text-4" id="text-org5a2ac35">
<p>
Fields in 2D CFTs are elements of representations of the Virasoro algebra.
Non-logarithmic fields are elements of representations where the generators \(L_0\) and \(\bar L_0\) of the Virasoro algebra act diagonally, with eigenvalues called conformal weights or dimensions and respectively denoted \((\Delta,\bar \Delta)\). Logarithmic fields are elements of representations where \(L_0\) and \(\bar L_0\) act as triangular matrices; see <a href="https://arxiv.org/abs/2007.04190">this paper</a>.
We parametrise the dimensions in terms of \(P,p,\Delta,\delta\), related by
</p>

<p>
\[
\Delta = \frac{c-1}{24} + \delta  \quad , \quad \delta = -P^2 = p^2
\]
</p>

<p>
The Kac parametrisation for conformal weights is
\[ P_{(r,s)}=\frac{1}{2}(b r + b^{-1}s)\]
</p>

<p>
where \(r,s\) are arbitrary numbers. We say the field is degenerate if \(r,s\in \mathbb Z\) and \(rs>0\). In terms of \(r,s\), the dimension \(\Delta\) is written
</p>

<p>
\[
\Delta_{(r,s)} = \frac14 B (1-r^2) + \frac12 (1-rs) + \frac14\frac{1-s^2}{B}
\]
</p>

<p>
This convention is consistent with the one in <a href="https://gitlab.com/s.g.ribault/Bootstrap_Virasoro.git">this code</a> but differs from the one in <a href="https://arxiv.org/abs/2208.14298">this paper</a>.
In our models, non-diagonal fields are written \(V_{(r,s)}\) and are parametrised by Kac indices \(r\),\(s\), with left and right conformal dimension \((P_{(r,s)},P_{(r,-s)})\).
</p>
</div>
</div>
</div>
<div id="outline-container-orgd264e14" class="outline-3">
<h3 id="orgd264e14">The <code>CFTData</code> module</h3>
<div class="outline-text-3" id="text-orgd264e14">
</div>
<div id="outline-container-org253c6a5" class="outline-4">
<h4 id="org253c6a5">Header</h4>
<div class="outline-text-4" id="text-org253c6a5">
<div class="org-src-container">
<pre class="src src-julia">
<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">CFTData.jl contains a module CFTData that provides types representing</span>
<span style="color: #07c365;">central charges and fields in 2D CFTs with Virasoro symmetry.</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">============================================================================================#</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Provides types representing central charges and fields in CFT.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">module</span> CFTData

<span style="color: #8959a8;">using</span> Match;

<span style="color: #8959a8;">export</span> CentralCharge, Field

<span style="color: #718c00;">"""print complex numbers in latex format"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>,<span style="color: #bb9200;">::MIME</span><span style="color: #718c00;">"text/latex"</span>,z<span style="color: #bb9200;">::Complex</span>)
    print(<span style="color: #718c00;">"$(real(z)) + $(imag(z))i"</span>)
<span style="color: #8959a8;">end</span>

</pre>
</div>
</div>
</div>
<div id="outline-container-orgb505ef3" class="outline-4">
<h4 id="orgb505ef3">Central charge</h4>
<div class="outline-text-4" id="text-orgb505ef3">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Get B from given parameter"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Bfrom</span>(parameter, value)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> parameter <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"c"</span> <span style="color: #bb9200;">=&gt;</span> (value<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">13</span><span style="color: #bb9200;">+</span>sqrt(complex((value<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">*</span>(value<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">25</span>))))<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">12</span>
        <span style="color: #718c00;">"b"</span> <span style="color: #bb9200;">=&gt;</span> value<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
        <span style="color: #718c00;">"&#946;"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #bb9200;">-</span>value<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
        <span style="color: #718c00;">"B"</span> <span style="color: #bb9200;">=&gt;</span> value
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Get asked parameter from B"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Bto</span>(parameter, value)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> parameter <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"c"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">13</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">6</span><span style="color: #bb9200;">*</span>value<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">6</span><span style="color: #bb9200;">/</span>value
        <span style="color: #718c00;">"b"</span> <span style="color: #bb9200;">=&gt;</span> sqrt(complex(value))
        <span style="color: #718c00;">"&#946;"</span> <span style="color: #bb9200;">=&gt;</span> im<span style="color: #bb9200;">*</span>sqrt(complex(value))
        <span style="color: #718c00;">"B"</span> <span style="color: #bb9200;">=&gt;</span> value
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    CentralCharge{T}</span>
<span style="color: #718c00;">Object representing the central charge.</span>
<span style="color: #718c00;">Contains the values of the 4 parameters representing it.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">CentralCharge</span>{T}

    <span style="color: #07c365;">#</span><span style="color: #07c365;">= T is the type of the parameters; either Complex{Float64} or Complex{BigFloat}</span>
<span style="color: #07c365;">    for arbitrary precision. =#</span>
    values<span style="color: #bb9200;">::Dict</span>{String, T}

<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    CentralCharge(parameter, value)</span>

<span style="color: #718c00;">Constructor function for the CentralCharge type.</span>

<span style="color: #718c00;">Given one of the four parameters `"c"`, `"b"`, `"&#946;"`, `"B"` and its value,</span>
<span style="color: #718c00;">creates an object CentralCharge{T} where T is the type of `value`.</span>

<span style="color: #718c00;"># Example</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; setprecision(BigFloat, 20, base=10)</span>
<span style="color: #718c00;">julia&gt; charge = CentralCharge("&#946;", sqrt(big(2)))</span>
<span style="color: #718c00;">Central charge :</span>
<span style="color: #718c00;">B = -2.0 + 0.0im</span>
<span style="color: #718c00;">c = -2.0 + 0.0im</span>
<span style="color: #718c00;">b = 0.0 + 1.414213562373095048804im</span>
<span style="color: #718c00;">&#946; = -1.414213562373095048804 + 0.0im</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">CentralCharge</span>(parameter = <span style="color: #718c00;">"c"</span>, value = <span style="color: #f5871f; font-weight: bold;">1</span>)
    <span style="color: #07c365;"># </span><span style="color: #07c365;">Constructor</span>
    T=typeof(AbstractFloat(real(value)))
    B=Bfrom(parameter, value)
    dict=Dict(key <span style="color: #bb9200;">=&gt;</span> Bto(key, B) <span style="color: #8959a8;">for</span> key <span style="color: #8959a8;">in</span> (<span style="color: #718c00;">"c"</span>, <span style="color: #718c00;">"b"</span>, <span style="color: #718c00;">"&#946;"</span>, <span style="color: #718c00;">"B"</span>))
    CentralCharge{complex(T)}(dict)
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org77c3037"></a>Pretty printing<br />
<div class="outline-text-5" id="text-org77c3037">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Display an object of type CentralCharge"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, charge<span style="color: #bb9200;">::CentralCharge</span>)
    println(<span style="color: #718c00;">"Central charge:"</span>)
    <span style="color: #8959a8;">for</span> (key, value) <span style="color: #8959a8;">in</span> charge.values
        println(io, <span style="color: #718c00;">"$key = $value"</span>)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display the value of the central charge in LaTeX format"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, <span style="color: #bb9200;">::MIME</span><span style="color: #718c00;">"text/latex"</span>, charge<span style="color: #bb9200;">::CentralCharge</span>, parameter)
    <span style="color: #8959a8;">if</span> parameter<span style="color: #bb9200;">==</span><span style="color: #718c00;">"&#946;"</span>
        print(<span style="color: #718c00;">"\\beta = "</span>)
    <span style="color: #8959a8;">else</span>
        print(parameter,<span style="color: #718c00;">" = "</span>)
    <span style="color: #8959a8;">end</span>
    show(io, MIME(<span style="color: #718c00;">"text/latex"</span>), charge[parameter])
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Overload of [] to access values in charge"""</span>
Base.<span style="color: #4271ae;">getindex</span>(charge<span style="color: #bb9200;">::CentralCharge</span>, key) = charge.values[key];
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgd362125" class="outline-4">
<h4 id="orgd362125">Fields</h4>
<div class="outline-text-4" id="text-orgd362125">
<p>
Fields can be given from any of the four parameters \(\Delta, \delta, P, p\). Optional keyword arguments lets us choose whether the field is diagonal, degenerate, logarithmic. The field can also be defined from its r and s indices using the keyword argument Kac = true.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Get p from any given parameter"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">p_from</span>(parameter, value, charge<span style="color: #bb9200;">::CentralCharge</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> parameter <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"&#916;"</span> <span style="color: #bb9200;">=&gt;</span> sqrt(complex(value <span style="color: #bb9200;">-</span> (charge[<span style="color: #718c00;">"c"</span>]<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>))
        <span style="color: #718c00;">"&#948;"</span> <span style="color: #bb9200;">=&gt;</span> sqrt(complex(value))
        <span style="color: #718c00;">"P"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #bb9200;">-</span>im<span style="color: #bb9200;">*</span>value
        <span style="color: #718c00;">"p"</span> <span style="color: #bb9200;">=&gt;</span> value
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Get all parameters from p"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">p_to</span>(parameter, value, charge<span style="color: #bb9200;">::CentralCharge</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> parameter <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"&#916;"</span> <span style="color: #bb9200;">=&gt;</span> value<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> (charge[<span style="color: #718c00;">"c"</span>]<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
        <span style="color: #718c00;">"&#948;"</span> <span style="color: #bb9200;">=&gt;</span> value<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
        <span style="color: #718c00;">"P"</span> <span style="color: #bb9200;">=&gt;</span> im<span style="color: #bb9200;">*</span>value
        <span style="color: #718c00;">"p"</span> <span style="color: #bb9200;">=&gt;</span> value
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    Field{T}</span>
<span style="color: #718c00;">Object representing a conformal field.</span>
<span style="color: #718c00;">Contains the values of the 4 parameters `"&#916;"`,`"&#948;"`,`"P"`,`"p"` for its conformal dimension,</span>
<span style="color: #718c00;">and flags saying whether the field is in the Kac table, degenerate, logarithmic or diagonal.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">Field</span>{T}

    values<span style="color: #bb9200;">::Dict</span>{String, Vector{T}}
    isKac<span style="color: #bb9200;">::Bool</span>
    r<span style="color: #bb9200;">::Rational</span>
    s<span style="color: #bb9200;">::Rational</span>
    isdegenerate<span style="color: #bb9200;">::Bool</span>
    islogarithmic<span style="color: #bb9200;">::Bool</span>
    isdiagonal<span style="color: #bb9200;">::Bool</span>

<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    Field(charge, parameter, leftvalue, rightvalue; kwargs...)</span>

<span style="color: #718c00;">Constructor function for the Field type.</span>

<span style="color: #718c00;">Given a charge `charge`, one of the four parameters `"&#916;"`, `"&#948;"`, `"P"`, `"p"` and two values,</span>
<span style="color: #718c00;">create an object Field{T} (where T is the type of the values in `charge`) that represents a</span>
<span style="color: #718c00;">field of left and right dimensions given by leftvalue and rightvalue in the chosen</span>
<span style="color: #718c00;">parametrisation.</span>

<span style="color: #718c00;"># keyword arguments:</span>

<span style="color: #718c00;">- `Kac::Bool`: if set to true, the field can be constructed from the values of its r and s</span>
<span style="color: #718c00;">indices,</span>
<span style="color: #718c00;">- `r::Rational`,`s::Rational`: used in conjunction to `Kac=true`, must be given rational</span>
<span style="color: #718c00;">values,</span>
<span style="color: #718c00;">- `logarithmic::Bool`: set to True if the field is logarithmic,</span>
<span style="color: #718c00;">- `degenerate::Bool`: set to True if the field is degenerate,</span>
<span style="color: #718c00;">- `diagonal::Bool`: set to True to get a diagonal field ; only the leftvalue needs to be</span>
<span style="color: #718c00;">given.</span>

<span style="color: #718c00;"># Examples</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; charge = CentralCharge("b", big(0.5));</span>
<span style="color: #718c00;">julia&gt; field = Field(charge, Kac=true, r=0, s=1)</span>
<span style="color: #718c00;">Non-diagonal field with Kac indices r = 0//1, s = 1//1 and (left,right) dimensions:</span>
<span style="color: #718c00;">&#916; = ( 2.5625 + 0.0im, 2.5625 + 0.0im )</span>
<span style="color: #718c00;">P = ( -0.0 - 1.0im, 0.0 + 1.0im )</span>
<span style="color: #718c00;">&#948; = ( 1.0 - 0.0im, 1.0 + 0.0im )</span>
<span style="color: #718c00;">p = ( -1.0 + 0.0im, 1.0 + 0.0im )</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; charge = CentralCharge("&#946;", 1.5+im);</span>
<span style="color: #718c00;">julia&gt; Field(charge, "&#948;", 2, 3)</span>
<span style="color: #718c00;">Non-diagonal field with (left, right) dimensions:</span>
<span style="color: #718c00;">&#916; = ( 2.1579142011834325 - 0.6789940828402367im, 3.1579142011834316 - 0.6789940828402367im )</span>
<span style="color: #718c00;">P = ( 0.0 + 1.4142135623730951im, 0.0 + 1.7320508075688772im )</span>
<span style="color: #718c00;">&#948; = ( 2.0000000000000004 + 0.0im, 2.9999999999999996 + 0.0im )</span>
<span style="color: #718c00;">p = ( 1.4142135623730951 + 0.0im, 1.7320508075688772 + 0.0im )</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; charge = CentralCharge();</span>
<span style="color: #718c00;">julia&gt; Field(charge, "&#948;", 1, diagonal=true)</span>
<span style="color: #718c00;">Diagonal field of dimension:</span>
<span style="color: #718c00;">&#916; = 1.0 + 0.0im</span>
<span style="color: #718c00;">P = 0.0 + 1.0im</span>
<span style="color: #718c00;">&#948; = 1.0 + 0.0im</span>
<span style="color: #718c00;">p = 1.0 + 0.0im</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Field</span>(
    charge<span style="color: #bb9200;">::CentralCharge</span> = CentralCharge(<span style="color: #718c00;">"c"</span>, <span style="color: #f5871f; font-weight: bold;">1</span>),
    parameter = <span style="color: #718c00;">"&#916;"</span>,
    leftvalue = <span style="color: #f5871f; font-weight: bold;">0</span>, rightvalue = <span style="color: #f5871f; font-weight: bold;">0</span>;
    Kac = <span style="color: #f5871f;">false</span>, r = <span style="color: #f5871f; font-weight: bold;">0</span>, s = <span style="color: #f5871f; font-weight: bold;">0</span>,
    logarithmic = <span style="color: #f5871f;">false</span>, degenerate = <span style="color: #f5871f;">false</span>, diagonal = <span style="color: #f5871f;">false</span>
    )

    T=typeof(charge.values[<span style="color: #718c00;">"c"</span>])   <span style="color: #07c365;">#</span><span style="color: #07c365;">dimensions have the same type as central charges</span>
    <span style="color: #8959a8;">if</span> degenerate
        Kac = <span style="color: #f5871f;">true</span>
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">if</span> Kac
        pleft = <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>(charge[<span style="color: #718c00;">"b"</span>]<span style="color: #bb9200;">*</span>r <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>charge[<span style="color: #718c00;">"b"</span>]<span style="color: #bb9200;">*</span>s)
        pright = <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>(charge[<span style="color: #718c00;">"b"</span>]<span style="color: #bb9200;">*</span>r <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>charge[<span style="color: #718c00;">"b"</span>]<span style="color: #bb9200;">*</span>s)
    <span style="color: #8959a8;">else</span>
        pleft, pright = p_from.(parameter, [leftvalue, rightvalue], Ref(charge))
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">if</span> diagonal
        pright = pleft
    <span style="color: #8959a8;">end</span>
    values = Dict(key <span style="color: #bb9200;">=&gt;</span> p_to.(key, [pleft, pright], Ref(charge))
                  <span style="color: #8959a8;">for</span> key <span style="color: #8959a8;">in</span> (<span style="color: #718c00;">"&#916;"</span>, <span style="color: #718c00;">"&#948;"</span>, <span style="color: #718c00;">"P"</span>, <span style="color: #718c00;">"p"</span>)
                      )
    Field{complex(T)}(values, Kac, r, s, degenerate, logarithmic, diagonal)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Compute the spin &#916;left - &#916;right of a field."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">spin</span>(field<span style="color: #bb9200;">::Field</span>)
    <span style="color: #07c365;">#</span><span style="color: #07c365;">Computes the spin &#916;-&#916;bar</span>
    <span style="color: #8959a8;">if</span> field.isdiagonal
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">return</span> field[<span style="color: #718c00;">"&#916;"</span>][<span style="color: #f5871f; font-weight: bold;">1</span>] <span style="color: #bb9200;">-</span> field[<span style="color: #718c00;">"&#916;"</span>][<span style="color: #f5871f; font-weight: bold;">2</span>]
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org46aea88"></a>Pretty printing<br />
<div class="outline-text-5" id="text-org46aea88">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Display field"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>,field<span style="color: #bb9200;">::Field</span>)
    <span style="color: #07c365;">#</span><span style="color: #07c365;">Print fields</span>
    <span style="color: #8959a8;">if</span> field.isdiagonal
        println(<span style="color: #718c00;">"Diagonal field of dimension:"</span>)
        <span style="color: #8959a8;">for</span> (key, value) <span style="color: #8959a8;">in</span> field.values
            println(io, <span style="color: #718c00;">"  $key = $(value[1])"</span>)
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">else</span>
        print(<span style="color: #718c00;">"Non-diagonal field "</span>)
        <span style="color: #8959a8;">if</span> field.isKac
            print(<span style="color: #718c00;">"with Kac indices r = $(field.r), s = $(field.s) and "</span>)
        <span style="color: #8959a8;">else</span>
            print(<span style="color: #718c00;">"with "</span>)
        <span style="color: #8959a8;">end</span>
        println(<span style="color: #718c00;">"(left, right) dimensions:"</span>)
        <span style="color: #8959a8;">for</span> (key, value) <span style="color: #8959a8;">in</span> field.values
            println(io, <span style="color: #718c00;">"  $key = ($(value[1]), $(value[2]))"</span>)
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display dimension of field in latex format"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>,<span style="color: #bb9200;">::MIME</span><span style="color: #718c00;">"text/latex"</span>, field<span style="color: #bb9200;">::Field</span>,parameter)
    <span style="color: #8959a8;">if</span> field.isdiagonal
        <span style="color: #8959a8;">if</span> parameter <span style="color: #bb9200;">==</span> <span style="color: #718c00;">"&#916;"</span>
            print(<span style="color: #718c00;">"\\Delta = "</span>)
        <span style="color: #8959a8;">elseif</span> parameter <span style="color: #bb9200;">==</span> <span style="color: #718c00;">"&#948;"</span>
            print(<span style="color: #718c00;">"\\delta = "</span>)
        <span style="color: #8959a8;">else</span>
            print(parameter,<span style="color: #718c00;">" = "</span>)
        <span style="color: #8959a8;">end</span>
        show(io, MIME(<span style="color: #718c00;">"text/latex"</span>), field[parameter][<span style="color: #f5871f; font-weight: bold;">1</span>])
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">if</span> parameter<span style="color: #bb9200;">==</span><span style="color: #718c00;">"&#916;"</span>
            print(<span style="color: #718c00;">"(\\Delta, \\bar\\Delta) = "</span>)
        <span style="color: #8959a8;">elseif</span> parameter<span style="color: #bb9200;">==</span><span style="color: #718c00;">"&#948;"</span>
            print(<span style="color: #718c00;">"(\\delta, \\bar\\delta) = "</span>)
        <span style="color: #8959a8;">else</span>
            print(<span style="color: #718c00;">"($parameter, \\bar$parameter) = "</span>)
        <span style="color: #8959a8;">end</span>
        print(<span style="color: #718c00;">"("</span>); show(io, MIME(<span style="color: #718c00;">"text/latex"</span>), field[parameter][<span style="color: #f5871f; font-weight: bold;">1</span>]); print(<span style="color: #718c00;">", "</span>);
        show(io, MIME(<span style="color: #718c00;">"text/latex"</span>), field[parameter][<span style="color: #f5871f; font-weight: bold;">2</span>]); print(<span style="color: #718c00;">")"</span>)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #07c365;"># </span><span style="color: #07c365;">function Base.show(io::IO, arr::Vector{Field{T}}) where {T}</span>
<span style="color: #07c365;">#     </span><span style="color: #07c365;">println(io, "Vector{Field{$T}} with $(length(arr)) elements:")</span>
<span style="color: #07c365;">#     </span><span style="color: #07c365;">for (index, field) in enumerate(arr)</span>
<span style="color: #07c365;">#         </span><span style="color: #07c365;">print(io, "$(index): ")</span>
<span style="color: #07c365;">#         </span><span style="color: #07c365;">show(io, field)</span>
<span style="color: #07c365;">#         </span><span style="color: #07c365;">println()</span>
<span style="color: #07c365;">#     </span><span style="color: #07c365;">end</span>
<span style="color: #07c365;"># </span><span style="color: #07c365;">end</span>

<span style="color: #718c00;">"""Overload []"""</span>
Base.<span style="color: #4271ae;">getindex</span>(field<span style="color: #bb9200;">::Field</span>,key) = field.values[key];
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge777063" class="outline-4">
<h4 id="orge777063">End of module</h4>
<div class="outline-text-4" id="text-orge777063">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org6cb541b" class="outline-2">
<h2 id="org6cb541b"><span class="section-number-2">3.</span> Correlation Functions</h2>
<div class="outline-text-2" id="text-3">
<p>
The file <a href="./src/CorrelationFunctions.jl">CorrelationFunctions.jl</a> provides structs and methods for representing and computing correlation functions.
</p>

<p>
It uses the types defined in <a href="#orgd264e14">The <code>CFTData</code> module</a>.
</p>
</div>
<div id="outline-container-org3a17569" class="outline-3">
<h3 id="org3a17569">Four-point correlation functions on the sphere</h3>
<div class="outline-text-3" id="text-org3a17569">
</div>
<div id="outline-container-orgace1a5e" class="outline-4">
<h4 id="orgace1a5e">Four point functions in CFT</h4>
<div class="outline-text-4" id="text-orgace1a5e">
<p>
Because of conformal invariance, computation of any four-point correlation function reduces to the computation of
</p>

<p>
\[ \mathcal F(x) = \langle V_{1}(x) V_{2}(0) V_{3}(\infty) V_{4}(1) \rangle \]
</p>
</div>
</div>
<div id="outline-container-orgb1a73cd" class="outline-4">
<h4 id="orgb1a73cd">Coefficients \(C^{N}_{m,n}\)</h4>
<div class="outline-text-4" id="text-orgb1a73cd">
<p>
We define a coefficient \(C_{m,n}^N\) by the recursive formula
</p>

<p>
\[
C^N_{m,n} = R_{m,n}\left(\delta_{N-mn,0} + \sum_{m'n'\leq N-mn} \frac{C^{N-mn}_{m',n'}}{\delta_{(m,-n)}-\delta_{(m',n')}} \right)
\]
</p>

<p>
An expression for the \(R_{m,n}\) can be found in <a href="https://en.wikipedia.org/wiki/Virasoro_conformal_block">this wikipedia article</a>. It can be rewritten
</p>

<p>
\[
R_{m,n} = \frac{1}{2}\frac{1}{D_{mn}}
\prod_{r\overset{2}{=} 1-m}^{m-1}
\prod_{s\overset{2}{=}1-n}^{n-1}
\sqrt{(\delta_2-\delta_1)^2 -2\delta_{(r,s)}(\delta_1+\delta_2) + \delta_{(r,s)}^2}
\sqrt{(\delta_3-\delta_4)^2 -2\delta_{(r,s)}(\delta_3+\delta_4) + \delta_{(r,s)}^2}
\]
</p>

<p>
where we do not actually take square roots, because each factor appears twice, except the \((r,s)=(0,0)\) factor which is however a perfect square. The normalization factor is
</p>

<p>
\[
D_{m,n} = mn \prod_{r=1}^{m-1} r^2B \left(r^2B - \frac{n^2}{B}\right)
\prod_{s=1}^{n-1} \frac{s^2}{B}\left(\frac{s^2}{B} - m^2B\right)
\prod_{r=1}^{m-1} \prod_{s=1}^{n-1} \left(r^2B -\frac{s^2}{B} \right)^2.
\]
</p>

<p>
The \(C^{N}_{m,n}\) only depend on the external fields and the central charge, hence we compute them in the <code>FourPointCorrelationFunctions</code> module.
</p>
</div>
</div>
<div id="outline-container-org48d60fd" class="outline-4">
<h4 id="org48d60fd">The <code>FourPointCorrelationFunctions</code> module</h4>
<div class="outline-text-4" id="text-org48d60fd">
<p>
The module <code>FourPointCorrelationFunctions</code> defines
</p>

<ul class="org-ul">
<li><p>
a struct <code>FourPointCorrelation</code> that represents a four point function
</p>

<p>
\[
  < V_1(0) V_2(1) V_3(\infty) V_4(x)>
  \]
</p></li>

<li>a method <code>computeCNmn</code> that computes the coefficients \(C^N_{m,n}\) which serve to compute the conformal blocks that enter the expansion of the 4-pt function.</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgdb5f971"></a>Header<br />
<div class="outline-text-5" id="text-orgdb5f971">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">===========================================================================================#</span>

<span style="color: #8959a8;">module</span> FourPointCorrelationFunctions

<span style="color: #8959a8;">export</span> FourPointCorrelation, computeCNmn

<span style="color: #8959a8;">using</span> ..CFTData
<span style="color: #8959a8;">using</span> Match
<span style="color: #8959a8;">import</span> Memoization: <span style="color: #4d4d4c; font-weight: bold;">@memoize</span>
</pre>
</div>
</div>
</li>
<li><a id="org534e444"></a>Four-point function type<br />
<div class="outline-text-5" id="text-org534e444">
<p>
We create a struct <code>FourPointCorrelation</code> for representing a four-point function on the sphere, that is, a central charge and four external fields.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Struct representing a four-point function. Contains</span>
<span style="color: #718c00;">- a central charge</span>
<span style="color: #718c00;">- 4 external fields</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">FourPointCorrelation</span>{T}
    charge<span style="color: #bb9200;">::CentralCharge</span>{T}
    fields<span style="color: #bb9200;">::Vector</span>{Field{T}}
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">FourPointCorrelation</span>(charge<span style="color: #bb9200;">::CentralCharge</span>{T}, V1, V2, V3, V4) <span style="color: #8959a8;">where</span> {T}
    <span style="color: #8959a8;">return</span> FourPointCorrelation{T}(charge, [V1, V2, V3, V4])
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display a four-point function"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>)
    println(<span style="color: #718c00;">"Four-point correlation function: &lt; V_1 V_2 V_3 V_4 &gt; where "</span>)
    print(<span style="color: #718c00;">"V_1 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>])
    print(<span style="color: #718c00;">"V_2 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">2</span>])
    print(<span style="color: #718c00;">"V_3 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">3</span>])
    print(<span style="color: #718c00;">"V_4 = "</span>); show(corr.fields[<span style="color: #f5871f; font-weight: bold;">4</span>])
<span style="color: #8959a8;">end</span>

<span style="color: #07c365;"># </span><span style="color: #07c365;">explicit names for the indices of left and right dimensions</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">left</span> = <span style="color: #f5871f; font-weight: bold;">1</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">right</span> = <span style="color: #f5871f; font-weight: bold;">2</span>
</pre>
</div>
</div>
</li>
<li><a id="org8d532c0"></a>Compute \(C^N_{m,n}\)<br />
<div class="outline-text-5" id="text-org8d532c0">
<p>
The function <code>permute_ext_fields</code> permutes the external fields such that the first two and last two are fused together in the channel.
</p>

<p>
The <code>@memoize</code> macro stores the result of the function such that subsequent calls with the same arguments only require a memory access.
</p>

<p>
The function <code>Rmn_zero_order</code> computes the order of a zero of R, to avoid computing 0/0 in \(\frac{R_{m,n}}{\delta - \delta_{r,s}}\). At generic central charge (non-rational) \(R_{m,n}\) is zero iff one of the two pairs of fused fields have Kac indices such that \(r_1 \pm r_2 \in \{1-m, 3-m, \dots, m-1\}\) or \(s_1 \pm s_2 \in \{1-n, 3-n, \dots, n-1\}\).
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #4271ae;">double_prod_in_Dmn</span>(m, n, B) = prod(prod((r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">-</span> s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #8959a8;">for</span> s in <span style="color: #f5871f; font-weight: bold;">1</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)

<span style="color: #4271ae;">&#948;rs</span>(r, s, B) = <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">4</span> <span style="color: #bb9200;">*</span> (B<span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">*</span>s <span style="color: #bb9200;">+</span> s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B)

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Dmn</span>(m, n, B)
    <span style="color: #8959a8;">if</span> m <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> n <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">treat cases m = 1, n=1 separately</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">1</span>
    <span style="color: #8959a8;">elseif</span> m <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">return</span> n <span style="color: #bb9200;">*</span> prod(s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">*</span> (s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">-</span> m<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
    <span style="color: #8959a8;">elseif</span> n <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">return</span> m <span style="color: #bb9200;">*</span> prod(r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">*</span> (r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">-</span> n<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
    <span style="color: #8959a8;">else</span>
        f1 = prod(r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">*</span> (r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B <span style="color: #bb9200;">-</span> n<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
        f2 = prod(s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">*</span> (s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B <span style="color: #bb9200;">-</span> m<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>B) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
        f3 = double_prod_in_Dmn(m, n, B)
        <span style="color: #8959a8;">return</span> m<span style="color: #bb9200;">*</span>n<span style="color: #bb9200;">*</span>f1<span style="color: #bb9200;">*</span>f2<span style="color: #bb9200;">*</span>f3
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Permute the external fields to get t- or u-channels from s-channel"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">permute_ext_fields</span>(corr<span style="color: #bb9200;">::FourPointCorrelation</span>, channel)
    Vs=corr.fields
    Vs = <span style="color: #4d4d4c; font-weight: bold;">@match</span> channel <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"s"</span> <span style="color: #bb9200;">=&gt;</span> [Vs[<span style="color: #f5871f; font-weight: bold;">1</span>], Vs[<span style="color: #f5871f; font-weight: bold;">2</span>], Vs[<span style="color: #f5871f; font-weight: bold;">3</span>], Vs[<span style="color: #f5871f; font-weight: bold;">4</span>]]
        <span style="color: #718c00;">"t"</span> <span style="color: #bb9200;">=&gt;</span> [Vs[<span style="color: #f5871f; font-weight: bold;">1</span>], Vs[<span style="color: #f5871f; font-weight: bold;">4</span>], Vs[<span style="color: #f5871f; font-weight: bold;">3</span>], Vs[<span style="color: #f5871f; font-weight: bold;">2</span>]]
        <span style="color: #718c00;">"u"</span> <span style="color: #bb9200;">=&gt;</span> [Vs[<span style="color: #f5871f; font-weight: bold;">1</span>], Vs[<span style="color: #f5871f; font-weight: bold;">3</span>], Vs[<span style="color: #f5871f; font-weight: bold;">2</span>], Vs[<span style="color: #f5871f; font-weight: bold;">4</span>]]
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> FourPointCorrelation(corr.charge, Vs)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Order of a pole of Rmn, assuming the central charge is generic"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Rmn_zero_order</span>(m, n, B, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, channel)

    order=<span style="color: #f5871f; font-weight: bold;">0</span>
    V=permute_ext_fields(corr, channel).fields

    <span style="color: #8959a8;">if</span><span style="color: #bb9200;"> !</span>((V[<span style="color: #f5871f; font-weight: bold;">1</span>].isKac <span style="color: #bb9200;">&amp;&amp;</span> V[<span style="color: #f5871f; font-weight: bold;">2</span>].isKac) <span style="color: #bb9200;">||</span> (V[<span style="color: #f5871f; font-weight: bold;">3</span>].isKac <span style="color: #bb9200;">&amp;&amp;</span> V[<span style="color: #f5871f; font-weight: bold;">4</span>].isKac))
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">end</span>

    r=[V[i].r <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>]
    s=[V[i].s <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>]

    <span style="color: #07c365;">#</span><span style="color: #07c365;">= Rmn is zero if r1 \pm r2 or r3 \pm r4 is an integer in 1-m:2:m-1, and</span>
<span style="color: #07c365;">    s1 \pm s2 or s3 \pm s4 is an integer in 1-n:2:n-1.</span>
<span style="color: #07c365;">    equivalently, if (|r1 \pm r2| &lt;= m-1 and r1-r2 - (m-1) % 2 == 0)</span>
<span style="color: #07c365;">    and (|s1 \pm s2| &lt;= n-1 and s1-s2 - (n-1) % 2 == 0)</span>
<span style="color: #07c365;">    =#</span>
    <span style="color: #8959a8;">for</span> pm <span style="color: #8959a8;">in</span> (<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">1</span>)
        <span style="color: #8959a8;">for</span> (i,j) <span style="color: #8959a8;">in</span> ((<span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">2</span>),(<span style="color: #f5871f; font-weight: bold;">3</span>,<span style="color: #f5871f; font-weight: bold;">4</span>))
            <span style="color: #8959a8;">if</span> V[i].isdegenerate <span style="color: #bb9200;">&amp;&amp;</span> V[j].isdegenerate
                <span style="color: #8959a8;">if</span> (abs(r[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>r[j]) <span style="color: #bb9200;">&lt;=</span> m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> (r[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>r[j]<span style="color: #bb9200;">-</span>(m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>))<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span>) <span style="color: #bb9200;">&amp;&amp;</span>
                    (abs(s[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>s[j]) <span style="color: #bb9200;">&lt;=</span> n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> (s[i]<span style="color: #bb9200;">+</span>pm<span style="color: #bb9200;">*</span>s[j]<span style="color: #bb9200;">-</span>(n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>))<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span>)
                    order <span style="color: #bb9200;">+=</span> <span style="color: #f5871f; font-weight: bold;">1</span>
                <span style="color: #8959a8;">end</span>
            <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>

    <span style="color: #8959a8;">return</span> order
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">helper_Rmn</span>(&#948;1, &#948;2, &#948;3, &#948;4, r, s, B)
    <span style="color: #8959a8;">if</span> r <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span> <span style="color: #bb9200;">&amp;&amp;</span> s <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> (&#948;2<span style="color: #bb9200;">-</span>&#948;1)<span style="color: #bb9200;">*</span>(&#948;3<span style="color: #bb9200;">-</span>&#948;4)
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">return</span> (((&#948;2<span style="color: #bb9200;">-</span>&#948;1)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#948;rs(r, s, B)<span style="color: #bb9200;">*</span>(&#948;1<span style="color: #bb9200;">+</span>&#948;2) <span style="color: #bb9200;">+</span> &#948;rs(r, s, B)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)
                <span style="color: #bb9200;">*</span>((&#948;3<span style="color: #bb9200;">-</span>&#948;4)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>&#948;rs(r, s, B)<span style="color: #bb9200;">*</span>(&#948;3<span style="color: #bb9200;">+</span>&#948;4) <span style="color: #bb9200;">+</span> &#948;rs(r, s, B)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>))
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Compute `Rmn`.</span>
<span style="color: #718c00;">lr indicates the left or right moving parts of the fields</span>
<span style="color: #718c00;">Cache the result.</span>
<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> value of regularisation</span>
<span style="color: #718c00;">"""</span>
<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> <span style="color: #8959a8;">function</span> Rmn(m, n, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, channel, lr)

    B = corr.charge[<span style="color: #718c00;">"B"</span>]
    Vs = permute_ext_fields(corr, channel).fields
    &#948;1 = Vs[<span style="color: #f5871f; font-weight: bold;">1</span>][<span style="color: #718c00;">"&#948;"</span>][lr]
    &#948;2 = Vs[<span style="color: #f5871f; font-weight: bold;">2</span>][<span style="color: #718c00;">"&#948;"</span>][lr]
    &#948;3 = Vs[<span style="color: #f5871f; font-weight: bold;">3</span>][<span style="color: #718c00;">"&#948;"</span>][lr]
    &#948;4 = Vs[<span style="color: #f5871f; font-weight: bold;">4</span>][<span style="color: #718c00;">"&#948;"</span>][lr]

    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, B, corr, channel) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">if</span> m <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span>
            res = prod(helper_Rmn(&#948;1, &#948;2, &#948;3, &#948;4, <span style="color: #f5871f; font-weight: bold;">0</span>, s, B) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">0</span>)
        <span style="color: #8959a8;">else</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">m &gt; 1</span>
            res = prod(prod(helper_Rmn(&#948;1, &#948;2, &#948;3, &#948;4, r, s, B)
                            <span style="color: #8959a8;">for</span> s in <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>) <span style="color: #8959a8;">for</span> r <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>m:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
            <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">==</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">m odd -&gt; treat r=0 term separately</span>
                res <span style="color: #bb9200;">*=</span> prod(helper_Rmn(&#948;1, &#948;2, &#948;3, &#948;4, <span style="color: #f5871f; font-weight: bold;">0</span>, s, B) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">0</span>)
            <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>

    <span style="color: #8959a8;">return</span> res<span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>Dmn(m, n, B))
<span style="color: #8959a8;">end</span>

<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> <span style="color: #8959a8;">function</span> computeCNmn(N, m, n, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, channel, lr)
    B = corr.charge[<span style="color: #718c00;">"B"</span>]
    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, B, corr, channel) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">elseif</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&gt;</span> N
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">elseif</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">==</span> N
        <span style="color: #8959a8;">return</span> Rmn(m, n, corr, channel, lr)
    <span style="color: #8959a8;">else</span>
        res = sum(sum(computeCNmn(N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n, mp, np, corr, channel, lr)<span style="color: #bb9200;">/</span>(&#948;rs(m, <span style="color: #bb9200;">-</span>n, B) <span style="color: #bb9200;">-</span> &#948;rs(mp, np, B))
                      <span style="color: #8959a8;">for</span> mp <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n <span style="color: #8959a8;">if</span> mp<span style="color: #bb9200;">*</span>np <span style="color: #bb9200;">&lt;=</span> N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
                  <span style="color: #8959a8;">for</span> np <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
        <span style="color: #8959a8;">return</span> Rmn(m, n, corr, channel, lr) <span style="color: #bb9200;">*</span> res
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org2840358"></a>End module<br />
<div class="outline-text-5" id="text-org2840358">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd74702b" class="outline-3">
<h3 id="orgd74702b">One-point correlation functions on the torus</h3>
<div class="outline-text-3" id="text-orgd74702b">
</div>
<div id="outline-container-org207aed6" class="outline-4">
<h4 id="org207aed6">One point functions in CFT</h4>
<div class="outline-text-4" id="text-org207aed6">
<p>
Because of translation invariance, one-point functions on the torus do not depend on the field&rsquo;s position, but only on the modulus of the torus.
</p>
</div>
</div>
<div id="outline-container-org9030346" class="outline-4">
<h4 id="org9030346">Coefficients \(C^{N,\text{torus}}_{m,n}\)</h4>
<div class="outline-text-4" id="text-org9030346">
<p>
The coefficients \(C_{m,n}^{N,\text{torus}}\) have the recursive representation
</p>

\begin{equation}
\label{org63c160c}
C^{N,\text{torus}}_{m,n} = R^{\text{torus}}_{m,n}\left(\delta_{N-mn,0} + \sum_{m'n'\leq N-mn} \frac{C^{N-mn}_{m',n'}}{\delta_{(m,-n)}-\delta_{(m',n')}} \right)
\end{equation}


<p>
An expression for the \(R_{m,n}^{\text{torus}}\) can be found on <a href="https://en.wikipedia.org/wiki/Virasoro_conformal_block">this wikipedia article</a>. It can be rewritten
</p>

<p>
\[
R_{m,n}^{\text{torus}} = \frac{1}{2 D_{m,n}} \prod_{r\overset2=1-2m}^{2m-1} \prod_{s\overset2=1-2n}^{2n-1} \sqrt{\delta_{(r,s)} - \delta_1}
\] 
</p>

<p>
where we do not actually take square roots, because each factor appears twice. The normalization factor is the same \(D_{m,n}\) as in the case.
</p>
</div>
</div>
<div id="outline-container-org650eada" class="outline-4">
<h4 id="org650eada">The <code>OnePointCorrelationFunctions</code> module</h4>
<div class="outline-text-4" id="text-org650eada">
<p>
The module <code>OnePointCorrelationFunctions</code> defines
</p>

<ul class="org-ul">
<li>a struct <code>OnePointCorrelation</code> that represents a one point function \[
  < V >,
  \]</li>
<li>a method <code>computeCNmn</code> that computes the coefficients \(C^{N,\text{torus}}_{m,n}\) which serve to compute the conformal blocks that enter the expansion of the 1-pt function.</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org002089d"></a>Header<br />
<div class="outline-text-5" id="text-org002089d">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">module</span> OnePointCorrelationFunctions

<span style="color: #8959a8;">export</span> OnePointCorrelation, computeCNmn

<span style="color: #8959a8;">using</span> ..CFTData
<span style="color: #8959a8;">import</span> ..FourPointCorrelationFunctions: Dmn, &#948;rs <span style="color: #07c365;"># </span><span style="color: #07c365;">re-use the Dmn from four-point functions</span>
</pre>
</div>
</div>
</li>
<li><a id="orge01bb8d"></a>One-point function type<br />
<div class="outline-text-5" id="text-orge01bb8d">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">OnePointCorrelation</span>{T}
    charge<span style="color: #bb9200;">::CentralCharge</span>{T}
    field<span style="color: #bb9200;">::Field</span>{T}
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display a one-point function"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, corr<span style="color: #bb9200;">::OnePointCorrelation</span>)
    println(<span style="color: #718c00;">"One-point correlation function: &lt; V &gt; where "</span>)
    print(<span style="color: #718c00;">"V = "</span>); show(corr.field)
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org2d63d5e"></a>Compute \(C^{N,\text{torus}}_{m,n}\)<br />
<div class="outline-text-5" id="text-org2d63d5e">
<p>
The computation of the \(C^{N,\text{torus}}_{m,n}\) is very similar to that of the <a href="#org8d532c0">coefficients \(C^{N}_{m,n}\)</a>. We re-use much of the code.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""Order of a pole of Rmn^torus, assuming the central charge is generic"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Rmn_zero_order</span>(m, n, B, corr<span style="color: #bb9200;">::OnePointCorrelation</span>)
    V = corr.field
    <span style="color: #8959a8;">if</span> V.isKac <span style="color: #bb9200;">&amp;&amp;</span> V.r<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">==</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> V.s<span style="color: #bb9200;">%</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">==</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> abs(V.r) <span style="color: #bb9200;">&lt;=</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> abs(V.s) <span style="color: #bb9200;">&lt;=</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">1</span>
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Compute `Rmn^torus`.</span>
<span style="color: #718c00;">lr indicates the left or right moving parts of the fields</span>
<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> value of regularisation</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Rmn</span>(m, n, B, corr<span style="color: #bb9200;">::OnePointCorrelation</span>, channel, lr)
    V=corr.field
    &#948;1 = Vs[<span style="color: #f5871f; font-weight: bold;">1</span>][<span style="color: #718c00;">"&#948;"</span>][lr]

    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, B, corr) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">else</span>
        res = prod(prod(&#948;rs(r, s, B) <span style="color: #bb9200;">-</span> &#948;1 <span style="color: #8959a8;">for</span> r in <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>m<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>) <span style="color: #8959a8;">for</span> s <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">2</span>n:<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #f5871f; font-weight: bold;">2</span>n<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)
        <span style="color: #8959a8;">return</span> res<span style="color: #bb9200;">/</span>(<span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>Dmn(m, n, B))
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">computeCNmn</span>(N, m, n, B, corr<span style="color: #bb9200;">::OnePointCorrelation</span>, lr)
    <span style="color: #8959a8;">if</span> Rmn_zero_order(m, n, B, corr) <span style="color: #bb9200;">&gt;</span> <span style="color: #f5871f; font-weight: bold;">0</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0</span>
    <span style="color: #8959a8;">else</span>
        res = sum(sum(computeCNmn(N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n, mp, np, B, corr, lr)<span style="color: #bb9200;">/</span>(&#948;rs(m, <span style="color: #bb9200;">-</span>n, B)<span style="color: #bb9200;">-</span>&#948;rs(mp, np, B))
                      <span style="color: #8959a8;">for</span> mp <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n <span style="color: #8959a8;">if</span> mp<span style="color: #bb9200;">*</span>np <span style="color: #bb9200;">&lt;=</span> N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
                  <span style="color: #8959a8;">for</span> mp <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n)
        <span style="color: #8959a8;">return</span> Rmn(m, n, B, corr, channel, lr) <span style="color: #bb9200;">*</span> ((N<span style="color: #bb9200;">-</span>m<span style="color: #bb9200;">*</span>n<span style="color: #bb9200;">==</span><span style="color: #f5871f; font-weight: bold;">0</span>)<span style="color: #bb9200;">+</span>res)
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org8801db3"></a>End module<br />
<div class="outline-text-5" id="text-org8801db3">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6a01abe" class="outline-2">
<h2 id="org6a01abe"><span class="section-number-2">4.</span> Virasoro conformal blocks</h2>
<div class="outline-text-2" id="text-4">
<p>
The file <a href="./src/ConformalBlocks.jl">ConformalBlocks.jl</a> implements Zamolodchikov&rsquo;s recursion formula for computing four-point conformal blocks on the sphere and one-point conformal blocks on the torus.
</p>

<p>
It uses types from <a href="#orgd264e14">The <code>CFTData</code> module</a> and <a href="#org6cb541b">3</a>.
</p>
</div>
<div id="outline-container-orgec4c276" class="outline-3">
<h3 id="orgec4c276">Four-point conformal blocks on the sphere</h3>
<div class="outline-text-3" id="text-orgec4c276">
</div>
<div id="outline-container-orgd501ab4" class="outline-4">
<h4 id="orgd501ab4">Four-point conformal blocks</h4>
<div class="outline-text-4" id="text-orgd501ab4">
<p>
Conformal blocks encode the universal part of correlation functions. More precisely, by performing the OPE of \(V_{1}\) with \(V_{2}\) and \(V_{3}\) with \(V_{4}\) (s-channel), or \(1\leftrightarrow 4, 2\leftrightarrow 3\) (t-channel) or \(1\leftrightarrow 3, 2\leftrightarrow 4\) (u-channel), \(\mathcal F(x)\) can be written as
</p>

<p>
\[ \mathcal F(x) = \sum_{s \in \mathcal S^{(s)}} \frac{C_{12s}C_{s34}}{B_s} \mathcal F_\Delta^{(s)}(\Delta_i | x)\]
</p>

<p>
where \(\sum_{\mathcal S^{(s)}}\) is a sum over a basis of the \(s\)-channel spectrum \(\mathcal S^{(s)}\), \(B_s\) are two-point structure constants and \(C_{ijk}\) are three-point structure constants. Analogous expressions can be written for the \(t\)- and \(u\)- channels. The functions \(\mathcal F_{\Delta}^{(s)}(\Delta_i | x)\) are called \(s\)-channel conformal blocks (resp. t,u).
</p>
</div>
<ul class="org-ul">
<li><a id="orgdf22b5f"></a>Normalisation of the blocks<br />
<div class="outline-text-5" id="text-orgdf22b5f">
<p>
Conformal blocks factorise into holomorphic and anti-holomorphic parts, and they are characterized by the normalisation conditions
</p>

\begin{align}
\label{orgdcee30b}
 \mathcal{F}^{(s)}_\Delta(x) & \underset{x\to 0}{=} \left| x^{\Delta-\Delta_1-\Delta_2}\right|^2 \left(1+O(x)\right) \nonumber
 \\
 \mathcal{F}^{(t)}_\Delta(x) & \underset{x\to 1}{=} \left|(1-x)^{\Delta-\Delta_1-\Delta_4}\right|^2 \left(1+O(1-x)\right) \nonumber
 \\
 \mathcal{F}^{(u)}_\Delta(x) & \underset{x\to \infty}{=} \left|\left(\frac{1}{x}\right)^{\Delta+\Delta_1-\Delta_3} \right|^2\left(1+O\left(\frac{1}{x}\right)\right)
\end{align}

<p>
(we omit the \(\Delta_i\) dependence in the notation \(\mathcal{F}^{(u)}_\Delta(x)\)).
</p>
</div>
</li>
<li><a id="orgf1cb57a"></a>Notations<br />
<div class="outline-text-5" id="text-orgf1cb57a">
<p>
\[
x = \frac{\theta_2(q)^4}{\theta_3(q)^4}, \quad q = e^{-\pi\frac{K(1-x)}{ K(x)}}
\]
</p>

<p>
where
</p>

<p>
\[
\theta_3(q) = \sum_{n\in\mathbb{Z}} q^{n^2} \quad , \quad \theta_2(q) = 2q^\frac14\sum_{n=0}^\infty q^{n(n+1)}
\] 
</p>

<p>
are Jacobi special \(\theta\)-functions, and \(K(x)\) is the elliptic \(K\) function.
</p>
</div>
</li>
<li><a id="org8d9e8de"></a>Expression<br />
<div class="outline-text-5" id="text-org8d9e8de">
<p>
Our chiral \(s\)-channel conformal block is 
</p>

<p>
\[
\mathcal{F}^{(s)}_{\delta}(x) =  x^{E_0} (1-x)^{E_1} \theta_3(q)^{-4E_2}
(16q)^{\delta} H(q,\delta)
\] 
</p>

<p>
where we use the exponents
\[
E_0 = -\delta_1-\delta_2-\frac{c-1}{24} \quad , \quad E_1 = -\delta_1-\delta_4-\frac{c-1}{24} \quad ,
\quad E_2 = \delta_1+\delta_2+\delta_3+\delta_4+\frac{c-1}{24}
\] 
The non-trivial coefficient is the series
</p>

<p>
\[
H(q,\delta) = 1 + \sum_{N=1}^{N_{max}} \sum_{mn\leq N} C_{m,n}^N \frac{(16q)^N}{\delta-\delta_{(m,n)}}
\]
</p>
</div>
</li>
<li><a id="org603b6b3"></a>Changing channels<br />
<div class="outline-text-5" id="text-org603b6b3">
<p>
In practice, we compute $s$-channel blocks, and then use these to compute $t$- and $u$- channel blocks, from the relations
</p>

\begin{align*}
\label{orgba76abe}
\mathcal{F}^{(t)}_{\Delta}(\Delta_1,\Delta_2,\Delta_3,\Delta_4|x)
&= (-1)^{S_1+S_2+S_3+S_4}
\mathcal{F}^{(s)}_{\Delta}(\Delta_1,\Delta_4,\Delta_3,\Delta_2|1-x)
\\
\mathcal{F}^{(u)}_\Delta(\Delta_1,\Delta_2,\Delta_3,\Delta_4|x)
&= (-1)^{S_1+S_2+S_3+S_4}
\left|x^{-2\Delta_1}\right|^2 \mathcal{F}^{(s)}_\Delta(\Delta_1,\Delta_3,\Delta_2,\Delta_4|\frac{1}{x})
\end{align*}

<p>
where \(S=\Delta-\bar\Delta\) is the conformal spin, which we assume to be integer. These relations are obtained from \eqref{orgdcee30b}.
</p>
</div>
</li>
<li><a id="orgbd8d197"></a><span class="todo TODO">TODO</span> Degenerate blocks<br />
<div class="outline-text-5" id="text-orgbd8d197">
<p>
In the case \(\delta_1 = \delta_{(r_1,s_1)}\) and \(\delta_2 = \delta_{(r_2,s_2)}\) with \(r_i,s_i\in\mathbb{N}^*\), we have
</p>

<p>
\[
\left\{\begin{array}{l} m\in |r_1-r_2|+1+2\mathbb{N}
\\ n \in |s_1-s_2| + 1+2\mathbb{N} \end{array} \right. \quad
\Rightarrow \quad R_{m,n} = 0
\] 
</p>

<p>
and similarly if the fields with numbers \(3\) and \(4\) are degenerate. Thanks to \(R_{m,n}=0\) thus \(C_{m,n}^N=0\), the block \(\mathcal{F}^{(s)}_{\delta_{(m,n)}}(x)\) is finite and can be computed exactly.
</p>

<p>
This can be generalized to fractional indices \(r_i,s_i\). In this case, we have to add the following restriction, which was redundant for positive integer indices:
</p>

<p>
\[
\left\{\begin{array}{l} m\in |r_1+r_2|+1+2\mathbb{N}
\\ n \in |s_1+s_2| + 1+2\mathbb{N} \end{array} \right. \quad
\Rightarrow \quad R_{m,n} = 0
\] 
</p>

<p>
and similarly if the fields with numbers \(3\) and \(4\) are degenerate. In particular, for \(\delta_i = \delta_{(0,\frac12)}\), we have \(m\in 2\mathbb{N}+1\Rightarrow R_{m,n}=0\).
</p>
</div>
</li>
<li><a id="orged2a427"></a><span class="todo TODO">TODO</span> Derivative and regularization<br />
<div class="outline-text-5" id="text-orged2a427">
<p>
For the purpose of computing conformal blocks for logarithmic channel representations, we need to compute derivatives of conformal blocks with respect to the channel dimension, and regularized values of blocks at their poles. Taking the derivative amounts to \[
H(q, \delta) \to \log(16q) H(q,\delta) +\frac{\partial}{\partial\delta} H(q, \delta)
\] And the regularization we are interested in amounts to \[
\left.\frac{1}{\delta-\delta_{(m,n)}}\right|_{\delta=\delta_{(m,n)}} = \log(16q)-\frac{1}{4\delta_{(m,n)}}
\] The code can formally compute a regularization of the block&rsquo;s derivative, but this regularization is a priori not meaningful.
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org15d6d50" class="outline-4">
<h4 id="org15d6d50">The <code>FourPointBlocksSphere</code> module</h4>
<div class="outline-text-4" id="text-org15d6d50">
<p>
The module <code>FourPointBlocksSphere</code> exports
</p>

<ul class="org-ul">
<li>a struct <code>FourPointBlockSphere</code> that encapsulates the data needed to compute a 4pt conformal block, namely a channel, four external fields and the field propagating in the channel</li>
<li>a function <code>F_four_point_sphere(block, charge, x)</code> which computes the value of the non-chiral block \(\mathcal F_{\Delta}^{(s)}(\Delta_i | x)\) as defined in this paragraph.</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org8a3fa60"></a>Header<br />
<div class="outline-text-5" id="text-org8a3fa60">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>

<span style="color: #07c365;">ConformalBlocks.jl contains modules that compute series expansions for</span>
<span style="color: #07c365;">Virasoro four-point conformal blocks on the sphere and Virasoro one-point conformal blocks</span>
<span style="color: #07c365;">on the torus.</span>

<span style="color: #07c365;">Written by Paul Roux, adapting a Python code written by Sylvain Ribault &amp; Rongvoram</span>
<span style="color: #07c365;">Nivesvivat</span>

<span style="color: #07c365;">===========================================================================================#</span>


<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Series expansion of four-point blocks on the sphere.</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">module</span> FourPointBlocksSphere

<span style="color: #8959a8;">export</span> FourPointBlockSphere, F_four_point_sphere

<span style="color: #8959a8;">using</span> ..CFTData, ..FourPointCorrelationFunctions
<span style="color: #8959a8;">import</span> ..FourPointCorrelationFunctions: permute_ext_fields
<span style="color: #8959a8;">using</span> Match, EllipticFunctions, Memoization

</pre>
</div>
</div>
</li>
<li><a id="orgbde3b69"></a>Four-point block sphere type<br />
<div class="outline-text-5" id="text-orgbde3b69">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Struct FourPointBlockSphere</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    FourPointBlockSphere{T}</span>

<span style="color: #718c00;">Composite type that represents the list of arguments of a four-point conformal block:</span>
<span style="color: #718c00;">a channel and a field propagating in the channel. The external fields and central charge are</span>
<span style="color: #718c00;">provided in a `FourPointCorrelation` object.</span>

<span style="color: #718c00;"># Example</span>

<span style="color: #718c00;">```julia-repl</span>
<span style="color: #718c00;">julia&gt; c = CentralCharge("c",0.5); V = Field(c, "&#948;", 0.6, diagonal = true);</span>
<span style="color: #718c00;">julia&gt; FourPointBlockSphere("s", V)</span>
<span style="color: #718c00;">Four-point block</span>
<span style="color: #718c00;">Channel:        s</span>
<span style="color: #718c00;">Channel Field:</span>
<span style="color: #718c00;">Diagonal field of dimension:</span>
<span style="color: #718c00;">  &#916; = 0.5791666666666667 + 0.0im</span>
<span style="color: #718c00;">  P = 0.0 + 0.7745966692414834im</span>
<span style="color: #718c00;">  &#948; = 0.6000000000000001 + 0.0im</span>
<span style="color: #718c00;">  p = 0.7745966692414834 + 0.0im</span>
<span style="color: #718c00;">```</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">FourPointBlockSphere</span>{T}

    channel<span style="color: #bb9200;">::String</span>
    channelField<span style="color: #bb9200;">::Field</span>{T}

<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Display blocks"""</span>
<span style="color: #8959a8;">function</span> Base.<span style="color: #4271ae;">show</span>(io<span style="color: #bb9200;">::IO</span>, block<span style="color: #bb9200;">::FourPointBlockSphere</span>)
    println(<span style="color: #718c00;">"Four-point block"</span>)
    println(<span style="color: #718c00;">"Channel:\t$(block.channel)"</span>)
    println(<span style="color: #718c00;">"Channel Field:"</span>)
    show(block.channelField)
    <span style="color: #07c365;"># </span><span style="color: #07c365;">println("External Fields:")</span>
    <span style="color: #07c365;"># </span><span style="color: #07c365;">print("1. "); show(block.extFields[1])</span>
    <span style="color: #07c365;"># </span><span style="color: #07c365;">print("2. "); show(block.extFields[2])</span>
    <span style="color: #07c365;"># </span><span style="color: #07c365;">print("3. "); show(block.extFields[3])</span>
    <span style="color: #07c365;"># </span><span style="color: #07c365;">print("4. "); show(block.extFields[4])</span>
<span style="color: #8959a8;">end</span>

<span style="color: #07c365;"># </span><span style="color: #07c365;">explicit names for the indices of left and right dimensions</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">left</span> = <span style="color: #f5871f; font-weight: bold;">1</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">right</span> = <span style="color: #f5871f; font-weight: bold;">2</span>
</pre>
</div>
</div>
</li>
<li><a id="org537131d"></a>Change of channel<br />
<div class="outline-text-5" id="text-org537131d">
<p>
The $t$- and $u$-channel blocks are computed from the $s$-channel one, using \eqref{orgba76abe} described above.
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Get t- and u- channel blocks from s-channel block</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""Prefactor to get t- or u-channel blocks from the s-channel block"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">channelprefactor</span>(block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, x)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> block.channel <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"s"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #718c00;">"t"</span> <span style="color: #bb9200;">=&gt;</span> (<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">^</span>(sum(spin(corr.fields)))
        <span style="color: #718c00;">"u"</span> <span style="color: #bb9200;">=&gt;</span> (<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">^</span>(sum(spin.(corr.fields)))<span style="color: #bb9200;">*</span>abs2(x)<span style="color: #bb9200;">^</span>(<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>][<span style="color: #718c00;">"&#916;"</span>])
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Cross-ratio at which to evaluate the s-channel block to get t- or u-channel block"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">crossratio</span>(channel, x)
    <span style="color: #4d4d4c; font-weight: bold;">@match</span> channel <span style="color: #8959a8;">begin</span>
        <span style="color: #718c00;">"s"</span> <span style="color: #bb9200;">=&gt;</span> x
        <span style="color: #718c00;">"t"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>x
        <span style="color: #718c00;">"u"</span> <span style="color: #bb9200;">=&gt;</span> <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>x
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="org79a28b1"></a>Prefactors, elliptic nome<br />
<div class="outline-text-5" id="text-org79a28b1">
<p>
The nome \(q\) is related to \(x\) via
</p>

<p>
\[
q(x) = \exp(-\pi \frac{K(1-x)}{K(x)})
\]
</p>

<p>
where \(K\) is the elliptic \(K\) function. The inverse of this relation isKac
</p>

<p>
\[
x(q) = \left(\frac{\theta_{4}(q)}{\theta_{3}(q)}\right)^{2}
\]
</p>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Set prefactors, relate the cross-ratio x and the elliptic nome q</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""Nome `q` from the cross-ratio `x`"""</span>
<span style="color: #4d4d4c; font-weight: bold;">@memoize</span> qfromx(x) = exp(<span style="color: #bb9200;">-</span>&#960;<span style="color: #bb9200;">*</span>ellipticK(<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>x) <span style="color: #bb9200;">/</span> ellipticK(x))

<span style="color: #718c00;">""""Cross ratio `x` from the nome `q`"""</span>
<span style="color: #4271ae;">xfromq</span>(q) = jtheta2(<span style="color: #f5871f; font-weight: bold;">0</span>,q)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">4</span> <span style="color: #bb9200;">/</span> jtheta3(<span style="color: #f5871f; font-weight: bold;">0</span>,q)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">4</span>

<span style="color: #718c00;">"""Prefactor for getting the block F from H. The argument `lr` indicates if we are working</span>
<span style="color: #718c00;">with a left or right moving block"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">blockprefactor</span>(block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, x, lr)

    c = corr.charge[<span style="color: #718c00;">"c"</span>]
    e0 = <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>][<span style="color: #718c00;">"&#948;"</span>][lr] <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">2</span>][<span style="color: #718c00;">"&#948;"</span>][lr] <span style="color: #bb9200;">-</span> (c<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
    e1 = <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">1</span>][<span style="color: #718c00;">"&#948;"</span>][lr] <span style="color: #bb9200;">-</span> corr.fields[<span style="color: #f5871f; font-weight: bold;">4</span>][<span style="color: #718c00;">"&#948;"</span>][lr] <span style="color: #bb9200;">-</span> (c<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
    e2 = sum(corr.fields[i][<span style="color: #718c00;">"&#948;"</span>][lr] <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">4</span>) <span style="color: #bb9200;">+</span> (c<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>)<span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">24</span>
    q=qfromx(x)

    <span style="color: #8959a8;">return</span> x<span style="color: #bb9200;">^</span>e0 <span style="color: #bb9200;">*</span> (<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>x)<span style="color: #bb9200;">^</span>e1 <span style="color: #bb9200;">*</span> jtheta3(<span style="color: #f5871f; font-weight: bold;">0</span>,q)<span style="color: #bb9200;">^</span>(<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">4</span><span style="color: #bb9200;">*</span>e2) <span style="color: #bb9200;">*</span> (<span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q)<span style="color: #bb9200;">^</span>block.channelField[<span style="color: #718c00;">"&#948;"</span>][<span style="color: #f5871f; font-weight: bold;">1</span>]
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Degenerate dimensions"""</span>
<span style="color: #4271ae;">&#948;rs</span>(r, s, B) = <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">4</span> <span style="color: #bb9200;">*</span> (B<span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>r<span style="color: #bb9200;">*</span>s <span style="color: #bb9200;">+</span> s<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>B)
</pre>
</div>
</div>
</li>
<li><a id="org33a531e"></a>Computation of the block<br />
<div class="outline-text-5" id="text-org33a531e">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Compute the conformal block</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""Compute the function ``H(q,&#948;)``."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">H</span>(q, Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, lr)
    &#948; = block.channelField[<span style="color: #718c00;">"&#948;"</span>][lr]
    B = corr.charge[<span style="color: #718c00;">"B"</span>]
    sq = <span style="color: #f5871f; font-weight: bold;">16</span><span style="color: #bb9200;">*</span>q
    res=<span style="color: #f5871f; font-weight: bold;">1</span>
    pow = <span style="color: #f5871f; font-weight: bold;">1</span>
    <span style="color: #8959a8;">for</span> N <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:Nmax
        sum_mn = sum(sum(computeCNmn(N, m, n, corr, block.channel, lr)<span style="color: #bb9200;">/</span>(&#948;<span style="color: #bb9200;">-</span>&#948;rs(m, n, B))
                         <span style="color: #8959a8;">for</span> n in <span style="color: #f5871f; font-weight: bold;">1</span>:N <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&lt;=</span> N) <span style="color: #8959a8;">for</span> m <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N)
        pow <span style="color: #bb9200;">*=</span> sq
        res <span style="color: #bb9200;">+=</span> pow <span style="color: #bb9200;">*</span> sum_mn
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> res
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    Fs_chiral(block::FourPointBlockSphere, corr::FourPointCorrelation, x, lr)</span>

<span style="color: #718c00;">Compute the chiral conformal block</span>

<span style="color: #718c00;">``\\mathcal F^{(s)}_{\\delta}(x)``</span>

<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">Fs_chiral</span>(x, Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, lr)
    blockprefactor(block, corr, x, lr) <span style="color: #bb9200;">*</span> H(qfromx(x), Nmax, block, corr, lr)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""Compute the chiral conformal block</span>

<span style="color: #718c00;">``\\mathcal F^{(\\text{chan})}_{\\delta}(x)``</span>

<span style="color: #718c00;">where `chan` is `s`, `t`, or `u`."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">F_chiral</span>(x, Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, lr)
    chan = block.channel
    Fs_chiral(crossratio(chan, x), Nmax, block, permute_ext_fields(corr, chan), lr)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Compute the non-chiral conformal block</span>

<span style="color: #718c00;">``\\mathcal F^{(\\text{chan})}_{\\delta}(x) \\overline{\\mathcal F}^{(\\text{chan})}_{\\delta}( \bar x )``</span>

<span style="color: #718c00;">where `chan` is `s`,`t` or `u`.</span>

<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> logarithmic blocks</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">F_four_point_sphere</span>(x, Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>)
    channelprefactor(block, corr, x) <span style="color: #bb9200;">*</span> <span style="color: #bb9200;">\</span>
        F_chiral(x, Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, left) <span style="color: #bb9200;">*</span> <span style="color: #bb9200;">\</span>
        conj(F_chiral(conj(x), Nmax, block<span style="color: #bb9200;">::FourPointBlockSphere</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, right))
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="orgc24110c"></a>End of module<br />
<div class="outline-text-5" id="text-orgc24110c">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-one-point-conformal-blocks-on-the-torus" class="outline-3">
<h3 id="one-point-conformal-blocks-on-the-torus">One-point conformal blocks on the torus</h3>
<div class="outline-text-3" id="text-one-point-conformal-blocks-on-the-torus">
</div>
<div id="outline-container-one-point-blocks-on-the-torus" class="outline-4">
<h4 id="one-point-blocks-on-the-torus">One point blocks on the torus</h4>
<div class="outline-text-4" id="text-one-point-blocks-on-the-torus">
<p>
A chiral one-point conformal block on the torus can be written as
</p>

<p>
\[
\mathcal{F}^\text{torus}_{\Delta}(\Delta_1|q) = q^{\delta}\eta(q)^{-1}H^\text{torus}_{\Delta}(\Delta_1|q)
\]
</p>

<p>
where \(\eta\) is the Dedekind eta function, \(q\) is related to the torus&rsquo; modular parameter \(\tau\) via \(q=e^{2i\pi \tau}\), and the non-trivial factor \(H^{\text{torus}}_{\Delta}(\Delta_1|q)\) can be computed by the following recursion formula:
</p>

<p>
\[
H^\text{torus}_{\Delta}(\Delta_1|q) = 1 + \sum_{N=1}^{N_{max}} \sum_{mn\leq N} C_{m,n}^{N,\text{torus}} \frac{q^N}{\delta-\delta_{(m,n)}}
\]
</p>

<p>
where the coefficient \(C^{N,\text{torus}}_{m,n}\) is given \eqref{org63c160c}.
</p>
</div>
</div>
<div id="outline-container-org8ad3b79" class="outline-4">
<h4 id="org8ad3b79">The <code>OnePointBlocksTorus</code> module</h4>
<div class="outline-text-4" id="text-org8ad3b79">
<p>
The module <code>OnePointBlocksTorus</code> exports
</p>

<ul class="org-ul">
<li>a struct <code>OnePointBlockTorus</code> that encapsulates the data needed to compute a 4pt conformal block, namely an external field.</li>
<li>a function <code>F_one_point_torus(block, charge, x)</code> which computes the value of the non-chiral block \(\mathcal F_{\Delta}^{\text{torus}}(\Delta | q(x))\) as defined in <a href="#orgd08d865">this equation</a>.</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgc13a34d"></a>Header<br />
<div class="outline-text-5" id="text-orgc13a34d">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Series expansion of one-point blocks on the torus</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">module</span> OnePointBlocksTorus

<span style="color: #8959a8;">using</span> ..CFTData, ..OnePointCorrelationFunctions
<span style="color: #8959a8;">import</span> EllipticFunctions: etaDedekind as &#951;

<span style="color: #8959a8;">export</span> F_one_point_torus

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Struct containing the data required to compute a block: an external field</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #8959a8;">struct</span> <span style="color: #bb9200;">OnePointBlockTorus</span>{T}
    channelField<span style="color: #bb9200;">::Field</span>{T}
<span style="color: #8959a8;">end</span>

<span style="color: #07c365;"># </span><span style="color: #07c365;">explicit names for the indices of left and right dimensions</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">left</span> = <span style="color: #f5871f; font-weight: bold;">1</span>
<span style="color: #8959a8;">const</span> <span style="color: #c82829;">right</span> = <span style="color: #f5871f; font-weight: bold;">2</span>
</pre>
</div>
</div>
</li>
<li><a id="org75c80e3"></a>Computation of the block<br />
<div class="outline-text-5" id="text-org75c80e3">
<div class="org-src-container">
<pre class="src src-julia">
<span style="color: #4271ae;">qfromtau</span>(&#964;) = exp(<span style="color: #f5871f; font-weight: bold;">2</span>im<span style="color: #bb9200;">*</span>&#960;<span style="color: #bb9200;">*</span>&#964;)

<span style="color: #07c365;">#</span><span style="color: #07c365;">===========================================================================================</span>
<span style="color: #07c365;">Compute the conformal block</span>
<span style="color: #07c365;">===========================================================================================#</span>
<span style="color: #718c00;">"""Compute the function  ``H^{\text{torus}}(q,&#948;)``."""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">H</span>(q, Nmax, block<span style="color: #bb9200;">::OnePointBlockTorus</span>, corr<span style="color: #bb9200;">::OnePointCorrelation</span>, lr)
    &#948; = block.channelField[<span style="color: #718c00;">"&#948;"</span>][lr]
    B = corr.charge[<span style="color: #718c00;">"B"</span>]
    res = <span style="color: #f5871f; font-weight: bold;">1</span>
    pow = <span style="color: #f5871f; font-weight: bold;">1</span>
    <span style="color: #8959a8;">for</span> N <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:Nmax
        sum_mn = sum(sum(computeCNmn(N, m, n, corr, block.channel, lr)<span style="color: #bb9200;">/</span>(&#948;<span style="color: #bb9200;">-</span>&#948;rs(m, n, B))
                         <span style="color: #8959a8;">for</span> n in <span style="color: #f5871f; font-weight: bold;">1</span>:N <span style="color: #8959a8;">if</span> m<span style="color: #bb9200;">*</span>n <span style="color: #bb9200;">&lt;=</span> N) <span style="color: #8959a8;">for</span> m <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:N)
        pow <span style="color: #bb9200;">*=</span> q
        res <span style="color: #bb9200;">+=</span> pow <span style="color: #bb9200;">*</span> sum_mn
    <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">return</span> res
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">    Fs_chiral(block::FourPointBlockSphere, corr::FourPointCorrelation, x, lr)</span>

<span style="color: #718c00;">Compute the chiral conformal block</span>

<span style="color: #718c00;">``\\mathcal F^{\text{torus}}_{\\delta}(x)``</span>

<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">F_chiral</span>(&#964;, Nmax, block<span style="color: #bb9200;">::OnePointBlockTorus</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>, lr)
    &#948; = block.channelField[<span style="color: #718c00;">"&#948;"</span>][lr]
    <span style="color: #8959a8;">return</span> q<span style="color: #bb9200;">^</span>{&#948;}<span style="color: #bb9200;">/</span>&#951;(&#964;) <span style="color: #bb9200;">*</span> H(qfromtau(&#964;), Nmax, block, corr, lr)
<span style="color: #8959a8;">end</span>

<span style="color: #718c00;">"""</span>
<span style="color: #718c00;">Compute the non-chiral conformal block</span>

<span style="color: #718c00;">`` \\mathcal F_{\\Delta}^{(\\text{chan})}(\\Delta_i| x)``</span>

<span style="color: #718c00;">where ``\\text{chan}`` is `s`,`t` or `u`.</span>

<span style="color: #eab700; font-weight: bold;">TODO:</span><span style="color: #718c00;"> logarithmic blocks</span>
<span style="color: #718c00;">"""</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">F_one_point_torus</span>(&#964;, Nmax, block<span style="color: #bb9200;">::OnePointBlockTorus</span>, corr<span style="color: #bb9200;">::FourPointCorrelation</span>)
    F_chiral(&#964;, Nmax, block, corr, left) <span style="color: #bb9200;">*</span> conj(F_chiral(conj(&#964;), Nmax, block, corr, right))
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
<li><a id="orgf2ba6a5"></a>End of module<br />
<div class="outline-text-5" id="text-orgf2ba6a5">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">end</span> <span style="color: #07c365;"># </span><span style="color: #07c365;">end module</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge53bab8" class="outline-2">
<h2 id="orge53bab8"><span class="section-number-2">5.</span> Special functions</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #07c365;">#</span><span style="color: #07c365;">==================</span>

<span style="color: #07c365;">SpecialFunctions.jl computes the special functions relevant for our applications in 2D CFT.</span>

<span style="color: #07c365;">==================#</span>

<span style="color: #8959a8;">using</span> EllipticFunctions

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">log_double_gamma</span>(beta, w)
<span style="color: #8959a8;">end</span>

<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">double_gamma</span>(beta, w)
    <span style="color: #8959a8;">return</span> exp(log_double_gamma(beta, w))
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org59cc416" class="outline-2">
<h2 id="org59cc416"><span class="section-number-2">6.</span> Unit testing</h2>
<div class="outline-text-2" id="text-6">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">using</span> JuliVirBootstrap
<span style="color: #8959a8;">using</span> Test

<span style="color: #4d4d4c; font-weight: bold;">@testset</span> <span style="color: #718c00;">"CFTData.jl"</span> <span style="color: #8959a8;">begin</span>

    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure the relation between b and &#946; does not change</span>
    c1 = CentralCharge(<span style="color: #718c00;">"c"</span>, <span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1.1</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">2</span>im)
    b = c1[<span style="color: #718c00;">"b"</span>]
    c2 = CentralCharge(<span style="color: #718c00;">"b"</span>, b)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> c1[<span style="color: #718c00;">"c"</span>] <span style="color: #bb9200;">==</span> c2[<span style="color: #718c00;">"c"</span>]
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> c1[<span style="color: #718c00;">"&#946;"</span>] <span style="color: #bb9200;">==</span> c2[<span style="color: #718c00;">"&#946;"</span>]

    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure the relation between p and P does not change</span>
    left = <span style="color: #f5871f; font-weight: bold;">1</span>
    right = <span style="color: #f5871f; font-weight: bold;">2</span>
    V1 = Field(c1, <span style="color: #718c00;">"P"</span>, <span style="color: #f5871f; font-weight: bold;">0.5</span>, diagonal=<span style="color: #f5871f;">true</span>)
    p = V1[<span style="color: #718c00;">"p"</span>][left]
    V2 = Field(c1, <span style="color: #718c00;">"p"</span>, p, diagonal=<span style="color: #f5871f;">true</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> V1[<span style="color: #718c00;">"P"</span>] <span style="color: #bb9200;">==</span> V2[<span style="color: #718c00;">"P"</span>]

    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure the keyword diagonal also works for fields given from Kac indices</span>
    V1 = Field(c1, Kac=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">3</span>, s=<span style="color: #f5871f; font-weight: bold;">4</span>, diagonal=<span style="color: #f5871f;">true</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> V1[<span style="color: #718c00;">"&#916;"</span>][left] <span style="color: #bb9200;">==</span> V1[<span style="color: #718c00;">"&#916;"</span>][right]


    <span style="color: #07c365;">#</span><span style="color: #07c365;">ensure degenerate and diagonal work well together</span>
    V1 = Field(c1, Kac=<span style="color: #f5871f;">true</span>, degenerate=<span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">2</span>, s=<span style="color: #f5871f; font-weight: bold;">5</span>, diagonal=<span style="color: #f5871f;">true</span>)
    <span style="color: #4d4d4c; font-weight: bold;">@test</span> V1[<span style="color: #718c00;">"&#916;"</span>][left] <span style="color: #bb9200;">==</span> V1[<span style="color: #718c00;">"&#916;"</span>][right]

<span style="color: #8959a8;">end</span>

<span style="color: #4d4d4c; font-weight: bold;">@testset</span> <span style="color: #718c00;">"FourPointCorrelationFunctions"</span> <span style="color: #8959a8;">begin</span>

    left=<span style="color: #f5871f; font-weight: bold;">1</span>
    right=<span style="color: #f5871f; font-weight: bold;">2</span>

    c = CentralCharge(<span style="color: #718c00;">"&#946;"</span>, <span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im)
    V1 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im, diagonal=<span style="color: #f5871f;">true</span>)
    V2 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">3.43</span>, diagonal=<span style="color: #f5871f;">true</span>)
    V3 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">0.13</span>, diagonal=<span style="color: #f5871f;">true</span>)
    V4 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">1.3</span>, diagonal=<span style="color: #f5871f;">true</span>)
    corr = FourPointCorrelation(c, V1, V2, V3, V4)

    <span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(JuliVirBootstrap.FourPointCorrelationFunctions.Rmn(<span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">1</span>, corr, <span style="color: #718c00;">"s"</span>, left),
                   <span style="color: #f5871f; font-weight: bold;">0.31097697185245077</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">0.70523695127635733</span>im, <span style="color: #07c365;"># </span><span style="color: #07c365;">value taken from Sylvain's code</span>
                   atol=<span style="color: #f5871f; font-weight: bold;">1e-8</span>)

    <span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(JuliVirBootstrap.FourPointCorrelationFunctions.Rmn(<span style="color: #f5871f; font-weight: bold;">3</span>, <span style="color: #f5871f; font-weight: bold;">3</span>, corr, <span style="color: #718c00;">"t"</span>, left),
                   <span style="color: #f5871f; font-weight: bold;">4.3964194233662846e-5</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1.1534661157146291e-5</span>im, <span style="color: #07c365;"># </span><span style="color: #07c365;">value taken from Sylvain's code</span>
                   atol=<span style="color: #f5871f; font-weight: bold;">1e-8</span>)

    <span style="color: #4d4d4c; font-weight: bold;">@test</span> isapprox(JuliVirBootstrap.FourPointCorrelationFunctions.computeCNmn(<span style="color: #f5871f; font-weight: bold;">7</span>, <span style="color: #f5871f; font-weight: bold;">2</span>, <span style="color: #f5871f; font-weight: bold;">3</span>, corr, <span style="color: #718c00;">"s"</span>, left),
                   <span style="color: #f5871f; font-weight: bold;">0.0019498393368877166</span><span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">0.0026353877950837049</span>im, <span style="color: #07c365;"># </span><span style="color: #07c365;">value taken from Sylvain's code</span>
                   atol=<span style="color: #f5871f; font-weight: bold;">1e-8</span>)

<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5525354" class="outline-2">
<h2 id="org5525354"><span class="section-number-2">7.</span> Development tests</h2>
<div class="outline-text-2" id="text-7">
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">import</span> Pkg; Pkg.activate(<span style="color: #718c00;">"."</span>)
<span style="color: #8959a8;">using</span> JuliVirBootstrap
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">using</span> JuliVirBootstrap, BenchmarkTools, EllipticFunctions, Profile, ProfileView
<span style="color: #8959a8;">import</span> Memoization: <span style="color: #4d4d4c; font-weight: bold;">@memoize</span>

left=<span style="color: #f5871f; font-weight: bold;">1</span>;
right=<span style="color: #f5871f; font-weight: bold;">2</span>;

c = CentralCharge(<span style="color: #718c00;">"&#946;"</span>, big(<span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im));
V1 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im, diagonal=<span style="color: #f5871f;">true</span>);
V2 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">3.43</span>, diagonal=<span style="color: #f5871f;">true</span>);
V3 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">0.13</span>, diagonal=<span style="color: #f5871f;">true</span>);
V4 = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">1.3</span>, diagonal=<span style="color: #f5871f;">true</span>);
V = Field(c, <span style="color: #718c00;">"&#916;"</span>, <span style="color: #f5871f; font-weight: bold;">0.1</span>, diagonal = <span style="color: #f5871f;">true</span>);

x = BigFloat(<span style="color: #718c00;">"0.05"</span>, RoundUp);
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">test</span>()
    corr = FourPointCorrelation(c, V1, V2, V3, V4)
    block = FourPointBlockSphere(<span style="color: #718c00;">"s"</span>, V)
    calc = JuliVirBootstrap.FourPointBlocksSphere.Fs_chiral(x, <span style="color: #f5871f; font-weight: bold;">5</span>, block, corr, left);
<span style="color: #8959a8;">end</span>;
</pre>
</div>

<pre class="example">
  1.072 ms (14067 allocations: 780.81 KiB)
2337.403601860713925958391009719678809055546365124340617423994215164154638728732 + 4771.392251761078219452023733430973991671048305871845481326523306698785531079742im
</pre>
</div>
<div id="outline-container-orgb9ac7c1" class="outline-3">
<h3 id="orgb9ac7c1">Relation between four-point blocks on the sphere and one-point blocks on the torus</h3>
<div class="outline-text-3" id="text-orgb9ac7c1">
<p>
Four point blocks on the sphere are related to one-point blocks on the torus through the relation
</p>

<p>
\[
\mathcal H^{\text{torus}}_{c, P}(P_{1} | q^{2}) = \mathcal H_{c', \sqrt{2}P'}\left(\left. P'_{(0,\frac12)}, \left(\frac{P_{1}}{\sqrt{2}}\right)', P'_{(0,\frac12)}, P'_{(0,\frac12)} \right| q \right)
\]
</p>

<p>
where
</p>
<ul class="org-ul">
<li>\(c'\) is related to \(c\) via \(\beta'=\frac\beta{\sqrt 2}\).</li>
<li>\(P'\) denotes the Virasoro module with primary field of dimension \(\Delta'(P') = \frac{c'-1}{24} - P'^{2}\)</li>
</ul>

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">import</span> JuliVirBootstrap.FourPointBlocksSphere.qfromx
c_torus = CentralCharge(<span style="color: #718c00;">"b"</span>, big(<span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im));
c_sphere = CentralCharge(<span style="color: #718c00;">"b"</span>, big(<span style="color: #f5871f; font-weight: bold;">1.2</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span><span style="color: #f5871f; font-weight: bold;">1</span>im)<span style="color: #bb9200;">/</span>sqrt(<span style="color: #f5871f; font-weight: bold;">2</span>))

V_torus_ext = Field(c1, <span style="color: #718c00;">"P"</span>,  <span style="color: #f5871f; font-weight: bold;">0.23</span><span style="color: #bb9200;">+</span>.<span style="color: #f5871f; font-weight: bold;">11</span>im, diagonal=<span style="color: #f5871f;">true</span>)
V_torus_chan = Field(c1, Kac = <span style="color: #f5871f;">true</span>, r=<span style="color: #f5871f; font-weight: bold;">0</span>, s=<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">2</span>)


</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Paul ROUX</p>
<p class="date">Created: 2024-03-01 Fri 10:31</p>
</div>
</body>
</html>
